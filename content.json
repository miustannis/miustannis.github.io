{"meta":{"title":"Miao's Blog","subtitle":null,"description":"","author":"miao","url":"https://miustannis.github.io","root":"/"},"pages":[{"title":"tags","date":"2024-08-31T13:20:15.000Z","updated":"2024-08-31T13:20:27.842Z","comments":true,"path":"tags/index.html","permalink":"https://miustannis.github.io/tags/index.html","excerpt":"","text":""},{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2024-08-31T13:23:24.772Z","comments":true,"path":"404/index.html","permalink":"https://miustannis.github.io/404/index.html","excerpt":"","text":""},{"title":"About","date":"2022-03-23T16:01:54.000Z","updated":"2025-08-16T15:49:13.836Z","comments":true,"path":"about/index.html","permalink":"https://miustannis.github.io/about/index.html","excerpt":"","text":"🎓Education： Soochow University &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Suzhou, China &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sep 2020 - Jun 2024 Bachelor of Engineering in Electrical Engineering &amp; Automation &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPA: 3.8 / 4.0 📃Publication： Fang J, Zhou S, Miao Y, et al. A continuous hemodynamic parameters algorithm based on the wearable tonometric device[C]//2024 IEEE 3rd International Conference on Micro/Nano Sensors for AI, Healthcare, and Robotics (NSENS). IEEE, 2024: 14-17. Yu C, Deng M, Zhou S, Miao Y, et al. Integrated Stretchable and Adhesive Ionic Gel Epidermal Electrode for Cardiovascular Monitoring[C]//2025 IEEE International Conference on Flexible and Printable Sensors and Systems (FLEPS). IEEE, 2025: 1-4."},{"title":"categories","date":"2022-04-01T03:49:27.000Z","updated":"2024-08-31T13:32:40.374Z","comments":true,"path":"categories/index.html","permalink":"https://miustannis.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"写一个小轮子：模拟实现ls-l 指令","slug":"250915","date":"2025-09-14T13:19:05.000Z","updated":"2025-09-15T14:21:57.330Z","comments":true,"path":"2025/09/14/250915/","link":"","permalink":"https://miustannis.github.io/2025/09/14/250915/","excerpt":"","text":"概述在Linux系统中，ls -l命令是我们日常使用最频繁的命令之一，它能够以长格式显示文件的详细信息。本文将深入解析ls -l的实现原理，并逐步讲解如何用C语言实现一个简化版的ls -l命令。 // 输出示例：-rw-rw-r-- 1 miao miao 4 9月 15 20:28 a.txt #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;unistd.h> #include &lt;stdio.h> #include &lt;pwd.h> #include &lt;grp.h> #include &lt;time.h> #include &lt;string.h> int main(int argc, char* argv[])&#123; if (argc &lt; 2)&#123; printf(\"%s filename\\n\", argv[0]); return -1; &#125; // 通过stat函数获取文件信息 struct stat st; int ret = stat(argv[1], &amp;st); if (ret == -1)&#123; perror(\"stat\"); return -1; &#125; // 1. 文件类型 char perms[12] = &#123;0&#125;; switch (st.st_mode &amp; __S_IFMT)&#123; case __S_IFLNK: perms[0] = 'l'; // 符号链接 break; case __S_IFDIR: perms[0] = 'd'; // 目录 break; case __S_IFREG: perms[0] = '-'; // 普通文件 break; case __S_IFBLK: perms[0] = 'b'; // 块设备 break; case __S_IFCHR: perms[0] = 'c'; // 字符设备 break; case __S_IFSOCK: perms[0] = 's'; // 套接字 break; case __S_IFIFO: perms[0] = 'p'; // 管道 break; default: perms[0] = '?'; // 未知类型 break; &#125; // 2. 文件权限 // 文件所有者权限 perms[1] = (st.st_mode &amp; S_IRUSR) ? 'r' : '-'; perms[2] = (st.st_mode &amp; S_IWUSR) ? 'w' : '-'; perms[3] = (st.st_mode &amp; S_IXUSR) ? 'x' : '-'; // 文件所在组权限 perms[4] = (st.st_mode &amp; S_IRGRP) ? 'r' : '-'; perms[5] = (st.st_mode &amp; S_IWGRP) ? 'w' : '-'; perms[6] = (st.st_mode &amp; S_IXGRP) ? 'x' : '-'; // 其他人权限 perms[7] = (st.st_mode &amp; S_IROTH) ? 'r' : '-'; perms[8] = (st.st_mode &amp; S_IWOTH) ? 'w' : '-'; perms[9] = (st.st_mode &amp; S_IXOTH) ? 'x' : '-'; perms[10] = '\\0'; // 字符串结束符 // 3. 硬链接数 int linknum = st.st_nlink; // 4. 文件所有者名称 char* fileuser = getpwuid(st.st_uid)->pw_name; // 5. 文件所在组 char* filegroup = getgrgid(st.st_gid)->gr_name; // 6. 文件大小 long int filesize = st.st_size; // 7. 修改时间 char* time = ctime(&amp;st.st_mtime); char mtime[512] = &#123;0&#125;; strncpy(mtime, time, strlen(time) - 1); // 去除末尾的换行符 // 格式化输出 char buf[1024]; sprintf(buf, \"%s %d %s %s %ld %s %s\", perms, linknum, fileuser, filegroup, filesize, mtime, argv[1]); printf(\"%s\\n\", buf); return 0; &#125; 1. stat系统调用stat()函数是获取文件信息的核心系统调用，它填充一个stat结构体，包含文件的所有元数据： 文件类型和权限(st_mode) 硬链接数量(st_nlink) 所有者和组ID(st_uid, st_gid) 文件大小(st_size) 最后修改时间(st_mtime) 2. 文件类型识别通过st_mode &amp; __S_IFMT这种掩码的方式，可以提取文件类型信息，常见的文件类型包括： 普通文件(-) 目录(d) 符号链接(l) 字符设备(c) 块设备(b) 套接字(s) 管道(p) 3. 权限位处理文件权限分为三组：所有者、组和其他用户，每组包含读(r)、写(w)和执行(x)权限。通过位掩码操作可以检查每位权限设置。 4. 用户和组信息转换使用getpwuid()和getgrgid()函数将UID和GID转换为可读的用户名和组名。 5. 时间格式处理ctime()将时间戳转换为可读字符串，但包含换行符，需要去除末尾的换行符。 示例： ll输出： 脚本输出：","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://miustannis.github.io/tags/CS/"},{"name":"Linux","slug":"Linux","permalink":"https://miustannis.github.io/tags/Linux/"}]},{"title":"KMP算法 Study Log","slug":"250810","date":"2025-08-10T03:38:44.000Z","updated":"2025-08-18T14:29:23.141Z","comments":true,"path":"2025/08/10/250810/","link":"","permalink":"https://miustannis.github.io/2025/08/10/250810/","excerpt":"","text":"什么是字符串匹配 暴力解法 KMP算法 具体实现 补充： &nbsp; KMP（Knuth-Morris-Pratt）算法是一种高效的字符串匹配算法，用于在一个主串中查找一个模式串的位置。它通过预处理模式串，避免了在匹配失败时重复比较已经匹配的部分，从而提高了匹配效率。 该算法在1977年被提出，取三位贡献者的姓名首字母组成算法名称。 什么是字符串匹配字符串匹配问题是计算机科学中的一个经典问题，其核心目标是在一个较长的文本串（Text）中查找是否存在一个或多个与给定模式串（Pattern）完全相同的子串。 例如： 文本串（T）：&quot;ABABDABACDABABCABAB&quot; 模式串（P）：&quot;ABABCABAB&quot; 那么模式串可以在文本串的索引11处匹配 &nbsp; 暴力解法知道控制语句用法的人都知道，这个问题可以套两层循环来解决，从文本串的第1个字符开始，与模式串逐字符比对，如果发现不匹配，则从文本串的第2个字符开始重新比对，以此类推，该解法时间复杂度为$O(m*n)$，效率较低。 &nbsp; KMP算法KMP算法通过预处理模式串，利用已经匹配的信息，减少重复比较，将时间复杂度优化至$O(m+n)$ 其核心思想有两点： 构造模式串的部分匹配表，也叫做前缀表，这个表记录了模式串的最长公共前后缀的长度 利用失败信息，当字符不匹配时，根据部分匹配表移动模式串指针的位置，而不需要回溯文本串的位置 下图可以清晰地看出前缀表的含义： &nbsp; 具体实现构造模式串的部分匹配表，即前缀表： void getprefix(const string &amp;s, int *prefix)&#123; int fend = 0; prefix[0] = 0; for (int bend = 1; bend &lt; s.size(); bend++)&#123; while (fend > 0 &amp;&amp; s[fend] != s[bend])&#123; fend = prefix[fend - 1]; &#125; if (s[bend] == s[fend]) fend++; prefix[bend] = fend; &#125; &#125; 这其中有一些类似递归的思想，当我们手动实现前缀表时，当遇到前缀最后一个字符与后缀字符不匹配的情况时，我们只需要去找他前一位的前缀表的值所指引的位置，从那个位置再次开始对比。 道理和字符串匹配中的应用是一样的，因为前一位存放的是在当前字符之前的子串最大相等前后缀的长度，索引之后代表你可以跳过对比几个前后缀都有的字符，提高效率。 在具体字符串匹配问题中，运用也是一个道理： int strStr(string haystack, string needle) &#123; if (needle.size() == 0) return 0; if (needle.size() > haystack.size()) return -1; vector&lt;int> prefix(needle.size()); getprefix(needle, &amp;prefix[0]); int index = 0; for (int i = 0; i &lt; haystack.size() ; i++)&#123; while (index > 0 &amp;&amp; haystack[i] != needle[index]) &#123; index = prefix[index - 1]; &#125; if (haystack[i] == needle[index]) index++; if (index == needle.size()) return (i - index + 1); &#125; return -1; &#125; &nbsp; 补充：由这个经典问题可推出：一个字符串是否由某个子串重复构成问题的解法。 结论是，如果一个字符串在去掉其最长相等前后缀的长度后，剩余的子串长度能被原始长度整除，那么原始字符串就能被这个剩余的子串重复表示。 充分性证明，即如果某字符串去掉最长相等前后缀后的剩余子串长度能整除原始长度，则原始字符串可由该剩余子串重复表示。 必要性证明，即如果字符串能被某个子串重复表示，则去掉字符串的最长相等前后缀后的剩余子串长度必能整除原始长度。 必要性显然，因此充分必要性均满足，证毕。","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://miustannis.github.io/tags/Algorithm/"}]},{"title":"用APP Inventor快速开发一款BLE安卓应用","slug":"250718","date":"2025-07-18T03:38:44.000Z","updated":"2025-09-15T14:07:58.798Z","comments":true,"path":"2025/07/18/250718/","link":"","permalink":"https://miustannis.github.io/2025/07/18/250718/","excerpt":"","text":"出于科研项目要求，我需要开发一个能个性化定制界面与功能的BLE手机上位机软件，在经过简单的调研后，主要有以下两种开发路径： Android Studio MIT APP Inventor 其中AS需要Java基础，且开发周期长；MIT APP Inventor图形化编程，20min可上手，于是我选择后者，最终也能达到我想要的效果。 选择建议如下： 选 Android Studio：如果你想成为专业开发者，或开发功能复杂、可发布的商业应用。 选 MIT App Inventor：如果你是学生，或只想快速做一个简单应用 于是在B站看了几个包浆的教学视频后，我开始上手制作，过程意外地顺利 首先，你需要明确你的APP要包含哪些模块 如下图所示，在登陆官网后，你可以把你需要的模块在侧边栏拖入主页面 依次描述我的思路 上图中组件1是BLE设备搜索与断联按钮 2是BLE连接状态，3是波形图，4是实时数值，5是清空按钮； 当然也有后端组件Ⅰ，是BLE模块，这个在官网没有，需要下载拓展包，https://iot.appinventor.mit.edu/ 这个网站里可以找到，组件Ⅱ相当于画图所用到的数据列表。 &nbsp; 在完成组件选择与视图构造后，进入下一步逻辑编程，这里不再赘述，和一些少儿编程培训用的Scratch基本是一个套路，特别注意BLE设备的gatt协议uuid需要根据产品厂商提供的数值修改 最终效果如下，其实整体耗时应该不到半天，向互联网开源精神致敬。","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://miustannis.github.io/tags/Android/"}]},{"title":"MFCC音频特征提取流程demo","slug":"250710","date":"2025-07-10T03:38:44.000Z","updated":"2025-08-20T04:14:33.829Z","comments":true,"path":"2025/07/10/250710/","link":"","permalink":"https://miustannis.github.io/2025/07/10/250710/","excerpt":"","text":"MFCC的核心思想是模仿人耳对声音的非线性感知特性（人耳对低频声音比高频声音更敏感），从而更好地表示语音特征。其流程可以概括为以下步骤： 分帧 目的：语音信号是非平稳信号，其特性是随时间变化的。但在一个非常短的时间段内，可以近似认为是平稳的。分帧就是将长信号切分成许多短片段来分析。 操作：使用一个固定长度的窗口以一定的帧移沿着信号滑动并截取数据。 加窗 目的：减少每一帧信号在其两端处的频谱泄漏，使帧两端平滑地衰减到零，从而降低后续傅里叶变换后旁瓣的强度。 操作：将每一帧信号乘上一个窗函数。 傅里叶变换和功率谱计算 目的：将信号从时域转换到频域。 操作： 对每一帧加窗后的信号进行FFT，得到复数频谱。 然后计算其功率谱（取模的平方）。P = |FFT(frame)|² / N （N是FFT点数） 梅尔滤波器组滤波 目的：模拟人耳的听觉特性。人耳对于不同频率的感知能力是不同的，在低频区域区分度高，在高频区域区分度低。梅尔刻度是一种将实际频率转换为更符合人耳感知的频率刻度。 操作： 定义一组三角带通滤波器（梅尔滤波器组），这些滤波器在梅尔刻度上是等宽的，但在线性频率刻度上是不等宽的（低频区域滤波器窄且密集，高频区域宽且稀疏）。 将上一步得到的功率谱与每一个梅尔滤波器进行积分（实际上是相乘并求和），得到每个滤波器输出的能量。这样就将频谱压缩为n个更能反映人耳听觉特性的滤波器组能量。 离散余弦变换 目的：对梅尔滤波器组能量取对数后，进行离散余弦变换 (DCT)。这一步也称为倒谱分析。 取对数：因为人耳对声音强度的感知也是对数的。同时，对数操作可以将卷积信号（声源激励和声道滤波）转化为可加的。 DCT：对取对数后的滤波器组能量进行DCT，相当于对频谱进行“压缩”。DCT的结果中，低维（前几个）系数代表了包络信息（反映了声道形状，是语音内容的关键），而高维系数代表了细节信息（如激励源）。 最终的输出通常只保留DCT后的前12-13个系数，再加上一个能量项（第0项或直接从时域帧中计算），共同构成最终的MFCC特征向量。 这个流程为音频信号的每一帧都计算出了一个固定维度的MFCC特征向量，这些向量序列就可以用于后续的语音识别、说话人识别等机器学习任务。 &nbsp; 下面是在一个项目中使用MFCC方法进行特征提取的预处理部分，这里用的不是标准MFCC，省去了最后的DCT部分，更直接简单。这个处理流程是在python仿真后迁移的，python中运用了librosa库，不过该库里面有一些隐式处理，因此在转换成C版本代码时遇到了较多不匹配的情况，不过调试中也是逐步改进了。 分帧函数如下，实际使用时调整传参使其能够保持60%的重合率，让每一帧平滑过渡，不过这个函数只计算帧数，真正的分帧操作在下面的流式处理里面循环执行。 // 分帧函数，使用局部缓存处理每一帧数据 int frame_signal(const int16_t* y, int y_len, int frame_length, int hop_length, int* n_frames) &#123; *n_frames = 1 + (y_len - frame_length) / hop_length; return 0; // 假设不会出错 &#125; //n_frames 经过处理后为实际帧数 //实际运行时，hoplength和framlength定义如下 // #define WIN_LENGTH 400 窗长400 // #define HOP_LENGTH 160 帧移160 &nbsp; 手动FFT实现，经典的Cooley-Tukey迭代FFT算法，采用了位反转置换和蝶形运算： // Complex结构体定义 typedef struct &#123; float real; float imag; &#125; Complex; void fft(Complex* x) &#123; // 预先计算旋转因子 static Complex W[N_FFT/2]; static int initialized = 0; if (!initialized) &#123; for (int k = 0; k &lt; N_FFT/2; k++) &#123; float angle = -2 * PI * k / N_FFT; W[k].real = cosf(angle); W[k].imag = sinf(angle); &#125; initialized = 1; &#125; // 位反转置换 int j = 0; for (int i = 0; i &lt; N_FFT - 1; i++) &#123; if (i &lt; j) &#123; Complex temp = x[i]; x[i] = x[j]; x[j] = temp; &#125; int k = N_FFT >> 1; while (k &lt;= j) &#123; j -= k; k >>= 1; &#125; j += k; &#125; // 迭代FFT for (int stride = 2; stride &lt;= N_FFT; stride &lt;&lt;= 1) &#123; int half_stride = stride >> 1; int W_step = N_FFT / stride; for (int k = 0; k &lt; N_FFT; k += stride) &#123; for (int m = 0; m &lt; half_stride; m++) &#123; int idx_e = k + m; int idx_o = idx_e + half_stride; int W_idx = m * W_step; Complex t = &#123; W[W_idx].real * x[idx_o].real - W[W_idx].imag * x[idx_o].imag, W[W_idx].real * x[idx_o].imag + W[W_idx].imag * x[idx_o].real &#125;; x[idx_o].real = x[idx_e].real - t.real; x[idx_o].imag = x[idx_e].imag - t.imag; x[idx_e].real += t.real; x[idx_e].imag += t.imag; &#125; &#125; &#125; &#125; &nbsp; Mel功率谱计算，函数中的汉明窗与Mel滤波器组都是事先生成的。 // 计算Mel功率谱 void manual_melspectrogram(const int16_t* y, int y_len, int sr, float* mel_spec, int* n_mels_out, int* n_frames_out) &#123; int n_frames; // 计算最大绝对值（用于归一化） float max_val = 0.0f; for (int i = 0; i &lt; y_len; i++) &#123; float abs_val = fabsf((float)y[i]); if (abs_val > max_val) &#123; max_val = abs_val; &#125; &#125; // 分配并归一化为 float 缓冲区 static float y_norm[8000]; // 假设最大长度8000 if (y_len > 8000) &#123; *n_frames_out = 0; return; // 防止越界 &#125; if (max_val > 0.0f) &#123; for (int i = 0; i &lt; y_len; i++) &#123; y_norm[i] = (float)y[i] / max_val; &#125; &#125; else &#123; for (int i = 0; i &lt; y_len; i++) &#123; y_norm[i] = 0.0f; &#125; &#125; // 计算帧数 frame_signal(y, y_len, WIN_LENGTH, HOP_LENGTH, &amp;n_frames); // 注意这里使用原 y，因为只用于 n_frames 计算 *n_mels_out = N_MELS; *n_frames_out = n_frames; // 建立FFT缓冲区 static Complex fft_input[N_FFT]; static float power_spectrum[MEL_BINS]; for (int t = 0; t &lt; n_frames; t++) &#123; // 加窗处理（改为使用 y_norm） for (int n = 0; n &lt; WIN_LENGTH; n++) &#123; fft_input[n].real = y_norm[t * HOP_LENGTH + n] * HAMMING_WINDOW[n]; fft_input[n].imag = 0.0f; &#125; // 清零剩余部分 for (int n = WIN_LENGTH; n &lt; N_FFT; n++) &#123; fft_input[n].real = 0.0f; fft_input[n].imag = 0.0f; &#125; // FFT计算 fft(fft_input); // 计算功率谱 (直接存储到power_spectrum) for (int k = 0; k &lt; MEL_BINS; k++) &#123; float re = fft_input[k].real / N_FFT; float im = fft_input[k].imag / N_FFT; power_spectrum[k] = re * re + im * im; &#125; // 梅尔滤波 (直接计算到输出mel_spec) for (int m = 0; m &lt; N_MELS; m++) &#123; float mel_energy = 0.0f; for (int k = 0; k &lt; MEL_BINS; k++) &#123; mel_energy += power_spectrum[k] * mel_filter[m][k]; &#125; mel_spec[m * n_frames + t] = mel_energy; &#125; &#125; &#125; &nbsp; 最终处理函数，这里是将上面流程输出的值每帧取均值后放入后续神经网络的input。 #include \"algo.h\" #include \"MFCC.h\" #include &lt;stdint.h> #define FRAME_LENGTH 8000 #define N_MELS 40 // 静态缓冲区，用于存储帧、梅尔频谱和对数梅尔特征 //static float frame_global[FRAME_LENGTH]; float mel_spec_global[N_MELS * MAX_FRAMES]; //static float mean_log_mel_global[N_MELS]; int speaker_recognition_run(int16_t* pcm_data, int len) &#123; // 确保只有一帧数据 if (len != FRAME_LENGTH) &#123; printf(\"lengtherror: need %d ，current %d\\n\", FRAME_LENGTH, len); return -1; // 如果数据长度不匹配，返回错误 &#125; // 计算梅尔频谱 int sr = 8000; int n_mels, n_frames; // 直接在全局缓冲区上操作，避免分配新内存 manual_melspectrogram(pcm_data, len, sr, mel_spec_global, &amp;n_mels, &amp;n_frames); // 计算对数梅尔特征 float* log_mel_features = compute_log_mel_mean(mel_spec_global, n_mels, n_frames); if (!log_mel_features) &#123; // 处理错误 printf(\"log error\\n\"); return 1; &#125; // Prepare input (1 sample, 40 features) float input[BATCH_SIZE * SEQ_LENGTH * INPUT_DIM]; for (int i = 0; i &lt; INPUT_DIM; i++) &#123; input[i] = log_mel_features[i]; &#125; free(log_mel_features); // Output array for the classification results float output[BATCH_SIZE * NUM_CLASSES]; // Forward pass through the model forward(input, output, BATCH_SIZE, SEQ_LENGTH); // FindMax float max = output[0]; int out = 0; for (int j = 1; j &lt; NUM_CLASSES; j++) &#123; if (max &lt; output[j]) &#123; max = output[j]; // 更新最大值 out = j; // 更新输出的索引 &#125; &#125; return out; &#125; 其中compute_log_mel_mean函数如下定义： // 计算对数梅尔特征并取均值 float* compute_log_mel_mean(float* mel_spec, int n_mels, int n_frames) &#123; if (n_mels &lt; 40) &#123; fprintf(stderr, \"The audio is too short to extract Mel features.\\n\"); return NULL; &#125; float* mean_log_mel = (float*)malloc(40 * sizeof(float)); // 保留40个梅尔频率带 // 计算每个梅尔频率带的对数均值 for (int i = 0; i &lt; n_mels; ++i) &#123; float sum = 0.0f; for (int j = 0; j &lt; n_frames; ++j) &#123; float value = mel_spec[i * n_frames + j]; // 按列优先排列 value = log10f(value + 1e-6); // 加上一个小常数以避免对数的零值 sum += value; &#125; mean_log_mel[i] = sum / n_frames * SCALE_FACTOR; // 按帧数取均值并进行缩放 &#125; return mean_log_mel; &#125; 其中SCALE_FACTOR 10.0 是比例因子，用于补偿与 Python 输出的差异。 当时仿真效果还可以，就没有再考虑添加DCT转换为标准MFCC，主打能跑就行。","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://miustannis.github.io/tags/Algorithm/"}]},{"title":"Pulp Compilation 从零开始的刷题之路","slug":"250621","date":"2025-06-21T13:19:05.000Z","updated":"2025-09-27T13:17:06.972Z","comments":true,"path":"2025/06/21/250621/","link":"","permalink":"https://miustannis.github.io/2025/06/21/250621/","excerpt":"","text":"1. 数学 2. 数组 3. 链表 4. 哈希散列 5. 栈与队列 6. 类与OOP应用 7. 二叉树 8. 回溯 9. 贪心 10. 动态规划 11. 单调栈 12. 图论 12.1 理论基础 12.2 深度优先搜索理论基础 12.3 广度优先搜索理论基础 12.4 并查集理论基础 12.5 案例 1. 数学1.1 基础有一天, 小明收到一张奇怪的信, 信上要小明计算出给定数各个位上数字为偶数的和。例如：5548，结果为12，等于 4 + 8 。小明很苦恼，想请你帮忙解决这个问题 #include &lt;iostream> using namespace std; int main()&#123; int n, sum = 0; //input while(cin >> n)&#123; // calculation while (n != 0)&#123; int res = 0; res = n % 10; if ((res % 2) == 0) sum += res; n = (n - res) / 10; &#125; cout &lt;&lt; sum &lt;&lt; endl; cout &lt;&lt; endl; sum = 0; &#125; return 0; &#125; 1.2 计数质数给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。 枚举法 考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x−1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)，无法通过所有测试数据。 根据数学特性更改枚举范围，可以一定程度上降低时间复杂度，不过依旧超时 class Solution &#123; public: int judge(int x)&#123; for (int i = 2; i * i &lt;= x; i++)&#123; if (x % i == 0) return 0; &#125; return 1; &#125; int countPrimes(int n) &#123; int result = 0; if (n == 0 || n == 1) result = 0; else&#123; for (int i = 2 ; i &lt; n; i++)&#123; result += judge(i); &#125; &#125; return result; &#125; &#125;; 埃氏筛 leetcode官方题解： 枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。 我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。 我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。 这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 y 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 x 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。 当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。 链接：https://leetcode.cn/problems/count-primes/solutions/507273/ji-shu-zhi-shu-by-leetcode-solution/ class Solution &#123; public: int countPrimes(int n) &#123; vector&lt;int> isPrime(n, 1); int ans = 0; for (int i = 2; i &lt; n; i++) &#123; if (isPrime[i]) &#123; ans += 1; if ((long long)i * i &lt; n) &#123; for (int j = i * i; j &lt; n; j += i) &#123; isPrime[j] = 0; &#125; &#125; &#125; &#125; return ans; &#125; &#125;; &nbsp; 2. 数组2.1 基础1编写一个程序，模拟打印一个正方形的框。程序应该接受用户输入的正整数作为正方形的边长，并打印相应大小的正方形框。 请注意，内部为空白，外部是由 “*” 字符组成的框。 #include &lt;iostream> using namespace std; int main()&#123; //input int n; cin >> n; int num = n; do&#123; if( (num == 1) || (num == n) ) &#123; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; '*'; &#125; cout &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt;= n; i++)&#123; if ((i == 0) || (i == (n-1))) cout &lt;&lt; '*'; else cout &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125; num --; &#125; while (num) ; &#125; 2.2 基础2给定一个整数数组，编写一个程序实现以下功能： 将输入的整数数组倒序输出，每个数之间用空格分隔。 从正序数组中，每隔一个单位（即索引为奇数的元素），输出其值，同样用空格分隔。 /* 理解错了，我以为是排序，实际上是按输入顺序逆序 */ #include &lt;iostream> using namespace std; int main()&#123; int n; cin >> n; if ((n>=1) &amp;&amp; ( n&lt;=1000))&#123; int origin[n]; for (int i = 0; i &lt; n; i++)&#123; cin >> origin[i]; &#125; //reverse int max = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = i + 1 ; j &lt; n; j++)&#123; if (origin[j] > origin[i])&#123; max = origin[j]; origin[j] = origin[i]; origin[i] = max; &#125; &#125; &#125; //output for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; origin[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; //reverse int min = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = i + 1 ; j &lt; n; j++)&#123; if (origin[j] &lt; origin[i])&#123; min = origin[j]; origin[j] = origin[i]; origin[i] = min; &#125; &#125; &#125; //step output for (int i = 0; i &lt; n; i++)&#123; if((i % 2) == 0) cout &lt;&lt; origin[i] &lt;&lt; ' '; &#125; &#125; &#125; 2.3 基础3给定一个整数数组，编写一个程序实现以下功能： 将输入的整数数组倒序输出，每个数之间用空格分隔。 从正序数组中，每隔一个单位（即索引为奇数的元素），输出其值，同样用空格分隔。 //我的程序 #include &lt;iostream> using namespace std; int main()&#123; int n; cin >> n; if ((n>=1) &amp;&amp; ( n&lt;=1000))&#123; int origin[n]; for (int i = 0; i &lt; n; i++)&#123; cin >> origin[i]; &#125; for (int i = n-1; i >= 0; i--)&#123; cout &lt;&lt; origin[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; n; i++)&#123; if ((i % 2) == 0) cout &lt;&lt; origin[i] &lt;&lt;' ' ; &#125; &#125; &#125; //题解 //vector(被称为容器)，做为C++ 标准库中的一个容器类，表示对象的集合，它可以动态地存储一组元素，所以可以根据需要轻松地调整 vector 的大小。 #include &lt;iostream> #include &lt;vector> using namespace std; int solution()&#123; vector&lt;int> origin; int n, num; cin >> n; if ((n>=1) &amp;&amp; ( n&lt;=1000))&#123; for (int i = 0; i &lt; n; i++)&#123; // 这里的长度不能用origin.size() cin >> num; origin.push_back(num); &#125; for (int i = origin.size()-1; i >= 0; i--)&#123; cout &lt;&lt; origin[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; origin.size(); i++)&#123; if ((i % 2) == 0) cout &lt;&lt; origin[i] &lt;&lt;' ' ; &#125; &#125; return 0; &#125; 2.4 基础4小明很喜欢玩积木。一天，他把许多积木块组成了好多高度不同的堆，每一堆都是一个摞一个的形式。然而此时，他又想把这些积木堆变成高度相同的。但是他很懒，他想移动最少的积木块来实现这一目标，你能帮助他吗？ /* 算法非常简单，求均值偏移数 注意计数后的清零，非常重要 */ #include &lt;iostream> #include &lt;vector> using namespace std; int main()&#123; int n, num, sum = 0, steps = 0; while (cin >> n)&#123; if (n == 0) break; // input &amp; sum vector&lt;int> nums; for (int i = 0; i &lt; n; i++)&#123; cin >> num; nums.push_back(num); sum += nums[i]; &#125; int average = sum / n; sum = 0; steps = 0; //step calculation: for (int i = 0; i &lt; n; i++)&#123; if (nums[i] > average) steps += (-average + nums[i]); &#125; cout &lt;&lt; steps &lt;&lt; endl; cout &lt;&lt; endl; &#125; return 0; &#125; 2.5 二分查找给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果 target 存在返回下标，否则返回 -1。 你必须编写一个具有 O(log n) 时间复杂度的算法。 class Solution &#123; public: int search(vector&lt;int>&amp; nums, int target) &#123; int left = 0; int right = nums.size() - 1; int middle = left + (right - left) / 2 ; while (left &lt;= right)&#123; if (target > nums[middle])&#123; left = middle+1; middle = left + (right - left) / 2 ; &#125; else if (target &lt; nums[middle])&#123; right = middle-1; middle = left + (right - left) / 2 ; &#125; else return middle; &#125; return -1; &#125; &#125;; 2.6 移除元素双指针法 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。 假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行以下操作： 更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。nums 的其余元素和 nums 的大小并不重要。 返回 k。 class Solution &#123; public: int removeElement(vector&lt;int>&amp; nums, int val) &#123; int slowindex = 0; for (int fastindex = 0; fastindex &lt; nums.size(); fastindex++) &#123; if (nums[fastindex] != val) &#123; nums[slowindex] = nums[fastindex]; slowindex++; &#125; &#125; return slowindex; &#125; &#125;; 2.7 有序数组的平方给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 暴力： class Solution &#123; public: vector&lt;int> sortedSquares(vector&lt;int>&amp; nums) &#123; for (int i = 0; i &lt; nums.size(); i++)&#123; nums[i] *= nums[i]; &#125; sort(nums.begin(),nums.end()); return nums; &#125; &#125;; 双指针： //时间复杂度为O(n) class Solution &#123; public: vector&lt;int> sortedSquares(vector&lt;int>&amp; nums) &#123; int length = nums.size(); int left = 0; int right = length - 1; vector&lt;int> result(nums.size(), 0); int index = length-1; while(left &lt;= right)&#123; if (nums[left] * nums[left] &lt;= nums[right] * nums[right])&#123; result[index] = nums[right] * nums[right]; index --; right -= 1; &#125; else if (nums[left] * nums[left] >= nums[right] * nums[right])&#123; result[index] = nums[left] * nums[left]; index --; left += 1; &#125; &#125; return result; &#125; &#125;; 2.8 长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 滑动窗口： class Solution &#123; public: int minSubArrayLen(int target, vector&lt;int>&amp; nums) &#123; int left = 0; int sum = 0; int length = 0; // 初始化为极大值，确保第一次比较时 length 会被选中 int result = INT32_MAX; for (int right = 0; right &lt; nums.size(); right++)&#123; sum += nums[right]; while (sum >= target)&#123; length = right - left + 1; result = result &lt; length ? result : length; sum -= nums[left++]; &#125; &#125; return result == INT32_MAX ? 0 : result; &#125; &#125;; 2.9 螺旋数组给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 class Solution &#123; public: vector&lt;vector&lt;int>> generateMatrix(int n) &#123; int mid = n/2 ; int num = 1; int loop = n/2; int start_x = 0; int end_x = n-start_x - 1; int start_y = 0; int end_y = n-start_y - 1; // vector 构建二维数组 vector&lt;vector&lt;int>> result(n, vector &lt;int>(n, 0)); while (loop -- )&#123; for (int i = start_x, j = start_y; i &lt; end_x; i++)&#123; result[j][i] = num; num ++; &#125; for (int i = start_y, j = end_x; i &lt; end_y; i++)&#123; result[i][j] = num; num ++; &#125; for (int i = end_y, j = end_x; j > start_x; j--)&#123; result[i][j] = num; num ++; &#125; for (int i = end_y, j = start_x; i > start_y; i--)&#123; result[i][j] = num; num ++; &#125; start_x +=1; start_y +=1; end_x -= 1; end_y -=1; &#125; if (n % 2 == 1)&#123; result[mid][mid] = n*n; &#125; return result; &#125; &#125;; 2.10 区间和给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。 输入描述 第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。 输出描述 输出每个指定区间内元素的总和。 /* 卡暴力，使用前缀和，即数列和的差值 */ #include &lt;iostream> #include &lt;vector> using namespace std; int main()&#123; int n; int num; int start = 0, end = 0; int result = 0; int pre_sum = 0; vector&lt;int> pre(n,0); cin >> n; int i = 0; // calculate 前缀和 while (n--)&#123; cin >> num; pre_sum += num; pre[i] = pre_sum; i++; &#125; while(cin >> start >> end)&#123; result = pre[end] - pre[start-1]; cout &lt;&lt; result &lt;&lt; endl; &#125; &#125; 2.11 字符串基础每门课的成绩分为A、B、C、D、F五个等级，为了计算平均绩点，规定A、B、C、D、F分别代表4分、3分、2分、1分、0分。有多组测试样例。每组输入数据占一行，由一个或多个大写字母组成，字母之间由空格分隔。每组输出结果占一行。如果输入的大写字母都在集合｛A,B,C,D,F｝中，则输出对应的平均绩点，结果保留两位小数。否则，输出“Unknown”。 //1. string处理， C++的字符串操作，头文件string， 长度 .size， 访问字符 [] // 判断是否为空 .empty()，输入输出可以用标准库中的iostream // cin >> word 读取到空格就会停止 // getline(cin , word) 读取一行直到换行符或者文件结束符停止 //2. &lt;iomanip> 对标准输出进行格式化处理 比如此题中的 cout &lt;&lt; fixed &lt;&lt; setprecision(2); 设置精度为2位小数 //注意点： //getline(cin, grades) 会读取整行输入，包括空格， //所以当输入包含空格时，default 分支会被触发，导致输出 Unknown 错误产生 #include &lt;iostream> #include &lt;string> #include &lt;iomanip> using namespace std; int main()&#123; string grades; while (getline(cin,grades))&#123; bool flag = 0; float total = 0; int count = 0; for (int i = 0; i &lt; grades.size(); i++) &#123; if (grades[i] == ' ') continue; switch(grades[i])&#123; case 'A': total += 4.0; count += 1; break; case 'B': total += 3.0; count += 1; break; case 'C': total += 2.0; count += 1; break; case 'D': total += 1.0; count += 1; break; case 'F': total += 0.0; count += 1; break; default: flag = 1; break; &#125; &#125; if (flag == 0)&#123; float final = 0.0; final = total / count; cout &lt;&lt; fixed &lt;&lt; setprecision(2); cout &lt;&lt; final &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; \"Unknown \" &lt;&lt; endl; &#125; &#125; return 0; &#125; 2.12 大写组合输出一个词组中每个单词的首字母的大写组合。输入的第一行是一个整数n，表示一共有n组测试数据。（输入只有一个n，没有多组n的输入）接下来有n行，每组测试数据占一行，每行有一个词组，每个词组由一个或多个单词组成；每组的单词个数不超过10个，每个单词有一个或多个大写或小写字母组成；单词长度不超过10，由一个或多个空格分隔这些单词 //注意这里使用了 getchar() 函数来吸收一个回车符，因为在输入 n 之后通常需要输入回车符才会输入下一行。 /* cin >> n 会留下换行符 \\n 在缓冲区 当输入 n 的值（比如 2）并按回车后，缓冲区的内容是：\"2\\n\"。 cin >> n 只读取 2，剩下的 \\n 仍然在缓冲区。 getline(cin, line) 会读取缓冲区中剩余的 \\n getline 遇到 \\n 时会直接读取并返回空字符串 \"\"，导致 line 为空，因此 for 循环不会执行。 */ #include &lt;iostream> #include &lt;string> using namespace std; char upper(char a)&#123; char upper; if ((a >= 'a') &amp;&amp; (a &lt;= 'z')) cout &lt;&lt; char(a + 'A' - 'a'); else if ((a >= 'A') &amp;&amp; (a &lt;= 'Z')) cout &lt;&lt; char(a); return upper; &#125; int main() &#123; string line; int n; cin >> n; getchar(); while (n--) &#123; getline(cin, line); if (line[0] != ' ') &#123; if ((line[0] >= 'a') &amp;&amp; (line[0] &lt;= 'z')) cout &lt;&lt; char(line[0] + 'A' - 'a'); else if ((line[0] >= 'A') &amp;&amp; (line[0] &lt;= 'Z')) cout &lt;&lt; char(line[0]); &#125; /* if (line[0] != ' ') &#123; upper(line[0]); &#125; */ for (int i = 1; i &lt; line.size(); i++) &#123; if ((line[i] != ' ') &amp;&amp; (line[i - 1] == ' ')) &#123; if ((line[i] >= 'a') &amp;&amp; (line[i] &lt;= 'z')) cout &lt;&lt; char(line[i] + 'A' - 'a'); else if ((line[i] >= 'A') &amp;&amp; (line[i] &lt;= 'Z')) cout &lt;&lt; char(line[i]); &#125; &#125; /* for (int i = 1; i &lt; line.size(); i++) &#123; if ((line[i] != ' ') &amp;&amp; (line[i - 1] == ' ')) &#123; upper(line[i]); &#125; &#125; */ cout &lt;&lt; endl; &#125; return 0; &#125; 2.13 字符串奇偶位翻转给定一个长度为偶数位的字符串，请编程实现字符串的奇偶位互换。输入包含多组测试数据。输入的第一行是一个整数n，表示有测试数据。（整个输入中，只有一个n）接下来是n组测试数据，保证串长为偶数位(串长&lt;=50)。 //题解使用了自定义的交换函数，其中用了变量引用， which is C++的特性 /* // 不返回(return)结果，所以返回类型为void， 函数名称为swap // 传入的参数为两个字符，所以类型为char, 参数名称为a 和 b void swap(char &amp;a, char &amp;b) &#123; // 交换两个字符串, a和b的内容需要改变，所以需要传递引用 // 定义第三个字符，并将字符a的内容赋值给第三个字符 char tmp = a; // 将字符a的内容修改为字符b的内容 a = b; // 将字符b的内容修改为第三个字符的内容，也就是字符a的内容，a和b之间完成替换 b = tmp; &#125; */ #include &lt;iostream> #include &lt;string> using namespace std; int main()&#123; string line; int n; cin >> n; getchar(); while(n--)&#123; getline(cin,line); char c; for (int i = 0; i &lt; line.size()-1; i++)&#123; if((i)%2 == 0)&#123; c = line[i]; line[i] = line[i+1]; line[i+1] = c; &#125; &#125; cout &lt;&lt; line &lt;&lt; endl; &#125; return 0; &#125; 2.14 反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 暴力： class Solution &#123; public: void reverseString(vector&lt;char>&amp; s) &#123; int n = s.size(); vector&lt;int> restore(n); for(int i = 0 ; i &lt; n; i++)&#123; restore[i] = s[i] -'a'; &#125; for (int i = n - 1; i >= 0; i-- )&#123; s[n-i-1] = restore[i] + 'a'; &#125; &#125; &#125;; 双指针： class Solution &#123; public: void reverseString(vector&lt;char>&amp; s) &#123; int n = s.size(); int left = 0; int right = n-1; while (left &lt; right)&#123; swap(s[left], s[right]); left ++; right --; &#125; &#125; &#125;; 2.15 反转字符串Ⅱ给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 class Solution &#123; public: string reverseStr(string s, int k) &#123; int n = s.size(); int roll1 = n / (2*k); int roll2 = n % (2*k); int start = 0; while (roll1 --)&#123; int left = start; int right = start + k -1; while (left &lt; right)&#123; swap(s[left] , s[right]); left ++; right --; &#125; start += 2 * k; &#125; roll1 = n / (2*k); if (roll2 &lt; k)&#123; int start = 2 * k * roll1; int left = start; int right = start + roll2 - 1; while (left &lt; right)&#123; swap(s[left] , s[right]); left ++; right --; &#125; &#125; else if (roll2 >= k &amp;&amp; roll2 &lt; 2 * k)&#123; int start = 2 * k * roll1; int left = start; int right = start + k - 1; while (left &lt; right)&#123; swap(s[left] , s[right]); left ++; right --; &#125; &#125; return s; &#125; &#125;; 2.16 替换数字给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。 #include &lt;iostream> #include &lt;string> using namespace std; int main()&#123; string input; cin >> input; int total = 0; for (auto &amp;s : input)&#123; if (s >= '0' &amp;&amp; s &lt;= '9') total ++; &#125; int space = input.size() + total * 5; char output[space + 1]; int start = input.size() - 1; /* 在 C/C++ 中，字符数组（char[]）用于表示字符串时，必须以 '\\0'（空字符，ASCII 码为 0）结尾。 如果缺少这个终止符，cout 或其他字符串处理函数（如 strlen、strcpy）可能会读取越界， 导致未定义行为（Undefined Behavior, UB），常见表现包括： 1. 输出乱码 2. 程序崩溃 3. 无限循环（如果内存中碰巧有非零数据） */ output[space] = '\\0'; // Ensure null-termination int end = space - 1; while (start >= 0)&#123; if (input[start] >= '0' &amp;&amp; input[start] &lt;= '9')&#123; output[end] = 'r'; end --; output[end] = 'e'; end --; output[end] = 'b'; end --; output[end] = 'm'; end --; output[end] = 'u'; end --; output[end] = 'n'; end --; &#125; else&#123; output[end] = input[start]; end --; &#125; start --; &#125; cout &lt;&lt; output &lt;&lt; endl; return 0; &#125; 2.17 找出字符串中第一个匹配项的下标给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。 暴力（伪双指针）： class Solution &#123; public: int strStr(string haystack, string needle) &#123; int n1 = needle.size(); int n2 = haystack.size(); int left1 = 0; int left2 = 0; int right1 = n1 - 1; int right2 = n1 - 1; int flag = 1; while(right2 &lt; n2)&#123; if(haystack[left2] == needle[left1] &amp;&amp; haystack[right2] == needle[right1])&#123; flag = 1; int restore = left2; for (int i = left2, j = left1; i &lt; right2, j &lt; right1; i++, j++)&#123; if(haystack[i] != needle[j]) &#123; flag = 0; break; &#125; &#125; if (flag == 1)&#123; return restore; &#125; &#125; left2++; right2++; &#125; return -1; &#125; &#125;; KMP：字符串匹配算法，值得理解 class Solution &#123; public: void getprefix(const string &amp;s, int *prefix)&#123; int fend = 0; prefix[0] = 0; for (int bend = 1; bend &lt; s.size(); bend++)&#123; while (fend > 0 &amp;&amp; s[fend] != s[bend])&#123; fend = prefix[fend - 1]; &#125; if (s[bend] == s[fend]) fend++; prefix[bend] = fend; &#125; &#125; int strStr(string haystack, string needle) &#123; if (needle.size() == 0) return 0; if (needle.size() > haystack.size()) return -1; vector&lt;int> prefix(needle.size()); getprefix(needle, &amp;prefix[0]); int index = 0; for (int i = 0; i &lt; haystack.size() ; i++)&#123; while (index > 0 &amp;&amp; haystack[i] != needle[index]) &#123; index = prefix[index - 1]; &#125; if (haystack[i] == needle[index]) index++; if (index == needle.size()) return (i - index + 1); &#125; return -1; &#125; &#125;; 2.18 翻转字符串里的单词给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 class Solution &#123; public: void removeextra(string &amp;s)&#123; int slow = 0; for (int fast = 0; fast &lt; s.size(); fast ++)&#123; if (s[fast] != ' ')&#123; if (slow > 0) s[slow++] = ' '; while (fast &lt; s.size() &amp;&amp; s[fast] != ' ')&#123; s[slow++] = s[fast++]; &#125; &#125; &#125; s.resize(slow); &#125; void reverse(string &amp;s, int left, int right)&#123; for (int i = left, j = right; i &lt; j; i++, j--) &#123; swap(s[i], s[j]); &#125; &#125; string reverseWords(string s) &#123; removeextra(s); reverse(s, 0, s.size()-1); int start = 0; for (int end = 1; end &lt; s.size(); end++)&#123; if(s[end] == ' ')&#123; reverse(s, start , end-1); start = end + 1; &#125; else if (end == s.size() - 1)&#123; reverse(s, start , end); &#125; &#125; return s; &#125; &#125;; 2.19 右旋字符串字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。 #include &lt;iostream> #include &lt;string> using namespace std; int main() &#123; int n; string s; cin >> n; cin >> s; int left0 = 0; int right0 = s.length() - 1; //全部翻转1 while (left0 &lt; right0) &#123; swap(s[left0], s[right0]); left0++; right0--; &#125; //局部翻转1 left0 = 0; right0 = n - 1; while (left0 &lt; right0) &#123; swap(s[left0], s[right0]); left0++; right0--; &#125; //局部翻转2 left0 = n; right0 = s.length() - 1; while (left0 &lt; right0) &#123; swap(s[left0], s[right0]); left0++; right0--; &#125; cout &lt;&lt; s; &#125; 2.20 重复的子字符串给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 class Solution &#123; public: bool repeatedSubstringPattern(string s) &#123; vector&lt;int> prefix(s.size()); prefix[0] = 0; int j = 0; for (int i = 1; i &lt; s.size(); i++)&#123; while (j > 0 &amp;&amp; s[i] != s[j])&#123; j = prefix[j- 1]; &#125; if (s[i] == s[j]) j++; prefix[i] = j; &#125; printf(\"%d\\r\\n\", prefix[s.size()-1]); if (s.size() == 2)&#123; if (prefix[s.size()-1] == 1) return true; &#125; if (s.size() > 2)&#123; if (prefix[s.size()-1] != 0 &amp;&amp; s.size() % (s.size()-(prefix[s.size() - 1]) )== 0) return true; &#125; return false; &#125; &#125;; &nbsp; 3. 链表3.1 基础1构建一个单向链表，链表中包含一组整数数据。输出链表中的所有元素。 要求： 使用自定义的链表数据结构 提供一个 linkedList 类来管理链表，包含构建链表和输出链表元素的方法 在 main 函数中，创建一个包含一组整数数据的链表，然后调用链表的输出方法将所有元素打印出来 // 0. 构造函数：ListNode(int x) : val(x), next(nullptr) &#123;&#125; // 这里的ListNode(int x)表示定义一个接收整数参数 x的名称为ListNode的构造函数（名称和结构体相同），:表示初始化列表的开始，val(x)表示链表数据域的值被初始化为传递的参数 x ，next(nullptr)则表示next指针被初始化为nullptr，表示没有下一个节点。 /* 这里有两个新的语法：new运算符和箭头语法-> 1. new是一个运算符，它的作用就是在堆内存中动态分配内存空间，并返回分配内存的地址，使用方式一般为： 指针变量 = new 数据类型, 比如下面的代码： int *arr = new int[5]; // 分配一个包含5个整数的数组的内存空间，并返回一个地址，指针arr指向这个地址 2. 箭头语法（->）：用于通过指针访问指针所指向的对象的成员，cur 是一个指向 ListNode 结构体对象的指针，而 next 是 ListNode 结构体内部的一个成员变量（指向下一个节点的指针）。使用 cur->next 表示访问 cur 所指向的节点的 next 成员变量。 */ #include &lt;iostream> using namespace std; struct ListNode&#123; int val; ListNode *next; ListNode(int x) : val(x) , next(nullptr)&#123;&#125; &#125;; int main()&#123; // 指针变量 = new 数据类型 // 建立一个虚拟头节点 ListNode *dummyhead = new ListNode(0); int m, n; while (cin >> n)&#123; ListNode *cur = dummyhead; while(n--)&#123; cin >> m; ListNode *newnode = new ListNode(m); cur-> next = newnode; cur = cur -> next; &#125; cur = dummyhead; while (cur->next != NULL)&#123; cout &lt;&lt; cur->next->val &lt;&lt; ' '; cur = cur->next; &#125; cout &lt;&lt; endl; &#125; &#125; 3.2 基础2请编写一个程序，实现以下操作： 构建一个单向链表，链表中包含一组整数数据，输出链表中的第 m 个元素（m 从 1 开始计数）。要求： 使用自定义的链表数据结构 提供一个 linkedList 类来管理链表，包含构建链表、输出链表元素以及输出第 m 个元素的方法 在 main 函数中，创建一个包含一组整数数据的链表，然后输入 m，调用链表的方法输出第 m 个元素 &nbsp;输入描述： 第一行包含两个整数 n 和 k，n 表示需要构建的链表的长度，k 代表输入的 m 的个数。接下来一行包含 n 个整数，表示链表中的元素。接下来一行包含 k 个整数，表示输出链表中的第 m 个元素。 &nbsp;输出描述测试数据输出占 k 行。每行输出链表中的第 m 个元素。如果 m 位置不合法，则输出“Output position out of bounds.”。 #include &lt;iostream> using namespace std; struct linknode&#123; int val; linknode* next; linknode(int x): val(x), next(nullptr) &#123;&#125; &#125;; int main()&#123; int n, k; int num; cin >> n >> k ; linknode* dummynode = new linknode(0); linknode* cur; cur = dummynode; // creat linklist while (n--)&#123; cin >> num; linknode *newnode =new linknode(num); cur->next = newnode; cur = cur -> next; &#125; // output while (k--)&#123; cin >> num; cur = dummynode; // judge range for (int i = 0; i &lt; num; i++)&#123; // if exceed, break if (cur != NULL) cur = cur->next ; else break; &#125; // cur == NULL : exceed // cur == dummyHead : m = 0 if (cur == NULL || cur == dummynode) &#123; cout &lt;&lt; \"Output position out of bounds.\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; cur->val &lt;&lt; endl; &#125; &#125; return 0; &#125; 3.3 基础3请编写一个程序，实现以下链表操作：构建一个单向链表，链表中包含一组整数数据。 实现在链表的第 n 个位置插入一个元素，输出整个链表的所有元素。 实现删除链表的第 m 个位置的元素，输出整个链表的所有元素。 要求： 使用自定义的链表数据结构。 提供一个 linkedList 类来管理链表，包含构建链表、插入元素、删除元素和输出链表元素的方法。 在 main 函数中，创建一个包含一组整数数据的链表，然后根据输入的 n 和 m，调用链表的方法插入和删除元素，并输出整个链表的所有元素。&nbsp; 输入描述: 每次输出只有一组测试数据。 每组的第一行包含一个整数 k，表示需要构建的链表的长度。 第二行包含 k 个整数，表示链表中的元素。 第三行包含一个整数 S，表示后续会有 S 行输入，每行两个整数，第一个整数为 n，第二个整数为 x ，代表在链表的第 n 个位置插入 x。 S 行输入… 在 S 行输入后，后续会输入一个整数 L，表示后续会有 L 行输入，每行一个整数 m，代表删除链表中的第 m 个元素。 L 行输入…&nbsp; 输出描述: 包含多组输出。 每组第一行输出构建的链表，链表元素中用空格隔开，最后一个元素后没有空格。 然后是 S 行输出，每次插入一个元素之后都将链表输出一次，元素之间用空格隔开，最后一个元素后没有空格； 如果插入位置不合法，则输出“Insertion position is invalid.”。 然后是 L 行输出，每次删除一个元素之后都将链表输出一次，元素之间用空格隔开，最后一个元素后没有空格；如果删除元素后链表的长度为0，则不打印链表。 如果删除位置不合法，则输出“Deletion position is invalid.”。 如果链表已经为空，执行删除操作时不需要打印任何数据。 #include &lt;iostream> using namespace std; struct linknode &#123; int val; linknode *next; linknode(int x) : val(x), next(nullptr) &#123;&#125; &#125;; // function for print the linklist void printlinklist(linknode *listhead) &#123; linknode *cur = listhead; while (cur->next != NULL) &#123; cout &lt;&lt; cur->next->val &lt;&lt; ' '; cur = cur->next; &#125; cout &lt;&lt; endl; &#125; int main() &#123; int k, s, l; int num; int place, var; int deleteplace; bool flag = 0; linknode *dummyhead = new linknode(0); linknode *cur; cin >> k; // linklist create cur = dummyhead; // linklist length int listLen = k; while (k--) &#123; cin >> num; cur->next = new linknode(num); cur = cur->next; &#125; // insert cin >> s; while (s--) &#123; cur = dummyhead; cin >> place >> var; if ((place > listLen) || (place &lt;= 0)) &#123; cout &lt;&lt; \"Insertion position is invalid.\" &lt;&lt; endl; continue; &#125; else &#123; for (int i = 1; i &lt; place; i++) &#123; cur = cur->next; &#125; linknode *insertnode = new linknode(var); insertnode->next = cur->next; cur->next = insertnode; // add length listLen++; &#125; // output printlinklist(dummyhead); &#125; // delete cin >> l; while (l--) &#123; cin >> deleteplace; if ((deleteplace > listLen) || (deleteplace &lt;= 0)) &#123; cout &lt;&lt; \"Deletion position is invalid.\" &lt;&lt; endl; continue; &#125; else &#123; cur = dummyhead; for (int i = 1; i &lt; deleteplace; i++) &#123; cur = cur->next; &#125; cur->next = cur->next->next; listLen--; &#125; if (listLen) printlinklist(dummyhead); &#125; return 0; &#125; 3.4 设计链表你可以选择使用单链表或者双链表，设计并实现自己的链表。（这里使用单链表） 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。 实现 MyLinkedList 类： MyLinkedList() 初始化 MyLinkedList 对象。 int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。 void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。 void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。 void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。 void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。 class MyLinkedList &#123; public: struct LinkNode&#123; int val; LinkNode* next; LinkNode(int val): val(val), next(nullptr)&#123;&#125; &#125;; // 初始化 MyLinkedList() &#123; dummyhead = new LinkNode(0); size = 0; &#125; int get(int index) &#123; if ( index &lt; 0 || index > (size - 1)) return -1; LinkNode* cur = dummyhead -> next; while (index --)&#123; cur = cur -> next; &#125; return cur ->val; &#125; void addAtHead(int val) &#123; LinkNode* newhead = new LinkNode(val); newhead->next = dummyhead ->next; dummyhead ->next = newhead; size ++; &#125; void addAtTail(int val) &#123; LinkNode* newtail = new LinkNode(val); LinkNode* cur = dummyhead; while (cur -> next != NULL)&#123; cur = cur -> next; &#125; cur -> next = newtail; size ++; &#125; void addAtIndex(int index, int val) &#123; LinkNode* newinsert = new LinkNode(val); if (index &lt; 0 || index > size) return; LinkNode* cur = dummyhead; while (index --)&#123; cur = cur-> next; &#125; newinsert -> next = cur -> next; cur -> next = newinsert; size ++; &#125; void deleteAtIndex(int index) &#123; LinkNode* cur = dummyhead; if (index &lt; 0 || index >= size) return ; while (index --)&#123; cur = cur->next; &#125; cur ->next = cur->next->next; size --; &#125; private: LinkNode* dummyhead; int size = 0; &#125;; /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj->get(index); * obj->addAtHead(val); * obj->addAtTail(val); * obj->addAtIndex(index,val); * obj->deleteAtIndex(index); */ 3.5 反转链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL; ListNode* cur = head ; ListNode* temp; //注意临界条件 while (cur != NULL)&#123; temp = cur->next; cur->next = pre; pre = cur; cur = temp; &#125; return pre; &#125; &#125;; 3.6 两两交换链表中的节点给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* swapPairs(ListNode* head) &#123; ListNode* dummyhead = new ListNode(0); dummyhead->next = head; ListNode* cur = dummyhead; while (cur->next != nullptr &amp;&amp; cur->next->next != nullptr)&#123; ListNode* temp = cur->next; ListNode* temp_1 = cur->next->next->next; cur->next = cur->next->next; cur->next->next = temp; cur->next->next->next = temp_1; cur = temp; &#125; return dummyhead->next; &#125; &#125;; 3.7 删除链表的倒数第N个节点给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 暴力： /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummyhead = new ListNode(0); dummyhead->next = head; ListNode* cur = dummyhead; int count = 0; while (cur->next != NULL)&#123; cur = cur->next; count ++; &#125; int count_reverse = count - n ; // cout &lt;&lt; count &lt;&lt; endl; cur = dummyhead; for (int i = 0; i &lt; count_reverse ; i++)&#123; cur = cur->next; &#125; // cout &lt;&lt; cur->val &lt;&lt; endl; if (cur->next != NULL) cur->next = cur->next->next; return dummyhead->next; &#125; &#125;; 双指针： /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummy = new ListNode(0); dummy->next = head; ListNode* fast = dummy; while (n--)&#123; fast = fast->next; &#125; ListNode* slow = dummy; while (fast->next != NULL)&#123; fast = fast->next; slow = slow->next; &#125; slow->next = slow->next->next; return dummy->next; &#125; &#125;; 3.8 链表相交给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 暴力： /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode* dummyA = new ListNode(0); ListNode* dummyB = new ListNode(0); dummyA->next = headA; dummyB->next = headB; ListNode* curA = dummyA; ListNode* curB = dummyB; while(curA->next != NULL)&#123; curA = curA->next; while (curB-> next != NULL)&#123; curB = curB ->next; if (curB == curA) return curA; &#125; curB = dummyB; &#125; return NULL; &#125; &#125;; 暴力2： 两链表尾端对齐后，两遍历节点同时取短链表head，向后移动并检查 class Solution &#123; public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode* curA = headA; ListNode* curB = headB; int lenA = 0, lenB = 0; while (curA != NULL) &#123; // 求链表A的长度 lenA++; curA = curA->next; &#125; while (curB != NULL) &#123; // 求链表B的长度 lenB++; curB = curB->next; &#125; curA = headA; curB = headB; // 让curA为最长链表的头，lenA为其长度 if (lenB > lenA) &#123; swap (lenA, lenB); swap (curA, curB); &#125; // 求长度差 int gap = lenA - lenB; // 让curA和curB在同一起点上（末尾位置对齐） while (gap--) &#123; curA = curA->next; &#125; // 遍历curA 和 curB，遇到相同则直接返回 while (curA != NULL) &#123; if (curA == curB) &#123; return curA; &#125; curA = curA->next; curB = curB->next; &#125; return NULL; &#125; &#125;; 3.9 环形链表给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 暴力哈希： /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode *detectCycle(ListNode *head) &#123; unordered_set&lt;ListNode*> store; ListNode* dummy = new ListNode(0); dummy->next = head; ListNode* cur = dummy; while (cur->next != NULL)&#123; store.insert(cur->next); cur = cur->next; //if (store.count(cur->next)) 也行 if (store.find(cur->next) != store.end()) return cur->next; &#125; return NULL; &#125; &#125;; 双指针：fast是走两步，slow是走一步，其实相对于slow来说，fast是一个节点一个节点的靠近slow的，所以fast一定可以和slow重合。 class Solution &#123; public: ListNode *detectCycle(ListNode *head) &#123; ListNode* fast = head; ListNode* slow = head; while(fast != NULL &amp;&amp; fast->next != NULL) &#123; slow = slow->next; fast = fast->next->next; // 快慢指针相遇，此时从head和相遇点，同时查找直至相遇 if (slow == fast) &#123; ListNode* index1 = fast; ListNode* index2 = head; while (index1 != index2) &#123; index1 = index1->next; index2 = index2->next; &#125; return index2; // 返回环的入口 &#125; &#125; return NULL; &#125; &#125;; &nbsp; 4. 哈希散列4.1 基础：数组给定一个只包含小写字母的字符串，统计字符串中每个字母出现的频率，并找出出现频率最高的字母，如果最高频率的字母有多个，输出字典序靠前的那个字母。 包含多组测试数据，每组测试数据占一行。 有多组输出，每组输出占一行。 #include &lt;iostream> #include &lt;string> using namespace std; int main() &#123; int n; string s; while (cin >> n) &#123; while (n--) &#123; cin >> s; int count[26] = &#123;0&#125;; int max = 0; int max_flag = 0; // hash for (int i = 0; i &lt; s.size(); i++) &#123; count[s[i] - 'a']++; &#125; // select max for (int j = 0; j &lt; 26; j++) &#123; if (count[j] > max) &#123; max = count[j]; max_flag = j; &#125; &#125; char result; result = max_flag + 'a'; cout &lt;&lt; result; cout &lt;&lt; endl; &#125; &#125; return 0; &#125; 4.2 基础：set编写一个程序，判断给定的整数 n 是否存在于给定的集合中。 有多组测试数据，第一行有一个整数 k，代表有 k 组测试数据。 每组数据第一行首先是一个正整数 m，表示集合中元素的数量（1 &lt;= m &lt;= 1000）。 接下来一行包含 m 个整数，表示集合中的元素。 最后一行包含一个整数 n，表示需要进行判断的目标整数。 包含多组输出，每组输出占一行。 如果集合中存在 m，输出“YES”，否则输出“NO”。 // set 集合 #include &lt;iostream> #include &lt;unordered_set> using namespace std; int main() &#123; int m, n, l; int test; cin >> m; while (m--) &#123; cin >> n; unordered_set&lt;int> uset; while (n--) &#123; cin >> l; // set insert uset.insert(l); &#125; //test cin >> test; if (uset.find(test) != uset.end()) // check iterator cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; &#125; 4.3 基础：map假设你手里有一串钥匙，这串钥匙上每把钥匙都有一个编号，对应着一个房门的编号。现给你一个房门编号，你需要判断是否能够打开该房门。 测试数据共有多组。 第一行为一个整数 s，表示共有多少组测试数据。 每组第一行有一个整数 n，表示钥匙串上有多少把钥匙。 后面共有 n 行输入，每行两个整数，第一个整数 k 表示钥匙编号，第二个整数 d 表示房门编号。 最后一行有一个整数 x，表示需要打开的房门编号。 输出多组，每组占一行。 如果能打开，则输出钥匙编号，不能打开则输出“Can’t open the door.”。 #include &lt;iostream> #include &lt;unordered_map> using namespace std; int main() &#123; int n, m; cin >> n; int key_num; int door_num; int x; while (n--) &#123; cin >> m; unordered_map&lt;int, int> umap; while (m--) &#123; cin >> key_num >> door_num; umap[key_num] = door_num; &#125; cin >> x; bool flag = 0; int answer = 0; for (const pair&lt;int,int> &amp;kv : umap) &#123; if (kv.second == x) &#123; flag = 1; answer = kv.first; break; &#125; &#125; if (flag == 1) &#123; cout &lt;&lt; answer &lt;&lt; endl; &#125; else cout &lt;&lt; \"Can't open the door.\" &lt;&lt; endl; &#125; &#125; 4.4 存在重复元素给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。 class Solution &#123; public: bool containsDuplicate(vector&lt;int>&amp; nums) &#123; unordered_set&lt;int> res; for (int num: nums)&#123; if (res.contains(num)) return true; else res.insert(num); &#125; return false; &#125; &#125;; 4.5 只出现一次的数字给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。 class Solution &#123; public: int singleNumber(vector&lt;int>&amp; nums) &#123; unordered_map&lt;int , int > count; for (int num: nums)&#123; count[num] ++; &#125; for (int num : nums)&#123; if (count[num] == 1)&#123; return num; &#125; &#125; return -1; &#125; &#125;; 4.6 有效的字母异位词给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的 字母异位词。 s 和 t 仅包含小写字母 class Solution &#123; public: bool isAnagram(string s, string t) &#123; vector&lt;int> table(26.0); //长度不同必定false if (s.length() != t.length()) return false; for (char &amp;ch : s)&#123; table[ch - 'a'] ++; &#125; for (char &amp;ch : t)&#123; table[ch - 'a']--; if (table[ch- 'a'] &lt; 0) return false; &#125; return true; &#125; &#125;; 4.7 两个数组的交集给定两个数组 nums1 和 nums2 ，返回 它们的 交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 class Solution &#123; public: vector&lt;int> intersection(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2) &#123; unordered_set&lt;int> result, restore; for (auto &amp;num : nums1)&#123; if(!restore.count(num)) restore.insert(num); &#125; for (auto &amp;num : nums2)&#123; if (restore.count(num)) result.insert(num); &#125; //vector&lt;int> a(begin_iterator, end_iterator);：使用范围构造函数，用迭代器指定的范围来初始化向量。 return vector&lt;int>(result.begin(), result.end()); &#125; &#125;; 4.8 快乐数编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 class Solution &#123; public: bool isHappy(int n) &#123; unordered_set &lt;int> sum; int result = n; while (sumsquare(result) != 1 )&#123; result = sumsquare(result); if (sum.count(result)) return false; sum.insert(result); &#125; return true; &#125; int sumsquare(int x)&#123; int sum = 0; int j = 0; while (x > 0)&#123; j = x % 10; // x = (x - j) / 10; x /= 10; sum += j * j; &#125; return sum; &#125; &#125;; 4.9 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。 你可以按任意顺序返回答案。 class Solution &#123; public: vector&lt;int> twoSum(vector&lt;int>&amp; nums, int target) &#123; unordered_map&lt;int,int> pair; for (int i = 0 ; i&lt; nums.size(); i++)&#123; if (pair.count(target-nums[i])) return &#123;pair[target- nums[i]], i&#125;; pair[nums[i]] = i; &#125; return &#123;&#125;; &#125; &#125;; 4.10 四数相加Ⅱ给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 &lt;= i, j, k, l &lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 class Solution &#123; public: int fourSumCount(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2, vector&lt;int>&amp; nums3, vector&lt;int>&amp; nums4) &#123; int count = 0; int n = nums1.size(); int sum = 0; unordered_map&lt;int, int> result; for (int i = 0 ; i &lt; n ; i++ )&#123; for (int j = 0; j &lt; n ; j++)&#123; sum = nums1[i] + nums2[j]; result[sum] += 1; &#125; &#125; for (int i = 0 ; i &lt; n ; i++ )&#123; for (int j = 0; j &lt; n ; j++)&#123; sum = nums3[i] + nums4[j]; if(result.find(-sum) != result.end()) count += result[-sum]; &#125; &#125; return count; &#125; &#125;; 4.11 赎金信给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 class Solution &#123; public: bool canConstruct(string ransomNote, string magazine) &#123; unordered_map&lt;int, int> uptime; for (auto &amp;ch : magazine)&#123; uptime[ch-'a']++; &#125; for (auto &amp;ch : ransomNote)&#123; if (uptime[ch - 'a'] == 0)&#123; return false; &#125; uptime[ch - 'a'] --; &#125; return true; &#125; &#125;; 4.12 三数之和：双指针给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 class Solution &#123; public: vector&lt;vector&lt;int>> threeSum(vector&lt;int>&amp; nums) &#123; vector&lt;vector&lt;int>> result; sort(nums.begin(),nums.end()); //本题为防止重复元素出现，需要对内外层去重 for (int a = 0; a &lt; nums.size(); a++) &#123; if (nums[a] > 0) &#123; return result; &#125; //对a去重 if (a > 0 &amp;&amp; nums[a] == nums[a - 1]) &#123; continue; &#125; int left = a + 1; int right = nums.size()-1; while (left &lt; right)&#123; if (nums[a] + nums[left] + nums[right] &lt; 0) left ++; else if (nums[a] + nums[left] + nums[right] > 0) right --; else &#123; result.push_back(vector&lt;int>&#123;nums[a], nums[left], nums[right]&#125;); // 去重逻辑应该放在找到一个三元组之后，对b和c去重 while (right > left &amp;&amp; nums[right] == nums[right - 1]) &#123;right--&#125;; while (right > left &amp;&amp; nums[left] == nums[left + 1]) &#123;left++&#125;; // 找到答案时，双指针同时收缩 right--; left++; &#125; &#125; &#125; return result; &#125; &#125;; 4.13 四数之和给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 &lt;= a, b, c, d &lt; n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按 任意顺序 返回答案 。 class Solution &#123; public: vector&lt;vector&lt;int>> fourSum(vector&lt;int>&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int>> result; for(int a = 0; a &lt; nums.size(); a++)&#123; // 去重 if (a > 0 &amp;&amp; nums[a] == nums[a - 1]) &#123; continue; &#125; // 剪枝 if (nums[a] > target &amp;&amp; nums[a] >= 0) &#123; break; &#125; for (int b = a + 1; b &lt; nums.size(); b++)&#123; // 去重 if (b > a + 1 &amp;&amp; nums[b] == nums[b - 1]) &#123; continue; &#125; // 剪枝 if (nums[a] + nums[b] > target &amp;&amp; nums[b] >= 0) &#123; break; &#125; int left = b + 1; int right = nums.size() - 1; while (left &lt; right)&#123; if ((long)nums[a] + nums[b] + nums[left] + nums[right] &lt; target) left ++; else if ((long)nums[a] + nums[b] + nums[left] + nums[right] > target) right --; else &#123; result.push_back(vector&lt;int>&#123;nums[a], nums[b], nums[left], nums[right]&#125;); while (right > left &amp;&amp; nums[left+1] == nums[left]) left ++; while (right > left &amp;&amp; nums[right] == nums[right - 1]) right --; left ++; right --; &#125; &#125; &#125; &#125; return result; &#125; &#125;; &nbsp; 5. 栈与队列5.1 基础：栈在餐厅里，洗盘子的工作需要使用到栈这种数据结构。 假设你手里有一个盘子堆放区。现在需要模拟洗盘子的过程，每个盘子都有一个编号。 盘子堆放区操作说明： 当操作为 1 时，表示从盘子堆放区拿走顶部的盘子清洗。 当操作为 2 时，表示有未洗的盘子放入盘子堆放区。 在一系列操作之后，你需要回答：下一个清洗的盘子编号？ 第一行有一个整数 n，代表初始盘子堆放区中盘子的数量为 n。 第二行有 n 个整数，代表了盘子的编号，同时整数之间的顺序也代表了未洗盘子加入盘子堆放区的顺序。 第三行为一个整数 m，代表接下来将会有 m 次操作。 接下来一共有 m 行，代表共有 m 次操作。 如果是操作 1，那么该行只会有一个数字 1，代表有一个盘子被拿走清洗。 如果是操作 2，那么该行有两个数字，第一个数字 2 表示有未洗的盘子加入，第二个数字代表未洗的盘子编号。 输出共一行，为下一个该清洗的盘子编号。 如果没有下一个该清洗的盘子，那么请输出 “All the dishes have been washed.” #include &lt;iostream> #include &lt;stack> using namespace std; int main()&#123; int num, dish_num, oper_num; int wash_flag; cin >> num; stack &lt;int> dishes; // enter while (num -- )&#123; cin >> dish_num; dishes.push(dish_num); &#125; //operate cin >> oper_num; while ( oper_num --)&#123; cin >> wash_flag; if (wash_flag == 1 &amp;&amp; !dishes.empty()) dishes.pop(); if (wash_flag == 2)&#123; cin >> dish_num; dishes.push(dish_num); &#125; &#125; // judge if (dishes.empty()) cout &lt;&lt; \"All the dishes have been washed.\" &lt;&lt; endl; else cout &lt;&lt; dishes.top() &lt;&lt; endl; &#125; 5.2 基础：队列假设有一家奶茶店，现在有一些人在排队等待取奶茶，同时也有人在取奶茶。 请你设计一个程序模拟这种情况下的奶茶队列管理。 假设每个人取奶茶的时间非常短，可以忽略不计，只需要考虑队列中的操作。 队列操作说明： 当操作为 1 时，表示有人已经取走奶茶，从队列中删除该人的信息。 当操作为 2 时，表示有新人加入排队，将该人的信息加入队列。 在一系列操作之后，你需要回答：下一个取奶茶的人是谁？ 第一行有一个整数 n，代表初始队列有 n 个人。 第二行有 n 个字符串，代表当前奶茶队列中的人。 第三行为一个整数 m，代表接下来将会有 m 次操作。 接下来一共有 m 行，代表共有 m 次操作。 如果是操作 1，那么该行只会有一个数字，代表有人取走了奶茶。如果是操作 2，那么该行有一个数字和一个字符串，第一个数字 2 表示有人加入了奶茶队列，第二个字符串代表新加入的奶茶队列的人。 输出只有一行，为下一个取奶茶的人。 如果已经没有去奶茶的人了，输出“There are no more people in the queue.”。 #include &lt;iostream> #include &lt;queue> #include &lt;string> using namespace std; int main()&#123; int origin_num; cin >> origin_num; // queue setup string name; queue &lt;string> milktea_queue; while (origin_num --)&#123; cin >> name; milktea_queue.push(name); &#125; // queue operation int opera_num, operation; cin >> opera_num; while(opera_num --)&#123; cin >> operation; if (operation == 1 &amp;&amp; !milktea_queue.empty()) milktea_queue.pop(); if (operation == 2) &#123; cin >> name; milktea_queue.push(name); &#125; &#125; // output if(milktea_queue.empty()) cout &lt;&lt; \"There are no more people in the queue.\" &lt;&lt; endl; else cout &lt;&lt; milktea_queue.front() &lt;&lt; endl; &#125; 5.3 有效的括号给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 class Solution &#123; public: bool isValid(string s) &#123; stack&lt;char> left; for (char item : s)&#123; if (item == '(' || item == '[' || item == '&#123;')&#123; left.push(item); &#125; else if (!left.empty() &amp;&amp; left.top() == leftreturn(item))&#123; left.pop(); &#125; else return false; &#125; return left.empty(); &#125; char leftreturn (char right)&#123; if(right == ')') return '('; if(right == '&#125;') return '&#123;'; if(right == ']') return '['; return false; &#125; &#125;; 5.4 买票需要的时间有 n 个人前来排队买票，其中第 0 人站在队伍 最前方 ，第 (n - 1) 人站在队伍 最后方 。 给你一个下标从 0 开始的整数数组 tickets ，数组长度为 n ，其中第 i 人想要购买的票数为 tickets[i] 。 每个人买票都需要用掉 恰好 1 秒 。一个人 一次只能买一张票 ，如果需要购买更多票，他必须走到 队尾 重新排队（瞬间 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 离开 队伍。 返回位于位置 k（下标从 0 开始）的人完成买票需要的时间（以秒为单位）。 class Solution &#123; public: int timeRequiredToBuy(vector&lt;int>&amp; tickets, int k) &#123; int n = tickets.size(); vector&lt;int> time(n); queue&lt;int> line; int timecost = 0; // 初始化队列，存储每个人的编号 id for(int i = 0; i &lt; n; i++)&#123; line.push(i); &#125; while(line.size())&#123; if (tickets[line.front()] > 1)&#123; timecost ++; tickets[line.front()]--; line.push(line.front()); line.pop(); &#125; else if (tickets[line.front()] == 1)&#123; timecost ++; time[line.front()] = timecost; line.pop(); &#125; &#125; return time[k]; &#125; &#125;; 5.5 用栈实现队列请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 class MyQueue &#123; private: stack&lt;int> input; stack&lt;int> output; public: MyQueue() &#123; &#125; void push(int x) &#123; input.push(x); &#125; int pop() &#123; int temp; if(output.empty())&#123; while (!input.empty())&#123; temp = input.top(); input.pop(); output.push(temp); &#125; &#125; int result; result = output.top(); output.pop(); return result; &#125; int peek() &#123; int temp; if(output.empty())&#123; while (!input.empty())&#123; temp = input.top(); input.pop(); output.push(temp); &#125; &#125; int result; result = output.top(); return result; &#125; bool empty() &#123; return input.empty() &amp;&amp; output.empty(); &#125; &#125;; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->peek(); * bool param_4 = obj->empty(); */ 5.6 用队列实现栈请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 class MyStack &#123; public: queue&lt;int> input; queue&lt;int> output; MyStack() &#123; &#125; void push(int x) &#123; input.push(x); &#125; int pop() &#123; while(input.size() > 1)&#123; output.push(input.front()); input.pop(); &#125; int result = input.front(); input.pop(); while(!output.empty())&#123; input.push(output.front()); output.pop(); &#125; return result; &#125; int top() &#123; int temp = this->pop(); input.push(temp); return temp; &#125; bool empty() &#123; return input.empty(); &#125; &#125;; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * bool param_4 = obj->empty(); */ 5.7 删除字符串中的所有相邻重复项给出由小写字母组成的字符串 s，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 s 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 class Solution &#123; public: string removeDuplicates(string s) &#123; stack&lt;char> lowercase; for (int i = 0; i &lt; s.size(); i++)&#123; if (i == 0) lowercase.push(s[i]); else&#123; if ((!lowercase.empty() &amp;&amp; s[i] != lowercase.top()) || lowercase.empty()) lowercase.push(s[i]); else lowercase.pop(); &#125; &#125; string result = \"\"; while (!lowercase.empty()) &#123; result += lowercase.top();// 将栈中元素放到result字符串汇总 lowercase.pop(); &#125; reverse (result.begin(), result.end()); // 字符串需要反转一下 return result; &#125; &#125;; 5.8 逆波兰表达式求值给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。 请你计算该表达式。返回一个表示表达式值的整数。 注意： 有效的算符为 &#39;+&#39;、&#39;-&#39;、&#39;*&#39; 和 &#39;/&#39; 。 每个操作数（运算对象）都可以是一个整数或者另一个表达式。 两个整数之间的除法总是 向零截断 。 表达式中不含除零运算。 输入是一个根据逆波兰表示法表示的算术表达式。 答案及所有中间计算结果可以用 32 位 整数表示。 class Solution &#123; public: int evalRPN(vector&lt;string>&amp; tokens) &#123; stack&lt;int> rpn; for(auto &amp;ch : tokens)&#123; if (ch == \"+\" || ch == \"-\" || ch == \"*\" || ch == \"/\") &#123; // 确保栈中至少有2个元素才能进行运算 if (rpn.size() &lt; 2) return 0; int temp = rpn.top(); rpn.pop(); int first = rpn.top(); rpn.pop(); if (ch == \"+\") &#123; rpn.push(first + temp); &#125; else if (ch == \"-\") &#123; rpn.push(first - temp); &#125; else if (ch == \"*\") &#123; rpn.push(first * temp); &#125; else if (ch == \"/\") &#123; rpn.push(first / temp); &#125; &#125; else &#123; // 将字符串转换为整数压入栈 rpn.push(stoi(ch)); &#125; &#125; return rpn.top(); &#125; &#125;; 5.9 滑动窗口最大值给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 暴力（力扣超时）： class Solution &#123; public: vector&lt;int> maxSlidingWindow(vector&lt;int>&amp; nums, int k) &#123; int size = nums.size() - k + 1; if (size &lt;= 0) &#123; vector&lt;int> result; return result; &#125; else &#123; vector&lt;int> result; vector&lt;int> compare(k); for (int i = 0; i &lt; size; i++)&#123; for(int j = i; j &lt; i + k; j++)&#123; compare[j - i] = nums[j]; &#125; sort(compare.begin(), compare.end(),[](const int &amp;a, const int &amp;b)&#123; return a &lt; b; &#125;); result.push_back(compare[k-1]); &#125; return result; &#125; &#125; &#125;; queue单向队列做（力扣超时）： class Solution &#123; public: vector&lt;int> maxSlidingWindow(vector&lt;int>&amp; nums, int k) &#123; int size = nums.size() - k + 1; int max = nums[0]; queue&lt;int> Max; vector&lt;int> result; for (int i = 0 ; i &lt; size; i++)&#123; int window = i + k; int i0 = i; if (Max.empty()) Max.push(nums[0]); if (i > 0 &amp;&amp; nums[i - 1] == Max.front())&#123; Max.pop(); &#125; while (i0 &lt; window)&#123; if (nums[i0] >= Max.front())&#123; while (!Max.empty())&#123; Max.pop(); &#125; Max.push(nums[i0]); &#125; else Max.push(nums[i0]); i0++; &#125; result.push_back(Max.front()); &#125; return result; &#125; &#125;; deque双向队列：可从末尾删除，想法上也更合理 #include &lt;vector> #include &lt;deque> using namespace std; class Solution &#123; public: vector&lt;int> maxSlidingWindow(vector&lt;int>&amp; nums, int k) &#123; vector&lt;int> result; deque&lt;int> dq; // 存储索引 for (int i = 0; i &lt; nums.size(); ++i) &#123; // 移除离开窗口的元素 while (!dq.empty() &amp;&amp; dq.front() &lt;= i - k) &#123; dq.pop_front(); &#125; // 从队尾移除比当前小的元素 while (!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) &#123; dq.pop_back(); &#125; // 加入当前元素索引 dq.push_back(i); // 窗口形成后记录最大值 if (i >= k - 1) &#123; result.push_back(nums[dq.front()]); &#125; &#125; return result; &#125; &#125;; 5.10 前K个高频元素给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 class Solution &#123; public: vector&lt;int> topKFrequent(vector&lt;int>&amp; nums, int k) &#123; unordered_map&lt;int,int> count(0); for (int i = 0; i &lt; nums.size(); i++)&#123; count[nums[i]] ++; &#125; // 转换为vector vector&lt;pair&lt;int, int>> freqVec(count.begin(), count.end()); //lambda表达式 sort(freqVec.begin(), freqVec.end(), [](const pair&lt;int, int>&amp; a, const pair&lt;int, int>&amp; b) &#123; return a.second > b.second; &#125;); // 提取前 k 个高频元素 vector&lt;int> result; for (int i = 0; i &lt; k &amp;&amp; i &lt; freqVec.size(); i++) &#123; result.push_back(freqVec[i].first); &#125; return result; &#125; &#125;; &nbsp; 6. 类与OOP应用6.1 图形面积考虑一个简单的图形类层次结构，包括基类 Shape 和两个派生类 Rectangle 和 Circle。每个类都有一个用于计算面积的方法。你的任务是编写一个程序，根据输入数据创建一个图形对象，然后计算并输出其面积。 输入包括多行，每行包含一个图形的描述。 描述的第一个单词是图形类型（”rectangle”或”circle”），然后是与该图形相关的参数。 对于矩形，参数是宽度和高度，对于圆形，参数是半径。输入以单词”end”结束。 对于每个图形描述，输出其类型和面积。使用两位小数点精度输出面积。 #include &lt;iomanip> #include &lt;iostream> #include &lt;string> #include &lt;vector> using namespace std; class Shape &#123; public: // virtual function virtual double getArea() const = 0; virtual string getType() const = 0; &#125;; // Class Circle class Circle : public Shape &#123; public: Circle(int r) : radius(r) &#123;&#125; // f1 string getType() const override &#123; return \"Circle\"; &#125; // f2 double getArea() const override &#123; return 3.14 * radius * radius; &#125; private: int radius; &#125;; // Class Rectangle class Rectangle : public Shape &#123; public: Rectangle(int w, int h) : width(w), height(h) &#123;&#125; // f1 string getType() const override &#123; return \"Rectangle\"; &#125; // f2 double getArea() const override &#123; return static_cast&lt;double>(width * height); &#125; private: int width; int height; &#125;; int main() &#123; vector&lt;Shape *> shapes; while (true) &#123; string type; cin >> type; if (type == \"end\") break; if (type == \"circle\") &#123; int radius; cin >> radius; shapes.push_back(new Circle(radius)); &#125; else if (type == \"rectangle\") &#123; int width, height; cin >> width >> height; shapes.push_back(new Rectangle(width, height)); &#125; &#125; for (const Shape *shape : shapes) &#123; cout &lt;&lt; shape->getType() &lt;&lt; \" area: \" &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; shape->getArea() &lt;&lt; endl; &#125; return 0; &#125; &nbsp; 7. 二叉树7.1 二叉树的递归遍历给定一个二叉树的根节点 root ，返回 它的 前中后序 遍历 。 /** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */ class Solution &#123; public: //前序遍历 void presearch(TreeNode* cur, vector&lt;int> &amp;val)&#123; if (cur == NULL) return; val.push_back(cur->val); presearch(cur->left,val); presearch(cur->right,val); &#125; //中序遍历 void middlesearch(TreeNode *cur, vector&lt;int> &amp;val)&#123; if (cur == NULL) return; middlesearch(cur->left, val); val.push_back(cur->val); middlesearch(cur->right, val); &#125; //后序遍历 void backsearch(TreeNode *cur, vector&lt;int> &amp;val)&#123; if (cur == NULL) return; backsearch(cur->left, val); backsearch(cur->right,val); val.push_back(cur->val); &#125; vector&lt;int> inorderTraversal(TreeNode* root) &#123; vector&lt;int> result; middlesearch(root, result); return result; &#125; &#125;; 7.2 二叉树的迭代遍历给定一个二叉树的根节点 root ，返回 它的 前中后序 遍历 。 /** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */ class Solution &#123; public: //前序遍历 void presearch(TreeNode* root, vector&lt;int> &amp;val)&#123; stack&lt;TreeNode*> st; if (root == NULL) return; st.push(root); while (!st.empty())&#123; TreeNode* head = st.top(); st.pop(); val.push_back(head->val); if (head->right) st.push(head->right); if (head->left) st.push(head->left); &#125; &#125; //中序遍历 void middlesearch(TreeNode* root, vector&lt;int> &amp;val)&#123; stack&lt;TreeNode*> st; if (root == NULL) return; TreeNode* cur = root; while ( !st.empty() || cur != NULL)&#123; if (cur != NULL) &#123; st.push(cur); cur = cur->left; &#125; else &#123; cur = st.top(); st.pop(); val.push_back(cur->val); cur = cur->right; &#125; &#125; &#125; //后序遍历 void backsearch(TreeNode *head, vector&lt;int> &amp;val)&#123; stack&lt;TreeNode*> st; if (head == NULL) return; // 如果始终没有打印过节点，head就一直是头节点 // 一旦打印过节点，head就变成打印节点 // 之后head：上一次打印完的节点 st.push(head); TreeNode* cur; while ( !st.empty())&#123; cur = st.top(); //有左树 且左树没处理过 if (cur->left != NULL &amp;&amp; head != cur->left &amp;&amp; head != cur->right)&#123; st.push(cur->left); &#125; //有右树 且右树没处理过 else if (cur->right != NULL &amp;&amp; head != cur->right)&#123; st.push(cur->right); &#125; //左树 右树 都为NULL 或都处理过了 else &#123; head = st.top(); val.push_back(st.top()->val); st.pop(); &#125; &#125; &#125; vector&lt;int> preorderTraversal(TreeNode* root) &#123; vector&lt;int> result; presearch(root , result); return result; &#125; &#125;; 7.3 二叉树的层序遍历给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 /** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */ class Solution &#123; public: vector&lt;vector&lt;int>> levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int>> result; queue&lt;TreeNode*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); vector&lt;int> layer; for (int i = 0; i &lt; size; i++)&#123; TreeNode* cur = que.front(); que.pop(); layer.push_back(cur->val); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); &#125; result.push_back(layer); &#125; // 如果要从底层开始，翻转一下就行 // reverse(result.begin(), result.end()); return result; &#125; &#125;; 7.4 二叉树的右视图给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 *即进行层序遍历时判断当前是否为该层最后一个元素 class Solution &#123; public: vector&lt;int> rightSideView(TreeNode* root) &#123; TreeNode* cur = root; vector&lt;int> result; queue&lt;TreeNode*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); for (int i = 0; i &lt; size; i++)&#123; cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); if (i == (size - 1)) result.push_back(cur->val); &#125; &#125; return result; &#125; &#125;; 7.5 二叉树的层平均值给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。 class Solution &#123; public: vector&lt;double> averageOfLevels(TreeNode* root) &#123; vector&lt;double> result; queue&lt;TreeNode*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); int count = 0; double sum = 0; for (int i = 0; i &lt; size; i++)&#123; TreeNode* cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); sum += cur->val; count++; &#125; result.push_back(sum/count); &#125; return result; &#125; &#125;; 7.6 N叉树的层序遍历给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔。 /* // Definition for a Node. class Node &#123; public: int val; vector&lt;Node*> children; Node() &#123;&#125; Node(int _val) &#123; val = _val; &#125; Node(int _val, vector&lt;Node*> _children) &#123; val = _val; children = _children; &#125; &#125;; */ class Solution &#123; public: vector&lt;vector&lt;int>> levelOrder(Node* root) &#123; vector&lt;vector&lt;int>> result; queue&lt;Node*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); vector&lt;int> local; for (int i = 0; i &lt; size; i++)&#123; Node* cur = que.front(); for (auto &amp;ch : cur->children)&#123; if (ch)&#123; que.push(ch); &#125; &#125; que.pop(); local.push_back(cur->val); &#125; result.push_back(local); &#125; return result; &#125; &#125;; 7.7 在每个树行中找最大值给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。 class Solution &#123; public: vector&lt;int> largestValues(TreeNode* root) &#123; vector&lt;int> max; queue&lt;TreeNode*> que; if (root) que.push(root); while (!que.empty())&#123; int max_num = INT_MIN; int size = que.size(); for(int i = 0; i &lt; size; i++)&#123; TreeNode* cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); if (cur->val >= max_num) max_num = cur->val; &#125; max.push_back(max_num); &#125; return max; &#125; &#125;; 7.8 填充每个节点的下一个右侧节点指针给定一个二叉树： struct Node &#123; int val; Node *left; Node *right; Node *next; &#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。 初始状态下，所有 next 指针都被设置为 NULL 。 /* // Definition for a Node. class Node &#123; public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125; Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125; Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) &#123;&#125; &#125;; */ class Solution &#123; public: Node* connect(Node* root) &#123; queue&lt;Node*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); for (int i = 0; i &lt; size; i++)&#123; Node* cur = que.front(); que.pop(); if (i == size-1) cur->next = NULL; else cur->next = que.front(); if(cur->left) que.push(cur->left); if(cur->right) que.push(cur->right); &#125; &#125; return root; &#125; &#125;; 7.9 二叉树的最大深度给定一个二叉树 root ，返回其最大深度。 二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。 迭代写法： class Solution &#123; public: int maxDepth(TreeNode* root) &#123; int depth = 0; queue&lt;TreeNode*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); for (int i = 0 ; i &lt; size; i++)&#123; TreeNode* cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); &#125; depth++; &#125; return depth; &#125; &#125;; 递归写法： class Solution &#123; public: int checkdepth(TreeNode* root)&#123; if (root == NULL)&#123; return 0; &#125; else&#123; int leftdepth = 0; int rightdepth = 0; if (root->left != NULL) leftdepth = checkdepth(root->left) + 1; if (root->right != NULL) rightdepth = checkdepth(root->right) + 1; if (root->left == NULL &amp;&amp; root->right == NULL) return 1; return max(leftdepth, rightdepth); &#125; &#125; int maxDepth(TreeNode* root) &#123; int depth = 0; depth = checkdepth(root); return depth; &#125; &#125;; 7.10 二叉树的最小深度给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明：叶子节点是指没有子节点的节点。 迭代写法： class Solution &#123; public: int minDepth(TreeNode* root) &#123; int depth = 0; queue&lt;TreeNode*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); for (int i = 0 ; i &lt; size; i++)&#123; TreeNode* cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); if (!cur->left &amp;&amp; !cur->right)&#123; depth++; return depth; &#125; &#125; depth++; &#125; return depth; &#125; &#125;; 递归写法： class Solution &#123; public: int checkdepth(TreeNode* root)&#123; if (root == NULL)&#123; return 0; &#125; else&#123; if (root->left == NULL &amp;&amp; root->right == NULL) return 1; int leftdepth = INT_MAX; int rightdepth = INT_MAX; if (root->left != NULL ) leftdepth = checkdepth(root->left) + 1; if (root->right != NULL) rightdepth = checkdepth(root->right) + 1; return min(leftdepth, rightdepth); &#125; &#125; int minDepth(TreeNode* root) &#123; int depth = 0; depth = checkdepth(root); return depth; &#125; &#125;; 7.11 翻转二叉树给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 class Solution &#123; public: void reverstreenode (TreeNode* cur)&#123; if (cur == NULL) return; reverstreenode(cur->left); reverstreenode(cur->right); TreeNode* temp; temp = cur->right; cur->right = cur->left; cur->left = temp; &#125; TreeNode* invertTree(TreeNode* root) &#123; reverstreenode(root); return root; &#125; &#125;; 7.12 对称二叉树给你一个二叉树的根节点 root ， 检查它是否轴对称。 递归写法： class Solution &#123; public: bool check(TreeNode* branch1, TreeNode* branch2)&#123; if (branch1 == NULL &amp;&amp; branch2 == NULL) return true; // 递归退出条件 else if (branch1 != NULL &amp;&amp; branch2 == NULL) return false; else if (branch1 == NULL &amp;&amp; branch2 != NULL) return false; else if (branch1 != NULL &amp;&amp; branch2 != NULL) &#123; if (branch1->val != branch2->val) return false; &#125; return (check(branch1->left, branch2->right) &amp;&amp; (check(branch1->right, branch2->left))); &#125; bool isSymmetric(TreeNode* root) &#123; if (root == NULL) return false; return check(root->left, root->right); &#125; &#125;; 迭代写法： class Solution &#123; public: bool isSymmetric(TreeNode* root) &#123; stack&lt;TreeNode*> st; if (root == NULL) return false; else if (root->left == NULL &amp;&amp; root->right == NULL) return true; else if (root->left != NULL &amp;&amp; root->right == NULL) return false; else if (root->left == NULL &amp;&amp; root->right != NULL) return false; else &#123; st.push(root->left); st.push(root->right); &#125; while (!st.empty())&#123; TreeNode* cur1 = st.top(); st.pop(); TreeNode* cur2 = st.top(); st.pop(); if (cur1->left == NULL &amp;&amp; cur2->right != NULL) return false; if (cur1->left != NULL &amp;&amp; cur2->right == NULL) return false; if (cur1->right == NULL &amp;&amp; cur2->left != NULL) return false; if (cur1->right != NULL &amp;&amp; cur2->left == NULL) return false; if (cur1->val != cur2->val) &#123; return false; &#125; if (cur1->left) st.push(cur1->left); if (cur2->right) st.push(cur2->right); if (cur1->right) st.push(cur1->right); if (cur2->left) st.push(cur2->left); &#125; return true; &#125; &#125;; 7.13 完全二叉树的节点个数给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（从第 0 层开始），则该层包含 1~ 2h 个节点。 class Solution &#123; public: int countNodes(TreeNode* root) &#123; int count = 0; if (root == NULL) return 0; queue&lt;TreeNode*> que; que.push(root); while (!que.empty())&#123; int size = que.size(); TreeNode* cur; for (int i = 0; i &lt; size; i++)&#123; cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); count++; &#125; &#125; return count; &#125; &#125;; 7.14 平衡二叉树给定一个二叉树，判断它是否是 平衡二叉树 （ 是指该树所有节点的左右子树的高度相差不超过 1。） class Solution &#123; public: int height (TreeNode* root)&#123; int count = 0; if (root == NULL) return 0; else &#123; int leftdepth = 0; int rightdepth = 0; if (root->left != NULL) leftdepth = height(root->left); if (root->right != NULL) rightdepth = height(root->right); if (root->left == NULL &amp;&amp; root->right == NULL) return 1; return max(leftdepth, rightdepth) + 1; &#125; &#125; bool isBalanced(TreeNode* root) &#123; if (root == NULL) return true; queue&lt;TreeNode*> que; que.push(root); while (!que.empty())&#123; int size = que.size(); TreeNode* cur; for (int i = 0; i &lt; size; i++)&#123; cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); if (height(cur->left) > height(cur->right))&#123; if (height(cur->left) - height(cur->right) > 1) return false; &#125; if (height(cur->left) &lt; height(cur->right))&#123; if (height(cur->right) - height(cur->left) > 1) return false; &#125; &#125; &#125; return true; &#125; &#125;; 7.15 左叶子之和给定二叉树的根节点 root ，返回所有左叶子之和。 class Solution &#123; public: int sumOfLeftLeaves(TreeNode* root) &#123; if (root == NULL) return 0; int sum = 0; queue&lt;TreeNode*> que; que.push(root); while (!que.empty())&#123; int size = que.size(); TreeNode* cur; for (int i = 0; i &lt; size; i++)&#123; cur = que.front(); que.pop(); if (cur->left) &#123; if (cur->left->left == NULL &amp;&amp; cur->left->right == NULL) sum += cur->left->val; que.push(cur->left); &#125; if (cur->right) que.push(cur->right); &#125; &#125; return sum; &#125; &#125;; 7.16 二叉树的所有路径给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。 *回溯思想 class Solution &#123; public: void travelback(TreeNode* root, vector&lt;int> &amp;path, vector&lt;string> &amp;result)&#123; path.push_back(root->val); //终止条件 if (root->left == NULL &amp;&amp; root->right == NULL)&#123; string str; for (auto ch : path)&#123; str += to_string(ch); str += \"->\"; &#125; str.pop_back(); str.pop_back(); result.push_back(str); return; &#125; if (root->left != NULL)&#123; travelback(root->left, path, result); path.pop_back(); // 回溯 &#125; if (root->right != NULL)&#123; travelback(root->right, path, result); path.pop_back(); // 回溯 &#125; &#125; vector&lt;string> binaryTreePaths(TreeNode* root) &#123; vector&lt;string> result; vector&lt;int> path; if (root == NULL) return result; travelback(root, path, result); return result; &#125; &#125;; 7.17 找树左下角的值给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 class Solution &#123; public: int findBottomLeftValue(TreeNode* root) &#123; int result = 0; queue&lt;TreeNode*> que; // if (root == NULL) return -1; que.push(root); while (!que.empty())&#123; int size = que.size(); TreeNode* cur; for (int i = 0; i &lt; size; i++)&#123; cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); if ( i == 0) result = cur->val; &#125; &#125; return result; &#125; &#125;; 7.18 路径总和给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 class Solution &#123; public: void sumcheck(TreeNode* root , int &amp;sum, int &amp;result, int &amp;calculate)&#123; calculate += root->val; if (root ->left == NULL &amp;&amp; root->right == NULL)&#123; if (calculate == sum) result += 1; &#125; if (root->left != NULL)&#123; sumcheck(root->left, sum, result,calculate); calculate -= root->left->val; &#125; if (root->right != NULL)&#123; sumcheck(root->right, sum, result,calculate); calculate -= root->right->val; &#125; &#125; bool hasPathSum(TreeNode* root, int targetSum) &#123; int result = 0; int calculate = 0; if (root == NULL) return false; sumcheck(root, targetSum, result, calculate); if (result) return true; else return false; &#125; &#125;; 7.19 从中序和后序遍历序列构造二叉树给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 *递归 //选择用索引应该会更好 class Solution &#123; public: TreeNode* rebuild(vector&lt;int>&amp; inorder, vector&lt;int>&amp; postorder)&#123; if (postorder.size() == 0) return NULL; int rootvalue = postorder[postorder.size()-1]; TreeNode* root = new TreeNode(rootvalue); if (postorder.size() == 1) return root; vector&lt;int> newleftmiddle; vector&lt;int> newrightmiddle; vector&lt;int> newleftback; vector&lt;int> newrightback; int flag = 0; // 左递归处理 for (auto &amp;ch : inorder)&#123; if (ch != rootvalue &amp;&amp; flag == 0) newleftmiddle.push_back(ch); else if (ch == rootvalue &amp;&amp; flag == 0)&#123; flag = 1; &#125; else newrightmiddle.push_back(ch); &#125; // 右递归处理 for (int i = 0; i &lt; newleftmiddle.size(); i++)&#123; newleftback.push_back(postorder[i]); &#125; for (int i = newleftmiddle.size(); i &lt; postorder.size()-1; i++)&#123; newrightback.push_back(postorder[i]); &#125; root->left = rebuild(newleftmiddle, newleftback); root->right = rebuild(newrightmiddle, newrightback); return root; &#125; TreeNode* buildTree(vector&lt;int>&amp; inorder, vector&lt;int>&amp; postorder) &#123; return rebuild(inorder,postorder); &#125; &#125;; 7.20 最大二叉树给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树\\ 。 class Solution &#123; public: TreeNode* rebuild(vector&lt;int> &amp;nums)&#123; if (nums.size() == 0) return NULL; int max = INT_MIN; int maxindex = 0; for (int i = 0; i &lt; nums.size(); i++)&#123; if (nums[i] > max) &#123; max = nums[i]; maxindex = i; &#125; &#125; TreeNode* root = new TreeNode(max); vector&lt;int> leftnew(nums.begin(), nums.begin()+maxindex); vector&lt;int> rightnew(nums.begin()+maxindex+1, nums.end()); root->left = rebuild(leftnew); root->right = rebuild(rightnew); return root; &#125; TreeNode* constructMaximumBinaryTree(vector&lt;int>&amp; nums) &#123; return rebuild(nums); &#125; &#125;; 7.21 合并二叉树给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 class Solution &#123; public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123; if (root1 == NULL &amp;&amp; root2 == NULL) return NULL; if (root1 == NULL &amp;&amp; root2 != NULL) return root2; if (root1 != NULL &amp;&amp; root2 == NULL) return root1; queue&lt;TreeNode*> que; que.push(root1); que.push(root2); while(!que.empty())&#123; TreeNode* cur1; TreeNode* cur2; cur1 = que.front(); que.pop(); cur2 = que.front(); que.pop(); cur1->val += cur2->val; if (cur1->left &amp;&amp; cur2->left) &#123; que.push(cur1->left); que.push(cur2->left); &#125; if (cur1->right &amp;&amp; cur2->right) &#123; que.push(cur1->right); que.push(cur2->right); &#125; if (!cur1->left &amp;&amp; cur2->left) &#123; cur1->left = cur2->left; &#125; if (!cur1->right &amp;&amp; cur2->right) &#123; cur1->right = cur2->right; &#125; &#125; return root1; &#125; &#125;; 7.22 二叉搜索树中的搜索给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。 二叉搜索树是一个有序树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树 // 写复杂了，其实不需要队列 class Solution &#123; public: TreeNode* searchBST(TreeNode* root, int val) &#123; if (root == NULL) return NULL; queue&lt;TreeNode*> que; que.push(root); TreeNode* resultnode; while (!que.empty())&#123; TreeNode* cur = que.front(); que.pop(); if (cur->val > val)&#123; if (cur->left) que.push(cur->left); else return NULL; &#125; else if (cur->val &lt; val)&#123; if (cur->right) que.push(cur->right); else return NULL; &#125; else &#123; resultnode = cur; break; &#125; &#125; return resultnode; &#125; &#125;; 7.23 验证二叉搜索树给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 严格小于 当前节点的数。 节点的右子树只包含 严格大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 // 只需要利用这个特性：二叉搜索树的中序遍历是递增数列 class Solution &#123; public: bool isValidBST(TreeNode* root) &#123; stack&lt;TreeNode*> st; if (root == NULL) return true; TreeNode* cur = root; TreeNode* pre = NULL; while ( !st.empty() || cur != NULL)&#123; if (cur != NULL) &#123; st.push(cur); cur = cur->left; &#125; else &#123; cur = st.top(); st.pop(); if (pre != NULL &amp;&amp; cur->val &lt;= pre->val) return false; pre = cur; //保存前一个访问的结点 cur = cur->right; &#125; &#125; return true; &#125; &#125;; 7.24 二叉搜索树的最小绝对差给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。 // 中序遍历 递增 class Solution &#123; public: int getMinimumDifference(TreeNode* root) &#123; // if (root == NULL) return 0; stack&lt;TreeNode*> st; TreeNode* cur = root; TreeNode* pre = NULL; int min = INT_MAX; while ( !st.empty() || cur != NULL)&#123; if (cur)&#123; st.push(cur); cur = cur->left; &#125; else &#123; cur = st.top(); st.pop(); //处理 if(pre != NULL)&#123; if ((cur->val) - (pre->val) &lt; min) min = (cur->val) - (pre->val); &#125; pre = cur; cur = cur ->right; &#125; &#125; return min; &#125; &#125;; 7.25 二叉搜索树中的众数给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的众数，即出现频率最高的元素。 如果树中有不止一个众数，可以按 任意顺序 返回。 假定 BST 满足如下定义： 结点左子树中所含节点的值 小于等于 当前节点的值 结点右子树中所含节点的值 大于等于 当前节点的值 左子树和右子树都是二叉搜索树 class Solution &#123; private: void searchBST(TreeNode* root, vector&lt;int> &amp;result) &#123; if (root == NULL) return; stack&lt;TreeNode*> st; int maxcount = 0; int count = 0; TreeNode* cur = root; TreeNode* pre = NULL; while (!st.empty() || cur != NULL)&#123; if (cur)&#123; st.push(cur); cur = cur->left; &#125; else&#123; cur = st.top(); st.pop(); // 重复处理逻辑 if (pre == NULL) count = 1; else &#123; if (pre->val == cur->val)&#123; count ++; &#125; else count = 1; &#125; if (count == maxcount) result.push_back(cur->val); if (count > maxcount)&#123; maxcount = count; result.clear(); result.push_back(cur->val); &#125; pre = cur; cur = cur->right; &#125; &#125; &#125; public: vector&lt;int> findMode(TreeNode* root) &#123; vector&lt;int> result; searchBST(root, result); return result; &#125; &#125;; 7.26 二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” // 有点难度 class Solution &#123; public: TreeNode* ancestorbackforth(TreeNode* root, TreeNode* p, TreeNode* q)&#123; if (root == NULL) return NULL; if (root == p || root == q) return root; TreeNode* left = ancestorbackforth(root->left, p , q); TreeNode* right = ancestorbackforth(root->right, p, q); if (left &amp;&amp; right) return root; else if (!left &amp;&amp; right) return right; else if (left &amp;&amp; !right) return left; else return NULL; &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; return ancestorbackforth(root, p, q); &#125; &#125;; 7.27 二叉搜索树的最近公共祖先相比上一题难度降低很多，利用有序性就行 class Solution &#123; public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == NULL) return NULL; TreeNode* cur = root; while (cur)&#123; if (cur->val > p->val &amp;&amp; cur->val > q->val) cur = cur->left; if (cur->val &lt; p->val &amp;&amp; cur->val &lt; q->val) cur = cur->right; else return cur; &#125; return NULL; &#125; &#125;; 7.28 将有序数组转换为二叉搜索树给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。（指该树所有节点的左右子树的高度相差不超过 1。） class Solution &#123; public: TreeNode* BSTbuild(vector&lt;int> &amp;nums)&#123; TreeNode* root = new TreeNode(0); int middleindex = 0; vector&lt;int> newleft; vector&lt;int> newright; if (nums.size() == 0) return NULL; else if (nums.size() % 2 == 1)&#123; middleindex = nums.size() / 2; root->val = nums[middleindex]; for (int i = 0; i &lt; middleindex; i++)&#123; newleft.push_back(nums[i]); &#125; for (int i = middleindex + 1; i &lt; nums.size(); i++)&#123; newright.push_back(nums[i]); &#125; &#125; else if (nums.size() % 2 == 0)&#123; middleindex = nums.size() / 2; root->val = nums[middleindex]; for (int i = 0; i &lt; middleindex; i++)&#123; newleft.push_back(nums[i]); &#125; for (int i = middleindex + 1; i &lt; nums.size(); i++)&#123; newright.push_back(nums[i]); &#125; &#125; root->left = BSTbuild(newleft); root->right = BSTbuild(newright); return root; &#125; TreeNode* sortedArrayToBST(vector&lt;int>&amp; nums) &#123; // 题目可以转换为：知道二叉搜索树的中序遍历，还原树 // 很容易想到递归 return BSTbuild(nums); &#125; &#125;; 7.29 二叉搜索树中的插入操作给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。 class Solution &#123; public: TreeNode* insertIntoBST(TreeNode* root, int val) &#123; TreeNode* cur = new TreeNode(val); if (root == NULL) &#123; root = cur; return root; &#125; TreeNode* cur1 = root; TreeNode* pre = new TreeNode(0); while (cur1)&#123; if (cur1->val > val) &#123; pre = cur1; cur1 = cur1->left; &#125; else if (cur1->val &lt; val) &#123; pre = cur1; cur1 = cur1->right; &#125; &#125; if (pre->val &lt; val) pre->right = cur; if (pre->val > val) pre->left = cur; return root; &#125; &#125;; 7.30 修剪二叉搜索树给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 class Solution &#123; public: TreeNode* trimBST(TreeNode* root, int L, int R) &#123; if (!root) return nullptr; // 处理头结点，让root移动到[L, R] 范围内，注意是左闭右闭 while (root != nullptr &amp;&amp; (root->val &lt; L || root->val > R)) &#123; if (root->val &lt; L) root = root->right; // 小于L往右走 else root = root->left; // 大于R往左走 &#125; TreeNode *cur = root; // 左侧修剪拼接 while (cur != nullptr) &#123; while (cur->left &amp;&amp; cur->left->val &lt; L) &#123; cur->left = cur->left->right; &#125; cur = cur->left; &#125; cur = root; // 右侧修剪拼接 while (cur != nullptr) &#123; while (cur->right &amp;&amp; cur->right->val > R) &#123; cur->right = cur->right->left; &#125; cur = cur->right; &#125; return root; &#125; &#125;; 7.31 删除二叉搜索树中的节点给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 // 没有想象中简单，需要把边界条件理清楚 class Solution &#123; public: TreeNode* deleteNode(TreeNode* root, int key) &#123; if (root == NULL) return NULL; TreeNode* cur = root; TreeNode* pre = root; while (cur)&#123; if (cur->val > key) &#123; pre = cur; cur = cur -> left; &#125; else if (cur->val &lt; key) &#123; pre = cur; cur = cur -> right; &#125; else break; &#125; if (cur == NULL) return root; else &#123; if (key &lt; pre->val)&#123; if (cur -> right) &#123; TreeNode* newleft = cur ->right; while (newleft -> left)&#123; newleft = newleft ->left; &#125; newleft -> left = cur ->left; pre ->left = cur->right; &#125; else if (cur->left) pre ->left = cur->left; else pre->left = NULL; &#125; if (key > pre->val)&#123; if (cur -> left)&#123; TreeNode* newright = cur ->left; while (newright -> right)&#123; newright = newright ->right; &#125; newright->right = cur->right; pre ->right = cur->left; &#125; else if (cur->right) pre ->right = cur->right; else pre->right = NULL; &#125; if (key == pre->val)&#123; if (cur->left)&#123; TreeNode* newright = cur ->left; while (newright -> right)&#123; newright = newright ->right; &#125; newright->right = cur->right; root = cur->left; &#125; else if (cur->right) root = pre ->right; else &#123; root = NULL; &#125; &#125; &#125; return root; &#125; &#125;; 7.32 把二叉搜索树转换为累加树给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 class Solution &#123; public: //思路：首先遍历一下取得所有节点和，然后中序遍历依次把值换成总和减去前一个节点值 int getsum(TreeNode* root)&#123; if (root == NULL) return 0; int val1 = getsum(root -> left); int val2 = getsum(root -> right); return root->val + (val1 + val2); &#125; TreeNode* convertBST(TreeNode* root) &#123; int sum = getsum(root); if (root == NULL) return NULL; stack&lt;TreeNode*> st; TreeNode* cur = root; int presum = 0; while (!st.empty() || cur != NULL)&#123; if (cur)&#123; st.push(cur); cur = cur->left; &#125; else &#123; cur = st.top(); st.pop(); //计算 presum += cur->val; cur ->val = sum -presum + cur->val; cur = cur ->right; &#125; &#125; return root; &#125; &#125;; &nbsp; 8. 回溯8.0 回溯法模板剪枝时注意递归循环中的起始位置 void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123; 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 &#125; &#125; 8.1 组合给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。 你可以按 任何顺序 返回答案。 class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; void backtraval(int n, int k , int startindex)&#123; // 返回条件 if (path.size() == k)&#123; result.push_back(path); return; &#125; // 递归过程 for (int i = startindex; i &lt;= n; i++)&#123; path.push_back(i); backtraval(n,k,i+1); // 回溯 path.pop_back(); &#125; &#125; vector&lt;vector&lt;int>> combine(int n, int k) &#123; backtraval(n,k,1); return result; &#125; &#125;; 8.2 组合总和Ⅲ找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9 每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; int sum = 0; void backtrack(int n, int k, int startindex)&#123; if (path.size() == k &amp;&amp; sum == n)&#123; result.push_back(path); return; &#125; for (int i = startindex; i &lt;= 9; i++)&#123; path.push_back(i); sum += i; // 剪枝 if (sum > n) &#123; sum -= i; path.pop_back(); return; &#125; backtrack(n,k,i+1); path.pop_back(); sum -= i; &#125; &#125; vector&lt;vector&lt;int>> combinationSum3(int k, int n) &#123; backtrack(n,k,1); return result; &#125; &#125;; 8.3 电话号码的字母组合给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 class Solution &#123; private: const string letterMap[10] = &#123; \"\", // 0 \"\", // 1 \"abc\", // 2 \"def\", // 3 \"ghi\", // 4 \"jkl\", // 5 \"mno\", // 6 \"pqrs\", // 7 \"tuv\", // 8 \"wxyz\", // 9 &#125;; public: string path; vector&lt;string> result; void backtrack(string digits, int length, int startindex)&#123; if (path.size() == length)&#123; result.push_back(path); return; &#125; for (int j = startindex; j &lt; digits.size() ; j++)&#123; int num = digits[j] - '0'; if (num != 7 &amp;&amp; num!= 9)&#123; for (int i = 0; i &lt;= 2; i++)&#123; path.push_back(letterMap[num][i]); backtrack(digits, length, j+1); path.pop_back(); &#125; &#125; else &#123; for (int i = 0; i &lt;= 3; i++)&#123; path.push_back(letterMap[num][i]); backtrack(digits, length, j+1); path.pop_back(); &#125; &#125; &#125; &#125; vector&lt;string> letterCombinations(string digits) &#123; if (digits == \"\") return result; int length = digits.size(); backtrack(digits,length,0); return result; &#125; &#125;; 8.4 组合总和给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 class Solution &#123; public: vector&lt;int> path; vector&lt;vector&lt;int>> result; int sum = 0; void backtrack(vector&lt;int> &amp;candidates, int target, int startindex)&#123; if (sum == target)&#123; result.push_back(path); return; &#125; // 必要剪枝，避免无限递归导致栈溢出 if (sum > target)&#123; return; &#125; for (int i = startindex; i &lt;candidates.size(); i++)&#123; path.push_back(candidates[i]); sum+= candidates[i]; backtrack(candidates, target, i); sum-= candidates[i]; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int>> combinationSum(vector&lt;int>&amp; candidates, int target) &#123; backtrack(candidates,target,0); return result; &#125; &#125;; 8.5 组合总和Ⅱ给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用 一次 。 注意：解集不能包含重复的组合。 // 此写法必须先进行排序 class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; void backtrack(vector&lt;int> &amp;candidates, int target, int startindex, int sum)&#123; if (sum == target)&#123; result.push_back(path); return; &#125; if (sum > target) return; for (int i = startindex; i &lt; candidates.size(); i++)&#123; // 不使用重复值（排序后） if (i > startindex &amp;&amp; candidates[i] == candidates[i-1]) continue; path.push_back(candidates[i]); sum += candidates[i]; backtrack(candidates, target, i + 1 , sum); path.pop_back(); sum -= candidates[i]; &#125; &#125; vector&lt;vector&lt;int>> combinationSum2(vector&lt;int>&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); backtrack(candidates, target, 0,0); return result; &#125; &#125;; 8.6 分割回文串给你一个字符串 s，请你将 s 分割成一些 子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 class Solution &#123; public: vector&lt;vector&lt;string>> result; vector&lt;string> path; int stringcheck(string &amp;s)&#123; for (int i = 0, j = s.size() - 1; i &lt; j; i++, j--)&#123; if (s[i] != s[j])&#123; return 0; &#125; &#125; return 1; &#125; void backtrack(string &amp;s, int startindex)&#123; if (startindex >= s.size())&#123; result.push_back(path); return ; &#125; for (int i = startindex; i &lt; s.size(); i++)&#123; string substr = s.substr(startindex, i - startindex + 1); if ( stringcheck(substr) )// 为回文串 &#123; path.push_back(substr); &#125; else&#123; continue; &#125; backtrack(s, i+1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;string>> partition(string s) &#123; backtrack(s,0); return result; &#125; &#125;; 8.7 复原IP地址有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 &#39;.&#39; 分隔。 例如：&quot;0.1.2.201&quot; 和&quot;192.168.1.1&quot; 是 有效 IP 地址，但是 &quot;0.011.255.245&quot;、&quot;192.168.1.312&quot; 和 &quot;192.168@1.1&quot; 是 无效 IP 地址。 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 &#39;.&#39; 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。 // 有点难度 class Solution &#123; public: vector&lt;string> result; string path; void backtrack(string &amp;s, int startindex, int dotCount) &#123; if (startindex == s.size() &amp;&amp; dotCount == 4) &#123; // 去除末尾的'.' path.pop_back(); result.push_back(path); return; &#125; // 剪枝：提前终止条件：剩余字符太多或太少 if (s.size() - startindex > (4 - dotCount) * 3 || s.size() - startindex &lt; (4 - dotCount)) &#123; return; &#125; for (int i = startindex; i &lt; s.size() &amp;&amp; i &lt; startindex + 3; i++) &#123; string substr = s.substr(startindex, i - startindex + 1); if (isValid(substr)) &#123; int originalSize = path.size(); path += substr + \".\"; backtrack(s, i + 1, dotCount + 1); // 回溯 path.erase(originalSize); &#125; &#125; &#125; bool isValid(string &amp;substr) &#123; if (substr.size() > 1 &amp;&amp; substr[0] == '0') &#123; return false; &#125; int num = stoi(substr); return num >= 0 &amp;&amp; num &lt;= 255; &#125; vector&lt;string> restoreIpAddresses(string s) &#123; if (s.size() &lt; 4 || s.size() > 12) return result; backtrack(s, 0, 0); return result; &#125; &#125;; 8.8 子集给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 // 想复杂了，本质上不需要条件直接返回就行 class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; void backtrack(vector&lt;int> &amp;nums, int startindex , int length)&#123; // condition if (path.size() == length)&#123; result.push_back(path); return; &#125; for (int i = startindex; i &lt; nums.size(); i++ )&#123; path.push_back(nums[i]); backtrack(nums, i+1, length); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int>> subsets(vector&lt;int>&amp; nums) &#123; for (int i = 0; i &lt;= nums.size(); i++)&#123; backtrack(nums,0,i); &#125; return result; &#125; &#125;; 8.9 子集Ⅱ给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。 解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 // 去重也可以用set class Solution &#123; public: vector&lt;int> path; vector&lt;vector&lt;int>> result; void backtrack(vector&lt;int> &amp;nums, int startindex)&#123; //add to result result.push_back(path); for (int i = startindex; i &lt; nums.size(); i++)&#123; //去重 if (i > startindex &amp;&amp; nums[i] == nums[i-1])&#123; continue; &#125; path.push_back(nums[i]); backtrack(nums,i+1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int>> subsetsWithDup(vector&lt;int>&amp; nums) &#123; sort(nums.begin(), nums.end()); backtrack(nums, 0); return result; &#125; &#125;; 8.10 非递减子序列给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。 // 这题不能用sort，因此选择用哈希表去重 class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; void backtrack(vector&lt;int>&amp; nums, int startindex)&#123; if (path.size() >= 2 )&#123; result.push_back(path); // return; &#125; unordered_set&lt;int> used; for (int i = startindex; i &lt; nums.size(); i++)&#123; if (used.find(nums[i]) != used.end()) continue; if (path.size() != 0)&#123; if (nums[i] >= path.back())&#123; used.insert(nums[i]); path.push_back(nums[i]); backtrack(nums, i+1); path.pop_back(); &#125; &#125; else&#123; used.insert(nums[i]); path.push_back(nums[i]); backtrack(nums, i+1); path.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int>> findSubsequences(vector&lt;int>&amp; nums) &#123; backtrack(nums, 0); return result; &#125; &#125;; 8.11 全排列给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 // 经典问题 class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; void backtrack(vector&lt;int> &amp;nums, vector&lt;bool> &amp;used)&#123; if (path.size() == nums.size())&#123; result.push_back(path); return; &#125; // 每次回溯均要从0索引开始 for (int i = 0; i &lt; nums.size(); i++)&#123; if (used[i] == true) continue; path.push_back(nums[i]); used[i] = true; backtrack(nums,used); path.pop_back(); used[i] = false; &#125; &#125; vector&lt;vector&lt;int>> permute(vector&lt;int>&amp; nums) &#123; vector&lt;bool> used(nums.size(), false); backtrack(nums,used); return result; &#125; &#125;; 8.12 全排列Ⅱ给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; void backtrack(vector&lt;int> &amp;nums, vector&lt;bool> &amp;used)&#123; if (path.size() == nums.size())&#123; result.push_back(path); return; &#125; // repeat set记录同一层级(深度)的已使用过的元素集，去重 // 确保在同一层级去重，不影响不同层级选择相同值的元素，同一层级的去重靠used实现 unordered_set&lt;int> repeat; for (int i = 0; i &lt; nums.size(); i++)&#123; if (repeat.find(nums[i]) != repeat.end()) continue; if (used[i] == true) continue; used[i] = true; path.push_back(nums[i]); backtrack(nums, used); path.pop_back(); used[i] = false; repeat.insert(nums[i]); &#125; &#125; vector&lt;vector&lt;int>> permuteUnique(vector&lt;int>&amp; nums) &#123; vector&lt;bool> used(nums.size(), false); backtrack(nums, used); return result; &#125; &#125;; 8.13 N皇后按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。 // 一开始写有两个问题，一是字符串的处理还不够熟练，二是used3状态索引一开始用的abs(i - j) 其实是错的 class Solution &#123; public: vector&lt;string> path; vector&lt;vector&lt;string>> result; void backtrack(int n, int i, vector&lt;bool> &amp;used1, vector&lt;bool> &amp;used2, vector&lt;bool> &amp;used3)&#123; if (i == n)&#123; result.push_back(path); return; &#125; for (int j = 0; j &lt; n; j++)&#123; if ( used1[j] || used2[i+j] || used3[i - j + n]) continue; string s(n, '.'); s[j] = 'Q'; used1[j] = true; used2[i+j] = true; used3[i - j + n] =true; path.push_back(s); backtrack(n, i + 1, used1, used2, used3); used1[j] = false; used2[i+j] = false; used3[i - j + n] =false; path.pop_back(); &#125; &#125; vector&lt;vector&lt;string>> solveNQueens(int n) &#123; vector&lt;bool> used1(n, false); vector&lt;bool> used2(n*n, false); vector&lt;bool> used3(n*n, false); backtrack(n, 0, used1, used2, used3); return result; &#125; &#125;; 8.14 解数独编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 class Solution &#123; public: bool backtrack(vector&lt;vector&lt;char>>&amp; board)&#123; for (int row = 0; row &lt; 9; row++)&#123; for (int col = 0; col &lt; 9; col++)&#123; if (board[row][col] == '.')&#123; for (char k = '1'; k &lt;= '9'; k++)&#123; if (isValid(board, row, col, k)) &#123; board[row][col] = k; if (backtrack(board)) return true; board[row][col] = '.'; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; bool isValid(vector&lt;vector&lt;char>>&amp; board, int row, int col, char k)&#123; for (int i = 0; i &lt; 9; i++)&#123; if (board[row][i] == k) return false; &#125; for (int i = 0; i &lt; 9; i++)&#123; if (board[i][col] == k) return false; &#125; int startrow = (row / 3) * 3; int startcol = (col / 3) * 3; for (int i = startrow; i &lt; startrow + 3; i++)&#123; for (int j = startcol; j &lt; startcol + 3; j++)&#123; if (board[i][j] == k) return false; &#125; &#125; return true; &#125; void solveSudoku(vector&lt;vector&lt;char>>&amp; board) &#123; backtrack(board); &#125; &#125;; &nbsp; 9. 贪心贪心的本质是选择每一阶段的局部最优，从而达到全局最优。 9.1 分发饼干对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。 class Solution &#123; public: int findContentChildren(vector&lt;int>&amp; g, vector&lt;int>&amp; s) &#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int count = 0; int backindex = s.size() - 1; for (int i = g.size() - 1; i >= 0; i--) &#123; if (backindex >= 0 &amp;&amp; s[backindex] >= g[i] ) &#123; backindex--; count++; &#125; if(backindex &lt; 0) break; &#125; return count; &#125; &#125;; 9.2 摆动序列如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。 //注意连续数据相等的情况 class Solution &#123; public: int wiggleMaxLength(vector&lt;int>&amp; nums) &#123; if (nums.size() == 1) return 1; int count = 1; int prevDiff = 0; for (int i = 1; i &lt; nums.size(); i++) &#123; int currDiff = nums[i] - nums[i-1]; if (currDiff == 0) continue; if (prevDiff == 0 || (prevDiff > 0 &amp;&amp; currDiff &lt; 0) || (prevDiff &lt; 0 &amp;&amp; currDiff > 0)) &#123; count++; prevDiff = currDiff; &#125; &#125; return count; &#125; &#125;; 9.3 最大子数组和给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组是数组中的一个连续部分。 class Solution &#123; public: int maxSubArray(vector&lt;int>&amp; nums) &#123; int count = 0; int maxsum = INT_MIN; for (int i = 0; i &lt; nums.size(); i++)&#123; count += nums[i]; if (count > maxsum) maxsum = count; if (count &lt; 0) count = 0; &#125; return maxsum; &#125; &#125;; 9.4 买卖股票的最佳时机Ⅱ给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 class Solution &#123; public: int maxProfit(vector&lt;int>&amp; prices) &#123; int profits = 0; for (int i = 1; i &lt; prices.size(); i++)&#123; int curdiff = prices[i] - prices[i - 1]; if (curdiff > 0)&#123; profits += curdiff; &#125; &#125; return profits; &#125; &#125;; 9.5 跳跃游戏给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。 //写的太复杂了，思路对的，但不需要 跳转 这个操作 class Solution &#123; public: bool canJump(vector&lt;int>&amp; nums) &#123; int length = nums.size(); int startindex = 0; if (nums.size() == 0) return false; while (startindex &lt; nums.size() - 1)&#123; int nextrange = nums[startindex]; if (nextrange == 0) return false; int nextmax = INT_MIN; if (startindex + nextrange >= nums.size() - 1) return true; int recordindex = startindex; for (int i = startindex + 1; i &lt;= startindex + nextrange; i++)&#123; int opt = i + nums[i]; if (opt > nextmax)&#123; nextmax = opt; recordindex = i; &#125; &#125; startindex = recordindex; &#125; return true; &#125; &#125;; // 简单解法 class Solution &#123; public: bool canJump(vector&lt;int>&amp; nums) &#123; int cover = 0; if (nums.size() == 1) return true; for (int i = 0; i &lt;= cover; i++) &#123; cover = max(i + nums[i], cover); if (cover >= nums.size() - 1) return true; &#125; return false; &#125; &#125;; 9.6 跳跃游戏Ⅱ给定一个长度为 n 的 0 索引整数数组 nums。初始位置在下标 0。 每个元素 nums[i] 表示从索引 i 向后跳转的最大长度。换句话说，如果你在索引 i 处，你可以跳转到任意 (i + j) 处： 0 &lt;= j &lt;= nums[i] 且 i + j &lt; n 返回到达 n - 1 的最小跳跃次数。测试用例保证可以到达 n - 1。 class Solution &#123; public: int jump(vector&lt;int>&amp; nums) &#123; int startindex = 0; int count = 0; if (nums.size() == 1) return 0; while (startindex &lt; nums.size() - 1)&#123; int nextrange = nums[startindex]; if (nextrange == 0) &#123; return 0; &#125; int nextmax = INT_MIN; if (startindex + nextrange >= nums.size() - 1)&#123; break; &#125; int recordindex = startindex; for (int i = startindex + 1; i &lt;= startindex + nextrange; i++)&#123; int opt = i + nums[i]; if (opt > nextmax)&#123; nextmax = opt; recordindex = i; &#125; &#125; startindex = recordindex; count ++; &#125; count += 1; return count; &#125; &#125;; 9.7 K次取反后最大化的数组和给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组： 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。 以这种方式修改数组后，返回数组 可能的最大和 。 class Solution &#123; public: int largestSumAfterKNegations(vector&lt;int>&amp; nums, int k) &#123; // 不需要按绝对值排序 for (int i = 0; i &lt; k; i++) &#123; sort(nums.begin(), nums.end()); nums[0] = -nums[0]; &#125; int sum = 0; for (auto&amp; num : nums) &#123; sum += num; &#125; return sum; &#125; &#125;; 9.8 加油站 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 class Solution &#123; public: int canCompleteCircuit(vector&lt;int>&amp; gas, vector&lt;int>&amp; cost) &#123; vector&lt;int> diff(gas.size(), 0); for (int i = 0; i &lt; gas.size(); i++)&#123; diff[i] = gas[i] - cost[i]; &#125; int count = 0; int totalsum = 0; int possum = 0; int negasum = 0; for (int i = 0; i &lt; diff.size(); i++)&#123; if (diff[i] &lt; 0) negasum += diff[i]; if (diff[i] > 0) possum += diff[i]; totalsum += diff[i]; // 这里是精髓 if (totalsum &lt; 0)&#123; count = i + 1; totalsum = 0; &#125; &#125; if ((negasum + possum) &lt; 0) return -1; else return count; &#125; &#125;; 9.9 分发糖果n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻两个孩子中，评分更高的那个会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。 //没想出来 class Solution &#123; public: int candy(vector&lt;int>&amp; ratings) &#123; int sum = 0; vector&lt;int> candycount(ratings.size(), 1); for (int i = 0; i &lt; ratings.size()-1; i++)&#123; if (ratings[i+1] > ratings[i]) candycount[i+1] = candycount[i] + 1; &#125; for (int i = ratings.size() - 2; i >= 0; i--)&#123; if (ratings[i+1] &lt; ratings[i]) &#123; //贪心思想在这里 candycount[i] = max(candycount[i+1] + 1, candycount[i]); &#125; &#125; for (int i = 0; i &lt; candycount.size(); i++)&#123; sum += candycount[i]; &#125; return sum; &#125; &#125;; 9.10 柠檬水找零在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 注意，一开始你手头没有任何零钱。 给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 class Solution &#123; public: bool lemonadeChange(vector&lt;int>&amp; bills) &#123; unordered_map&lt;int,int> cash; for (int i = 0; i &lt; bills.size(); i++)&#123; if(bills[i] == 5) cash[5]++; else if (bills[i] == 10) &#123; cash[10]++; if (cash[5]>0) cash[5]--; else return false; &#125; else&#123; cash[20]++; //优先找10块钱的 if (cash[5]>0 &amp;&amp; cash[10]>0)&#123; cash[5]--; cash[10]--; &#125; else if (cash[5]>=3)&#123; cash[5] -= 3; &#125; else return false; &#125; &#125; return true; &#125; &#125;; 9.11 根据身高重建队列假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。 //两个判断条件，先梳理好一个再考虑另外一个 class Solution &#123; public: //类内定义cmp需要使用静态成员函数，防止this指针出现 static bool cmp(const vector&lt;int>&amp; a, const vector&lt;int>&amp;b)&#123; if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] > b[0]; &#125; vector&lt;vector&lt;int>> reconstructQueue(vector&lt;vector&lt;int>>&amp; people) &#123; vector&lt;vector&lt;int>> queue; sort(people.begin(), people.end(), cmp); for (int i = 0; i &lt; people.size(); i++)&#123; int index = people[i][1]; queue.insert(queue.begin() + index, people[i]); &#125; return queue; &#125; &#125;; 9.12 用最少数量的箭引爆气球有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。 一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x``start，x``end， 且满足 xstart ≤ x ≤ x``end，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。 给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。 //秒了 class Solution &#123; public: static bool cmp(const vector&lt;int> &amp;a, const vector&lt;int> &amp;b)&#123; if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] &lt; b[0]; &#125; int findMinArrowShots(vector&lt;vector&lt;int>>&amp; points) &#123; sort(points.begin(), points.end(), cmp); int count = points.size(); int rightboundary = points[0][1]; for (int i = 0; i &lt; points.size() - 1; i++)&#123; if (points[i+1][0] &lt;= rightboundary)&#123; rightboundary = min(rightboundary, points[i+1][1]); count--; &#125; else rightboundary = points[i+1][1]; &#125; return count; &#125; &#125;; 9.13 无重叠区间给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。 注意 只在一点上接触的区间是 不重叠的。例如 [1, 2] 和 [2, 3] 是不重叠的。 //思想同上，边界处理方式不同 class Solution &#123; public: static bool cmp(const vector&lt;int> &amp;a, const vector&lt;int> &amp;b)&#123; if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] &lt; b[0]; &#125; int eraseOverlapIntervals(vector&lt;vector&lt;int>>&amp; intervals) &#123; int result = 0; sort(intervals.begin(), intervals.end(), cmp); int right = intervals[0][1]; for (int i = 0; i &lt; intervals.size()-1; i++)&#123; if(intervals[i+1][0] &lt; right)&#123; result++; right = min(intervals[i+1][1], right); &#125; else &#123; right = intervals[i+1][1]; &#125; &#125; return result; &#125; &#125;; 9.14 划分字母区间给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 &quot;ababcc&quot; 能够被分为 [&quot;abab&quot;, &quot;cc&quot;]，但类似 [&quot;aba&quot;, &quot;bcc&quot;] 或 [&quot;ab&quot;, &quot;ab&quot;, &quot;cc&quot;] 的划分是非法的。 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。 返回一个表示每个字符串片段的长度的列表。 // 用哈希表记录每个字符出现的最后位置 // 统计每一个字符最后出现的位置 // 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点 class Solution &#123; public: vector&lt;int> partitionLabels(string s) &#123; vector&lt;int> hash(27,0); for (int i = 0; i &lt; s.size(); i++)&#123; hash[s[i] - 'a'] = i; &#125; int maxindex = 0; vector&lt;int> result; int left = 0; for (int right = 0; right &lt; s.size(); right++)&#123; maxindex = max(maxindex, hash[s[right] - 'a']); if (right == maxindex)&#123; result.push_back(right - left + 1); left = right + 1; &#125; &#125; return result; &#125; &#125;; 9.15 合并区间以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 class Solution &#123; public: static bool cmp(const vector&lt;int> &amp;a, const vector&lt;int> &amp;b)&#123; if (a[0] == b[0] ) return a[1] &lt; b[1]; return a[0] &lt; b[0]; &#125; vector&lt;vector&lt;int>> merge(vector&lt;vector&lt;int>>&amp; intervals) &#123; vector&lt;vector&lt;int>> result; vector&lt;int> ele(2,0); sort(intervals.begin(), intervals.end(), cmp); int right = intervals[0][1]; int left = intervals[0][0]; for (int i = 0; i &lt; intervals.size() - 1; i++)&#123; if (intervals[i+1][0] &lt;= right)&#123; right = max(intervals[i+1][1], right); &#125; else&#123; ele[0] = left; ele[1] = right; result.push_back(ele); left = intervals[i+1][0]; right = intervals[i+1][1]; &#125; &#125; //最后一项也放进去 ele[0] = left; ele[1] = right; result.push_back(ele); return result; &#125; &#125;; 9.16 单调递增的数字当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。 给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。 //本题用字符串就不需要考虑数据大小的问题了 class Solution &#123; public: int monotoneIncreasingDigits(int n) &#123; if (n == 0) return 0; vector&lt;int> nums; while (n > 0)&#123; int num = n % 10; n = n / 10; nums.push_back(num); &#125; for (int i = 0; i &lt; nums.size()-1; i++)&#123; if (nums[i] &lt; nums[i+1])&#123; for (int j = 0; j &lt;= i; j++) nums[j] = 9; nums[i+1] = nums[i+1] - 1; &#125; &#125; int sum = 0; //测试例有较大数据，用long long weight = 1; for (int i = 0; i &lt; nums.size(); i++)&#123; sum += nums[i] * weight; weight *= 10; &#125; return sum; &#125; &#125;; 9.17 监控二叉树给定一个二叉树，我们在树的节点上安装摄像头。 节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。 计算监控树的所有节点所需的最小摄像头数量。 //难度高 //贪心思想：从叶子节点向上搜索，叶子节点的父节点需要安装，再往上每隔2个节点放一个 //0：该节点无覆盖 //1：本节点有摄像头 //2：本节点有覆盖 class Solution &#123; private: int result; int traversal(TreeNode* cur) &#123; // 空节点，该节点有覆盖 if (cur == NULL) return 2; int left = traversal(cur->left); // 左 int right = traversal(cur->right); // 右 // 情况1 // 左右节点都有覆盖 if (left == 2 &amp;&amp; right == 2) return 0; // 情况2 // left == 0 &amp;&amp; right == 0 左右节点无覆盖 // left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖 // left == 0 &amp;&amp; right == 1 左节点有无覆盖，右节点摄像头 // left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖 // left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖 if (left == 0 || right == 0) &#123; result++; return 1; &#125; // 情况3 // left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖 // left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头 // left == 1 &amp;&amp; right == 1 左右节点都有摄像头 // 其他情况前段代码均已覆盖 if (left == 1 || right == 1) return 2; // 这个 return -1 逻辑不会走到这里。 return -1; &#125; public: int minCameraCover(TreeNode* root) &#123; result = 0; // 情况4 if (traversal(root) == 0) &#123; // root 无覆盖 result++; &#125; return result; &#125; &#125;; 10. 动态规划动态规划中每一个状态一定是由上一个状态推导出来的，这一点区分于贪心，贪心没有状态推导，而是从局部直接选最优的。 10.1 斐波那契数斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) &#x3D; 0，F(1) &#x3D; 1 F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1 给定 n ，请计算 F(n) 。 class Solution &#123; public: int fib(int n) &#123; if (n == 0 ) return 0; if (n == 1 ) return 1; return (fib(n-1) + fib(n-2)); &#125; &#125;; //dp 形式 class Solution &#123; public: int fib(int n) &#123; if (n == 0 ) return 0; if (n == 1 ) return 1; vector&lt;int> dp(n+1,0); dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= n; i++)&#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n]; &#125; &#125;; // 递归比dp效率低，因为很多值被重复计算了多次 10.2 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ class Solution &#123; public: int climbStairs(int n) &#123; if (n &lt;= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针 vector&lt;int> dp(n+1,0); dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++)&#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n]; &#125; &#125;; 10.3 使用最小花费爬楼梯给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。 请你计算并返回达到楼梯顶部的最低花费。 class Solution &#123; public: int minCostClimbingStairs(vector&lt;int>&amp; cost) &#123; vector&lt;int> dp(cost.size()+2,0); dp[0] = 0; dp[1] = 0; for (int i = 2; i &lt;= cost.size(); i++)&#123; dp[i] = min(dp[i-1] + cost[i-1] , dp[i-2] + cost[i-2]); &#125; return dp[cost.size()]; &#125; &#125;; 10.4 不同路径一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ class Solution &#123; public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int>> dp(m,vector&lt;int> (n,0)); for (int i = 0; i &lt; n; i++)&#123; dp[0][i] = 1; &#125; for (int i = 0; i &lt; m; i++)&#123; dp[i][0] = 1; &#125; for (int i = 1; i &lt; m ; i++)&#123; for (int j = 1; j &lt; n; j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125; &#125;; 10.5 不同路径Ⅱ给定一个 m x n 的整数数组 grid。一个机器人初始位于 左上角（即 grid[0][0]）。机器人尝试移动到 右下角（即 grid[m - 1][n - 1]）。机器人每次只能向下或者向右移动一步。 网格中的障碍物和空位置分别用 1 和 0 来表示。机器人的移动路径中不能包含 任何 有障碍物的方格。 返回机器人能够到达右下角的不同路径数量。 测试用例保证答案小于等于 2 * 109。 class Solution &#123; public: int uniquePathsWithObstacles(vector&lt;vector&lt;int>>&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;vector&lt;int>> dp(m, vector&lt;int>(n,0)); for (int i = 0; i &lt; m; i++) &#123; if (obstacleGrid[i][0] == 0) dp[i][0] = 1; if (obstacleGrid[i][0] == 1) &#123; for (int j = i; j &lt; m; j++) dp[j][0] = 0; break; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (obstacleGrid[0][i] == 0) dp[0][i] = 1; if (obstacleGrid[0][i] == 1) &#123; for (int j = i; j &lt; n; j++) dp[0][j] = 0; break; &#125; &#125; for (int i = 1; i &lt; m; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; if (obstacleGrid[i][j])&#123; dp[i][j] = 0; &#125; else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125; &#125;; 10.6 整数拆分给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。 // 拆分成2个数和3个数及以上的情况 class Solution &#123; public: int integerBreak(int n) &#123; vector&lt;int> dp(n+1,0); dp[2] = 1; dp[1] = 1; for (int i = 3; i &lt;= n; i++)&#123; for (int j = 1; j &lt; i ; j++)&#123; //首个max():内层遍历 第二个max():比较2个数和多个数大小 dp[i] = max( dp[i] , max(j*(i-j), j*dp[i-j])); &#125; &#125; return dp[n]; &#125; &#125;; 10.7 不同的二叉搜索树给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 class Solution &#123; public: int numTrees(int n) &#123; vector&lt;int> dp(n+1, 0); if (n &lt;= 2) return n; dp[0] = 1; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++)&#123; for (int j = 0; j &lt; i; j++)&#123; dp[i] += dp[j] * dp[i - j - 1]; &#125; &#125; return dp[n]; &#125; &#125;; 10.8 01背包问题小明需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。 输入描述： 第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。 第二行包含 M 个正整数，代表每种研究材料的所占空间。 第三行包含 M 个正整数，代表每种研究材料的价值。 输出整数代表小明能够携带的研究材料的最大价值。 #include &lt;iostream> #include &lt;vector> using namespace std; int main()&#123; int type, luggage; cin >> type >> luggage; vector&lt;int> space(type,0); vector&lt;int> value(type,0); for (int i = 0; i &lt; type; i++)&#123; cin >> space[i]; &#125; for (int i = 0; i &lt; type; i++)&#123; cin >> value[i]; &#125; vector&lt;vector&lt;int>> dp(type, vector&lt;int>(luggage + 1,0)); //初始化dp //1. dp[i][0] for(int i = 0; i &lt; type; i++)&#123; dp[i][0] = 0; &#125; //2. dp[0][j] for (int j = space[0]; j &lt; luggage + 1; j++)&#123; dp[0][j] = value[0]; &#125; //递推,dp[i][j] 表示在j的空间下，在前i种选择里能达到的最大价值 // 有两种情况，1是取i的物品，2是不取 for (int i = 1; i &lt; type; i++)&#123; for (int j = 0; j &lt; luggage+1; j++)&#123; if (j >= space[i]) dp[i][j] = max(dp[i-1][j] , dp[i-1][j-space[i]] + value[i]); else dp[i][j] = dp[i-1][j]; //cout &lt;&lt; dp[i][j]&lt;&lt; ' '; &#125; &#125; cout &lt;&lt; dp[type-1][luggage]; return 0; &#125; // 一维压缩 这里使用递减的原因是二维状态转移时左上方数值需要保留以用来参考，则一维需要保留左侧数值参考 #include &lt;iostream> #include &lt;vector> using namespace std; int main()&#123; int type, luggage; cin >> type >> luggage; vector&lt;int> space(type,0); vector&lt;int> value(type,0); for (int i = 0; i &lt; type; i++)&#123; cin >> space[i]; &#125; for (int i = 0; i &lt; type; i++)&#123; cin >> value[i]; &#125; //初始化 vector&lt;int> dp(luggage + 1,0); // 新增一层物品状态来源于上一层状态 for (int i = 0; i &lt; type; i++)&#123; for (int j = luggage; j >= space[i]; j--)&#123; dp[j] = max(dp[j] , dp[j-space[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp[luggage]; return 0; &#125; 10.9 分割等和子集给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 class Solution &#123; public: bool canPartition(vector&lt;int>&amp; nums) &#123; vector&lt;int> dp(10001,0); int sum = 0; int target = 0; for (int i = 0; i &lt; nums.size(); i++)&#123; sum += nums[i]; &#125; if (sum % 2) return false; else target = sum / 2; for (int i = 0; i &lt; nums.size(); i++)&#123; for (int j = target; j >= nums[i]; j--)&#123; dp[j] = max(dp[j], dp[j-nums[i]] + nums[i]); &#125; &#125; //判断能否分割，看 sum的一半 背包能否被装满 if (dp[target] == target) return true; return false; &#125; &#125;; 10.10 最后一块石头的重量Ⅱ有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。 class Solution &#123; public: int lastStoneWeightII(vector&lt;int>&amp; stones) &#123; vector&lt;int> dp(15001,0); int sum = 0; int target = 0; for (int i = 0; i &lt; stones.size(); i++)&#123; sum += stones[i]; &#125; target = sum / 2; for (int i = 0; i &lt; stones.size(); i++)&#123; for (int j = target; j >= stones[i]; j--)&#123; dp[j] = max(dp[j], dp[j-stones[i]] + stones[i]); &#125; &#125; return (sum - dp[target]) - dp[target]; &#125; &#125;; 10.11 目标和给你一个非负整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 &#39;+&#39; 或 &#39;-&#39; ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 &#39;+&#39; ，在 1 之前添加 &#39;-&#39; ，然后串联起来得到表达式 &quot;+2-1&quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 class Solution &#123; public: int findTargetSumWays(vector&lt;int>&amp; nums, int target) &#123; int sum = 0; for (int i = 0; i &lt; nums.size(); i++)&#123; sum += nums[i]; &#125; if (abs(target) > sum) return 0; if ((sum + target) % 2) return 0; int bagsize = (sum + target) / 2; vector&lt;int> dp(bagsize+1,0); dp[0] = 1; for (int i = 0; i &lt; nums.size();i++)&#123; for (int j = bagsize; j>=nums[i]; j--)&#123; // 组合问题用二维的方式先思考一遍 dp[j] = dp[j] + dp[j-nums[i]]; &#125; &#125; return dp[bagsize]; &#125; &#125;; 10.12 一和零给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 //相当于物品有两个维度的重量 class Solution &#123; public: int findMaxForm(vector&lt;string>&amp; strs, int m, int n) &#123; vector&lt;vector&lt;int>> dp(m+1, vector&lt;int>(n+1,0)); for (auto &amp;s : strs)&#123; int zeronum = 0; int onenum = 0; for (auto &amp;ch : s)&#123; if (ch == '0') zeronum ++; else onenum ++; &#125; //向后遍历原因：实际上这两层for循环都是在遍历背包，又根据递推式可知后一次遍历的值需要和之前的左上方对比，因此需要从后向前遍历 for (int i = m; i >= zeronum; i--)&#123; for(int j = n; j >= onenum; j--)&#123; dp[i][j] = max(dp[i][j], dp[i-zeronum][j-onenum] + 1); &#125; &#125; &#125; return dp[m][n]; &#125; &#125;; 10.13 完全背包小明需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的重量，并且具有不同的价值。 小明的行李箱所能承担的总重量是有限的，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。 输入描述 第一行包含两个整数，n，v，分别表示研究材料的种类和行李所能承担的总重量 接下来包含 n 行，每行两个整数 wi 和 vi，代表第 i 种研究材料的重量和价值 // 由于 可以重复取 这一特性，dp初始化与递归式与01背包不同 #include &lt;iostream> #include &lt;vector> using namespace std; int main()&#123; int type, bagsize; cin >> type >> bagsize; vector&lt;int> weight(type, 0); vector&lt;int> value(type, 0); for (int i = 0; i &lt; type; i++) cin >> weight[i]>> value[i]; vector&lt;vector&lt;int>> dp(type , vector&lt;int>(bagsize + 1, 0)); // 初始化 for (int j = weight[0]; j &lt;= bagsize; j++) dp[0][j] = dp[0][j - weight[0]] + value[0]; for (int i = 1; i &lt; type; i++)&#123; for (int j = 0; j &lt;= bagsize; j++)&#123; if (j >= weight[i]) // 这里递归式需要注意也可以取当前行的 dp[i][j] = max(dp[i-1][j], dp[i][j - weight[i]] + value[i]); else dp[i][j] = dp[i-1][j]; &#125; &#125; cout &lt;&lt; dp[type - 1][bagsize] &lt;&lt; endl; &#125; 10.14 零钱兑换Ⅱ给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。 class Solution &#123; public: int change(int amount, vector&lt;int>&amp; coins) &#123; // 用uint64_t 应对最后一个测试用例 vector&lt;vector&lt;uint64_t>> dp(coins.size(), vector&lt;uint64_t>(amount + 1,0)); // 初始化 for (int i = 0; i &lt; coins.size(); i++) dp[i][0] = 1; for (int i = 0; i &lt;= amount; i++)&#123; if (i % coins[0] == 0) dp[0][i] =1; &#125; // 递推 for (int i = 1; i &lt; coins.size(); i++)&#123; for (int j = 0; j &lt;= amount; j++ )&#123; if (j >= coins[i]) dp[i][j] = dp[i-1][j] + dp[i][ j - coins[i]]; else dp[i][j] = dp[i-1][j]; &#125; &#125; return dp[coins.size() - 1][amount]; &#125; &#125;; //一维dp // 可压缩原因：尽管从递推公式上看，dp[i][j]由前一行和本行共同决定，貌似不能压缩，但是其实由于完全背包的特性，只要从前向后遍历，就能保留本行的结果 class Solution &#123; public: int change(int amount, vector&lt;int>&amp; coins) &#123; vector&lt;uint64_t> dp(amount + 1,0); // 初始化 dp[0] = 1; // 递推 for (int i = 0; i &lt; coins.size(); i++)&#123; for (int j = 0; j &lt;= amount; j++ )&#123; if (j >= coins[i]) dp[j] += dp[j - coins[i]]; else dp[j] = dp[j]; &#125; &#125; return dp[amount]; &#125; &#125;; // 一维完全背包dp递推一个重要的性质，将内外循环顺序对换后，是组合与排列的区别 //组合数的递推： //dp[j] 只依赖于之前已经计算过的组合，不会产生重复的顺序排列 //排列数的递推： //对于每个金额j，都会考虑所有可能的硬币作为最后一步，从而产生所有可能的排列 10.15 组合问题Ⅳ给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。 题目数据保证答案符合 32 位整数范围。 // 求排列就是求排列，还叫组合问题就不太对了 class Solution &#123; public: int combinationSum4(vector&lt;int>&amp; nums, int target) &#123; vector&lt;uint64_t> dp(target+1, 0); dp[0] = 1; for (int j = 0; j &lt;= target; j++)&#123; for (int i = 0; i &lt; nums.size(); i++)&#123; if (j >= nums[i]) dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125; &#125;; 10.16 爬楼梯进阶假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬至多m (1 &lt;= m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 #include &lt;iostream> #include &lt;vector> using namespace std; int main()&#123; int n , m; cin >> n >> m; vector&lt;int> dp(n + 1, 0); dp[0] = 1; for (int j = 0; j &lt;= n; j++)&#123; for (int i = 1; i &lt;= m; i++)&#123; if (j >= i) dp[j] += dp[j - i]; &#125; &#125; cout &lt;&lt; dp[n]; return 0; &#125; 10.17 零钱兑换给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 class Solution &#123; public: int coinChange(vector&lt;int>&amp; coins, int amount) &#123; vector&lt;vector&lt;int>> dp(coins.size(), vector&lt;int>(amount+1 , INT_MAX)); // 初始化 for (int i = 0; i &lt;= amount; i++)&#123; if (i % coins[0] == 0) dp[0][i] = i / coins[0]; &#125; for (int i = 0; i &lt; coins.size(); i++)&#123; dp[i][0] = 0; &#125; // 递推 for (int i = 1; i &lt; coins.size(); i++)&#123; for (int j = 0; j &lt;= amount; j++)&#123; if (j >= coins[i]) &#123; if (dp[i][j - coins[i]] == INT_MAX) dp[i][j] = dp[i-1][j]; else dp[i][j] = min(dp[i-1][j], dp[i][j - coins[i]] + 1); &#125; else dp[i][j] = dp[i - 1][j]; &#125; &#125; if (dp[coins.size() - 1][amount] == INT_MAX) return -1; return dp[coins.size() - 1][amount]; &#125; &#125;; 10.18 完全平方数给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 class Solution &#123; public: int numSquares(int n) &#123; vector&lt;int> dp(n+1); dp[0] = 0; for (int i = 1; i &lt;= n; i++) dp[i] = i; for (int i = 2; i &lt;= sqrt(n); i++)&#123; for (int j = 0; j &lt;= n; j++)&#123; if (j >= i*i) dp[j] = min(dp[j], dp[j - i*i] + 1); &#125; &#125; return dp[n]; &#125; &#125;; 10.19 单词拆分给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。 注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 // 想法有点难度 递推公式比较特殊 不能纠结于“背包”概念 class Solution &#123; public: bool wordBreak(string s, vector&lt;string>&amp; wordDict) &#123; unordered_set&lt;string> wordSet(wordDict.begin(), wordDict.end()); vector&lt;bool> dp(s.size() + 1, false); dp[0] = true; for (int i = 1; i &lt;= s.size(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; string word = s.substr(j, i - j); //substr(起始位置，截取的个数) if (wordSet.find(word) != wordSet.end() &amp;&amp; dp[j]) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.size()]; &#125; &#125;; 10.20 打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 // dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。 class Solution &#123; public: int rob(vector&lt;int>&amp; nums) &#123; if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; vector&lt;int> dp(nums.size(), 0); dp[0] = nums[0]; dp[1] = max(nums[0] , nums[1]); for (int i = 2; i &lt; nums.size(); i++)&#123; dp[i] = max(dp[i - 2] + nums[i] , dp[i-1]); &#125; return dp[nums.size() - 1]; &#125; &#125;; 10.21 打家劫舍Ⅱ你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 //按首尾包含情况分两种讨论 class Solution &#123; public: int rob(vector&lt;int>&amp; nums) &#123; if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; if (nums.size() == 2) return max(nums[0], nums[1]); vector&lt;int> dp(nums.size(), 0); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i &lt; nums.size() - 1; i++)&#123; dp[i] = max(dp[i-1] , dp[i-2] + nums[i]); &#125; int result1 = dp[nums.size() - 2]; dp = vector&lt;int>(nums.size(), 0); dp[1] = nums[1]; dp[2] = max(dp[1], nums[2]); for (int i = 3; i &lt; nums.size(); i++)&#123; dp[i] = max(dp[i-1] , dp[i-2] + nums[i]); &#125; int result2 = dp[nums.size() - 1]; return max(result1, result2); &#125; &#125;; 10.22 打家劫舍Ⅲ小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。 除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。 给定二叉树的 root 。返回 *在不触动警报的情况下 ，小偷能够盗取的最高金额* 。 // 一开始的错误思路 // 层序遍历后把每层的和作为一次value // 这样写的问题，漏了一些情况，比如[2,1,3,null,4] class Solution &#123; public: int rob(TreeNode* root) &#123; if (root == NULL) return 0; queue&lt;TreeNode*> que; int layer = 0; que.push(root); vector&lt;int> value; while (!que.empty())&#123; int size = que.size(); int layervalue = 0; for (int i = 0; i &lt; size; i++)&#123; TreeNode* cur = que.front(); que.pop(); layervalue += cur->val; if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); &#125; value.push_back(layervalue); layer++; &#125; if (layer == 1) return value[0]; vector&lt;int> dp(layer,0); dp[0] = value[0]; dp[1] = max(value[0], value[1]); for (int i = 2; i &lt; layer; i++)&#123; dp[i] = max(dp[i-2] + value[i], dp[i-1]); &#125; return dp[layer - 1]; &#125; &#125;; // 思路：把dp由一维数组转换成树形结果 class Solution &#123; public: vector&lt;int> robtree(TreeNode* cur)&#123; // 两种情况，对应不选本节点和选本节点 //所以dp数组：下标为0记录不选该节点所得到的的最大金钱，下标为1记录选该节点所得到的的最大金钱。 vector&lt;int> result(2,0); if (cur == NULL) return result; vector&lt;int> left = robtree(cur->left); vector&lt;int> right = robtree(cur->right); // 不选本节点 result[0] = max(left[0], left[1]) + max(right[0], right[1]); // 选本节点 result[1] = cur->val + left[0] + right[0]; return result; &#125; int rob(TreeNode* root) &#123; vector&lt;int> result = robtree(root); return max(result[0], result[1]); &#125; &#125;; 10.23 买卖股票的最佳时机给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 // 想法：dp[i][0] 表示第i天持有股票所得最多现金 // dp[i][1] 表示第i天不持有股票所得最多现金 /* 如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0] 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i] 那么dp[i][0]应该选所得现金最大的，所以dp[i][0] = max(dp[i - 1][0], -prices[i]); 如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1] 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1][0] 同样dp[i][1]取最大的，dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]); */ class Solution &#123; public: int maxProfit(vector&lt;int>&amp; prices) &#123; if (prices.size() == 0) return 0; vector&lt;vector&lt;int>> dp(prices.size(), vector&lt;int>(2, 0)); dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; prices.size(); i++)&#123; dp[i][0] = max(dp[i-1][0], -prices[i]); dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0]); &#125; return dp[prices.size() - 1][1]; &#125; &#125;; 10.24 买卖股票的最佳时机Ⅱ（dp写）给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 // 之前用贪心写过， 用dp方法写一下 class Solution &#123; public: int maxProfit(vector&lt;int>&amp; prices) &#123; if (prices.size() == 0) return 0; vector&lt;vector&lt;int>> dp(prices.size(), vector&lt;int>(2,0)); dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; prices.size(); i++)&#123; // 这里是与上一题的区别之处: max中的后一项指第i天持有股票，可以是前一天不持有股票，今天买入后的现金; 上一题由于一共只能买一次，因此买之前一定现金为0 dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]); dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]); &#125; return dp[prices.size() - 1][1]; &#125; &#125;; 10.25 买卖股票的最佳时机Ⅲ给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 class Solution &#123; public: int maxProfit(vector&lt;int>&amp; prices) &#123; if (prices.size() == 0) return 0; vector&lt;vector&lt;int>> dp(prices.size(), vector&lt;int>(4,0)); dp[0][0] = -prices[0]; dp[0][1] = 0; dp[0][2] = -prices[0]; dp[0][3] = 0; for (int i = 1; i &lt; prices.size(); i++)&#123; // first hold dp[i][0] = max(dp[i-1][0], -prices[i]); // first unhold dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]); // second hold dp[i][2] = max(dp[i-1][2], dp[i-1][1] - prices[i]); // second unhold dp[i][3] = max(dp[i-1][3], dp[i-1][2] + prices[i]); &#125; // return dp[prices.size() - 1][3]; 这个包含下面的情况 return max(dp[prices.size() - 1][1], dp[prices.size() - 1][3]); &#125; &#125;; 10.26 买卖股票的最佳时机Ⅳ给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 // 从上一题归纳而来 class Solution &#123; public: int maxProfit(int k, vector&lt;int>&amp; prices) &#123; if (prices.size() == 0) return 0; vector&lt;vector&lt;int>> dp(prices.size(), vector&lt;int>(k*2,0)); for (int j = 0; j &lt; 2*k; j++)&#123; if ( j % 2 == 0) dp[0][j] = -prices[0]; else dp[0][j] = 0; &#125; for (int i = 1; i &lt; prices.size(); i++)&#123; dp[i][0] = max(dp[i-1][0], -prices[i]); for (int j = 1; j &lt; 2 * k; j++)&#123; if (j % 2) // unhold dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i]); else // hold dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] - prices[i]); &#125; &#125; return dp[prices.size() - 1][2*k-1]; &#125; &#125;; 10.27 买卖股票的最佳时机含冷冻期给定一个整数数组prices，其中第 prices[i] 表示第 *i* 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 // 除了基础的状态外增加冷冻期状态和当天卖出状态 /* 持有股票状态（状态一）即：dp[i][0]，有两个操作： 1：前一天就是持有股票状态（状态一），dp[i][0] = dp[i - 1][0] 2：今天买入了，有两种情况 前一天是冷冻期（状态四），dp[i - 1][3] - prices[i] 前一天是保持卖出股票的状态（状态二），dp[i - 1][1] - prices[i] 那么dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]); 无股票且不进入冷冻期（当天不卖出）状态（状态二）即：dp[i][1]，有两个具体操作： 操作一：前一天就是状态二 操作二：前一天是冷冻期（状态四） dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]); 无股票且进入冷冻期（当天卖出股票）状态（状态三），即：dp[i][2] ，只有一个操作： 昨天一定是持有股票状态（状态一），今天卖出 即：dp[i][2] = dp[i - 1][0] + prices[i]; 冷冻期状态（状态四），即：dp[i][3]，只有一个操作： 昨天卖出了股票（状态三） dp[i][3] = dp[i - 1][2]; */ class Solution &#123; public: int maxProfit(vector&lt;int>&amp; prices) &#123; int n = prices.size(); if (n == 0) return 0; vector&lt;vector&lt;int>> dp(n, vector&lt;int>(4, 0)); dp[0][0] = -prices[0]; for (int i = 1; i &lt; n; i++) &#123; dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i])); dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]); dp[i][2] = dp[i - 1][0] + prices[i]; dp[i][3] = dp[i - 1][2]; &#125; return max(dp[n - 1][3], max(dp[n - 1][1], dp[n - 1][2])); &#125; &#125;; 10.28 买卖股票的最佳时机含手续费给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 class Solution &#123; public: int maxProfit(vector&lt;int>&amp; prices, int fee) &#123; if (prices.size() == 0) return 0; vector&lt;vector&lt;int>> dp(prices.size(), vector&lt;int>(2,0)); dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; prices.size(); i++)&#123; dp[i][0] = max(dp[i-1][0] , dp[i-1][1] - prices[i]); dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee); &#125; return dp[prices.size() - 1][1]; &#125; &#125;; 10.30 最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 class Solution &#123; public: int lengthOfLIS(vector&lt;int>&amp; nums) &#123; if (nums.size() &lt;= 1) return nums.size(); // dp[i] : longest subarray end by num[i] vector&lt;int> dp(nums.size() , 1); int result = 0; for (int i = 1; i &lt; nums.size(); i++)&#123; // search the longest subarray end by element before num[i] for (int j = 0; j &lt; i; j++)&#123; if (nums[i] > nums[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; if (dp[i] > result) result = dp[i]; &#125; return result; &#125; &#125;; 10.31 最长连续递增序列给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。 class Solution &#123; public: int findLengthOfLCIS(vector&lt;int>&amp; nums) &#123; if (nums.size() &lt;= 1) return nums.size(); vector&lt;int> dp(nums.size(), 1); int result = 0; for (int i = 1; i &lt; nums.size(); i++)&#123; if (nums[i] > nums[i-1]) dp[i] = dp[i-1] + 1; if (dp[i] > result) result = dp[i]; &#125; return result; &#125; &#125;; 10.32 最长重复子数组给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。 // 想法有点难 // dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。 class Solution &#123; public: int findLength(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2) &#123; if (nums1.size() == 0 || nums2.size() == 0) return 0; vector&lt;vector&lt;int>> dp(nums1.size() + 1, vector&lt;int>(nums2.size() + 1, 0)); int result = 0; for (int i = 1; i &lt;= nums1.size(); i++)&#123; for (int j = 1; j &lt;= nums2.size(); j++)&#123; if (nums1[i -1] == nums2[j-1]) dp[i][j] = dp[i-1][j-1] + 1; if ( dp[i][j] > result ) result = dp[i][j]; &#125; &#125; return result; &#125; &#125;; 10.32 最长公共子序列给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 class Solution &#123; public: int longestCommonSubsequence(string text1, string text2) &#123; if (text1.size() == 0 || text2.size() == 0) return 0; vector&lt;vector&lt;int>> dp(text1.size()+1, vector&lt;int>(text2.size()+1,0)); for (int i = 1; i &lt;= text1.size(); i++)&#123; for (int j = 1; j &lt;= text2.size(); j++)&#123; if (text1[i-1] == text2[j-1]) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = max(dp[i][j-1], dp[i-1][j]); &#125; &#125; return dp[text1.size()][text2.size()]; &#125; &#125;; 10.33 不相交的线在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。 现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足： nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。 以这种方法绘制线条，并返回可以绘制的最大连线数。 // 思路最清晰的一集 class Solution &#123; public: int maxUncrossedLines(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2) &#123; if (nums1.size() == 0 || nums2.size() == 0) return 0; vector&lt;vector&lt;int>> dp(nums1.size() + 1, vector&lt;int>(nums2.size() + 1, 0)); for (int i = 1; i &lt;= nums1.size(); i++)&#123; for (int j = 1; j &lt;= nums2.size(); j++)&#123; if (nums1[i-1] == nums2[j-1])&#123; dp[i][j] = max(dp[i-1][j-1] + 1, max(dp[i-1][j], dp[i][j-1])); &#125; else dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; return dp[nums1.size()][nums2.size()]; &#125; &#125;; 10.34 最大子数组和给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组是数组中的一个连续部分。 // 配合前面的贪心算法食用 class Solution &#123; public: int maxSubArray(vector&lt;int>&amp; nums) &#123; if (nums.size() == 0) return 0; // dp: subarray's maxsum ended by nums[i] vector&lt;int> dp(nums.size(), 0); dp[0] = nums[0]; int result = nums[0]; for (int i = 1; i &lt; nums.size(); i++)&#123; dp[i] = max(dp[i-1] + nums[i], nums[i]); if (dp[i] > result) result = dp[i]; &#125; return result; &#125; &#125;; 10.35 判断子序列给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。 // 按10.33写法可以直接过 class Solution &#123; public: bool isSubsequence(string s, string t) &#123; if (s.size() > t.size() || t.size() == 0 &amp;&amp; s.size()) return false; if (s.size() == 0) return true; vector&lt;vector&lt;int>> dp(s.size() + 1, vector&lt;int>(t.size() + 1, 0)); for (int i = 1; i &lt;= s.size(); i++)&#123; for (int j = 1; j &lt;= t.size(); j++)&#123; if (s[i-1] == t[j-1])&#123; dp[i][j] = max(dp[i-1][j-1] + 1, max(dp[i-1][j], dp[i][j-1])); &#125; else dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; return (dp[s.size()][t.size()] == s.size()); &#125; &#125;; 10.36 不同的子序列给你两个字符串 s 和 t ，统计并返回在 s 的 子序列 中 t 出现的个数。 测试用例保证结果在 32 位有符号整数范围内。 class Solution &#123; public: int numDistinct(string s, string t) &#123; if (s.size() &lt; t.size()) return 0; vector&lt;vector&lt;uint64_t>> dp(s.size()+1, vector&lt;uint64_t>(t.size() + 1,0)); for (int i = 0; i &lt;= s.size(); i++) dp[i][0] = 1; for (int i = 1; i &lt;= s.size(); i++)&#123; for (int j = 1; j &lt;= t.size(); j++)&#123; if (s[i-1] == t[j-1]) dp[i][j] = dp[i-1][j-1] + dp[i-1][j]; else dp[i][j] = dp[i-1][j]; &#125; &#125; return dp[s.size()][t.size()]; &#125; &#125;; 10.37 两个字符串的删除操作给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。 每步 可以删除任意一个字符串中的一个字符。 class Solution &#123; public: int minDistance(string word1, string word2) &#123; vector&lt;vector&lt;int>> dp(word1.size()+1, vector&lt;int>(word2.size()+1,0)); for (int i = 0; i &lt;= word1.size(); i++) dp[i][0] = i; for (int i = 0; i &lt;= word2.size(); i++) dp[0][i] = i; for (int i = 1; i &lt;= word1.size(); i++)&#123; for (int j = 1; j &lt;= word2.size(); j++)&#123; if (word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + 1; &#125; &#125; return dp[word1.size()][word2.size()]; &#125; &#125;; 10.38 编辑距离给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 class Solution &#123; public: int minDistance(string word1, string word2) &#123; vector&lt;vector&lt;int>> dp(word1.size() + 1, vector&lt;int>(word2.size() + 1, 0)); for (int i = 0; i &lt;= word1.size(); i++) dp[i][0] = i; for (int i = 0; i &lt;= word2.size(); i++) dp[0][i] = i; for (int i = 1; i &lt;= word1.size(); i++)&#123; for (int j = 1; j &lt;= word2.size(); j++)&#123; if (word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]; else // 主要要了解替换插入和删除是等价的 dp[i][j] = min(dp[i-1][j-1] + 1, min(dp[i][j-1]+1, dp[i-1][j] + 1)); &#125; &#125; return dp[word1.size()][word2.size()]; &#125; &#125;; 10.39 回文子串给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。 回文字符串 是正着读和倒过来读一样的字符串。 子字符串 是字符串中的由连续字符组成的一个序列。 // 可以两层for循环再reverse判断 // dp写法 这里的递推关系和遍历顺序都比较特殊，dp[i][j] 是s的i~j项能否组成回文子串，需要靠内层判断 class Solution &#123; public: int countSubstrings(string s) &#123; vector&lt;vector&lt;bool>> dp(s.size(), vector&lt;bool>(s.size(), false)); int result = 0; for (int i = s.size() - 1; i >= 0; i--)&#123; for (int j = i; j &lt; s.size(); j++)&#123; if (s[i] == s[j]) &#123; if (j - i &lt;= 1)&#123; dp[i][j] = true; result++; &#125; else&#123; if (dp[i][j] = dp[i+1][j-1] &amp; true)&#123; dp[i][j] = true; result++; &#125; &#125; &#125; &#125; &#125; return result; &#125; &#125;; 10.40 最长回文子序列给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 class Solution &#123; public: int longestPalindromeSubseq(string s) &#123; vector&lt;vector&lt;int>> dp(s.size(), vector&lt;int>(s.size(), 0)); int result = 0; for (int i = s.size() - 1; i >= 0; i--)&#123; for (int j = i; j &lt; s.size(); j++)&#123; if (s[i] == s[j]) &#123; if (j - i == 0)&#123; dp[i][j] += 1; &#125; else dp[i][j] = dp[i+1][j-1] + 2; &#125; else dp[i][j] = max(dp[i+1][j], dp[i][j-1]); &#125; &#125; return dp[0][s.size() - 1]; &#125; &#125;; &nbsp; 11. 单调栈单调栈使用场景：通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置。时间复杂度为O(n)。 11.1 每日温度给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。 // 两层for循环暴力，最后一个用例超时 class Solution &#123; public: vector&lt;int> dailyTemperatures(vector&lt;int>&amp; temperatures) &#123; vector&lt;int> days(temperatures.size(), 0); int size = temperatures.size(); for (int i = 0; i &lt; size; i++)&#123; int value = 1; int flag = 0; // 没遇到更高的为0 for (int j = i + 1; j &lt; size; j++)&#123; if (temperatures[j] &lt;= temperatures[i]) value++; else &#123; flag = 1; break; &#125; &#125; if(flag == 1) days[i] = value; else days[i] = 0; &#125; return days; &#125; &#125;; //单调栈写法，从栈顶到栈底递增 class Solution &#123; public: vector&lt;int> dailyTemperatures(vector&lt;int>&amp; temperatures) &#123; vector&lt;int> days(temperatures.size(), 0); int size = temperatures.size(); stack&lt;int> st; st.push(0); for (int i = 1; i &lt; size; i++)&#123; // 情况一 if (temperatures[i] &lt;= temperatures[st.top()]) st.push(i); // 情况二 else &#123; while (!st.empty() &amp;&amp; temperatures[i] > temperatures[st.top()])&#123; days[st.top()] = i - st.top(); st.pop(); &#125; st.push(i); &#125; &#125; return days; &#125; &#125;; 11.2 下一个最大元素Ⅰnums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。 给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。 对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。 返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。 // 暴力 class Solution &#123; public: vector&lt;int> nextGreaterElement(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2) &#123; vector&lt;int> result(nums1.size(), -1); for (int i = 0; i &lt; nums1.size(); i++)&#123; for (int j = 0; j &lt; nums2.size(); j++)&#123; if (nums2[j] == nums1[i])&#123; for (int k = j + 1; k &lt; nums2.size(); k++)&#123; if (nums2[k] > nums1[i])&#123; result[i] = nums2[k]; break; &#125; &#125; &#125; &#125; &#125; return result; &#125; &#125;; //单调栈 class Solution &#123; public: vector&lt;int> nextGreaterElement(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2) &#123; vector&lt;int> result(nums1.size(), -1); stack&lt;int> st; st.push(0); unordered_map&lt;int, int> value; // &lt;value, index> for (int i = 0; i &lt; nums1.size(); i++)&#123; value[nums1[i]] = i; &#125; for (int i = 0; i &lt; nums2.size(); i++)&#123; if (nums2[i] &lt;= nums2[st.top()]) st.push(i); else &#123; while (!st.empty() &amp;&amp; nums2[i] > nums2[st.top()])&#123; if (value.count(nums2[st.top()]) > 0)&#123; int index = value[nums2[st.top()]]; result[index] = nums2[i]; &#125; st.pop(); &#125; st.push(i); &#125; &#125; return result; &#125; &#125;; 11.3 下一个更大元素Ⅱ给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。 数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。 // 第一次尝试，发现有负数的情况下我的反向遍历会出问题 class Solution &#123; public: vector&lt;int> nextGreaterElements(vector&lt;int>&amp; nums) &#123; vector&lt;int> result(nums.size(), -1); stack&lt;int> st; st.push(0); // 第一次：正向遍历 for (int i = 1; i &lt; nums.size(); i++)&#123; if (nums[i] &lt;= nums[st.top()]) st.push(i); else &#123; while (!st.empty() &amp;&amp; nums[i] > nums[st.top()])&#123; result[st.top()] = nums[i]; st.pop(); &#125; st.push(i); &#125; &#125; // 第二次：反向 for (int i = nums.size() -1; i >= 0; i--)&#123; if (result[i] == -1)&#123; for (int j = 0; j &lt; i; j++)&#123; if (nums[j] > nums[i]) &#123; result[i] = nums[j]; break; &#125; &#125; &#125; &#125; return result; &#125; &#125;; // 拼接成两倍数组就可以了，更精简可以用i % nums.size() class Solution &#123; public: vector&lt;int> nextGreaterElements(vector&lt;int>&amp; nums) &#123; vector&lt;int> result(nums.size(), -1); stack&lt;int> st; st.push(0); for (int i = 1; i &lt; nums.size() * 2; i++)&#123; // 前半段 if (i &lt; nums.size())&#123; if (nums[i] &lt;= nums[st.top()]) st.push(i); else &#123; while (!st.empty() &amp;&amp; nums[i] > nums[st.top()])&#123; result[st.top()] = nums[i]; st.pop(); &#125; st.push(i); &#125; &#125; // 后半段 else&#123; int index = i - nums.size(); if (nums[index] &lt;= nums[st.top()]) st.push(index); else &#123; while (!st.empty() &amp;&amp; nums[index] > nums[st.top()])&#123; result[st.top()] = nums[index]; st.pop(); &#125; st.push(index); &#125; &#125; &#125; return result; &#125; &#125;; 11.4 接雨水给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 class Solution &#123; public: int trap(vector&lt;int>&amp; height) &#123; if (height.size() == 1) return 0; int result = 0; stack&lt;int> st; st.push(0); for (int i = 1; i &lt; height.size(); i++)&#123; if (height[i] &lt; height[st.top()]) st.push(i); else if (height[i] == height[st.top()])&#123; // st.pop()可以不加 st.pop(); st.push(i); &#125; else&#123; while (!st.empty() &amp;&amp; height[i] > height[st.top()])&#123; int mid = height[st.top()]; st.pop(); if (!st.empty())&#123; int w = i - st.top() - 1; int h = min(height[st.top()], height[i]) - mid; result += w * h; &#125; &#125; st.push(i); &#125; &#125; return result; &#125; &#125;; 11.5 柱状图中最大的矩形给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 class Solution &#123; public: int largestRectangleArea(vector&lt;int>&amp; heights) &#123; int result = 0; stack&lt;int> st; st.push(0); // 和接雨水不同，这里开头和结尾都需要补零，开头为了计算开头值，结尾为了防止一直不进循环 heights.insert(heights.begin(), 0); heights.push_back(0); for (int i = 1; i &lt; heights.size(); i++)&#123; if (heights[i] > heights[st.top()]) st.push(i); else if (heights[i] == heights[st.top()]) &#123; st.pop(); st.push(i); &#125; else&#123; while (!st.empty() &amp;&amp; (heights[i] &lt; heights[st.top()]) )&#123; int mid = st.top(); st.pop(); if (!st.empty())&#123; int h = i - st.top() - 1; int w = heights[mid]; result = max(h * w, result); &#125; &#125; st.push(i); &#125; &#125; return result; &#125; &#125;; 12. 图论12.1 理论基础图的种类 有向图 无向图 加权图 度 无向图中有几条边连接该节点，该节点就有几度 有向图中，每个节点有出度和入度，出度是从该节点出发的边的个数， 入度是指向该节点的边的个数 连通性 无向图中，任意两个节点都是可以到达的，可称之为连通图，如果有节点不能到达其他节点，则为非连通图 无向图中的极大连通子图称之为该图的一个连通分量 有向图中，两个节点可以相互到达，则这两个节点为强连通图 有向图中，极大强连通子图称之为该图的强连通分量 图的构造 单维存储 有n条边就定义n*2的数组，或者map或者类，每行存储边两边的节点，由节点0指向节点1 优点：直观，表示节点之间的关系 缺点： 查找时需要遍历 邻接矩阵 使用二维数组来表示图结构。邻接矩阵从节点的角度表示图，有n个节点就定义n*n的二维数组的值表示n指向m的权重 优点： 查找比较快，表达比较简单 缺点： 稀疏图浪费空间 邻接表 使用数组 + 链表的方式来表示，数组大小为节点数，链表大小为边的数量 12.2 深度优先搜索理论基础 dfs：一个方向搜索到底 + 回溯思想 void dfs(参数) &#123; if (终止条件) &#123; 存放结果; return; &#125; for (选择：本节点所连接的其他节点) &#123; 处理节点; dfs(图，选择的节点); // 递归 回溯，撤销处理结果 &#125; &#125; 12.3 广度优先搜索理论基础bfs：一圈一圈地搜索，向外扩展 放置容器选择队列，和二叉树的层序遍历保持一致 对于四方格的模板： int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; // 表示四个方向 // grid 是地图，也就是一个二维数组 // visited标记访问过的节点，不要重复访问 // x,y 表示开始搜索节点的下标 void bfs(vector&lt;vector&lt;char>>&amp; grid, vector&lt;vector&lt;bool>>&amp; visited, int x, int y) &#123; queue&lt;pair&lt;int, int>> que; // 定义队列 que.push(&#123;x, y&#125;); // 起始节点加入队列 visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点 while(!que.empty()) &#123; // 开始遍历队列里的元素 pair&lt;int ,int> cur = que.front(); que.pop(); // 从队列取元素 int curx = cur.first; int cury = cur.second; // 当前节点坐标 for (int i = 0; i &lt; 4; i++) &#123; // 开始想当前节点的四个方向左右上下去遍历 int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标 if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; // 坐标越界了，直接跳过 if (!visited[nextx][nexty]) &#123; // 如果节点没被访问过 que.push(&#123;nextx, nexty&#125;); // 队列添加该节点为下一轮要遍历的节点 visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问 &#125; &#125; &#125; &#125; 12.4 并查集理论基础并查集常用来解决连通性问题。 并查集主要有两个功能： 将两个元素添加到一个集合中。 判断两个元素在不在同一个集合 int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好 vector&lt;int> father = vector&lt;int> (n, 0); // C++里的一种数组结构 // 并查集初始化 void init() &#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; &#125; &#125; // 并查集里寻根的过程 int find(int u) &#123; if (u == father[u]) return u; // 如果根就是自己，直接返回 else return find(father[u]); // 如果根不是自己，就根据数组下标一层一层向下找 &#125; // 并查集里寻根的过程 路径压缩 int find(int u) &#123; if (u == father[u]) return u; else return father[u] = find(father[u]); // 路径压缩 &#125; // 判断 u 和 v是否找到同一个根 bool isSame(int u, int v) &#123; u = find(u); v = find(v); return u == v; &#125; // 将v->u 这条边加入并查集 void join(int u, int v) &#123; u = find(u); // 寻找u的根 v = find(v); // 寻找v的根 if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回 father[v] = u; &#125; 12.5 案例Problem 1 所有可达路径 给定一个有 n 个节点的有向无环图，节点编号从 1 到 n。请编写一个程序，找出并返回所有从节点 1 到节点 n 的路径。每条路径应以节点编号的列表形式表示。 #include &lt;iostream> #include &lt;vector> using namespace std; vector&lt;int> path; vector&lt;vector&lt;int>> result; void dfs(vector&lt;vector&lt;int>> &amp;graph, int x, int n); int main()&#123; int n, m; cin >> n >> m; // store path - array vector&lt;vector&lt;int>> graph(n + 1, vector&lt;int>(n + 1, 0)); while (m--)&#123; int s, t; cin >> s >> t; graph[s][t] = 1; &#125; // pre path.push_back(1); // execute dfs(graph, 1 ,n); // print - delete the last space if (result.size() == 0) cout &lt;&lt; -1 &lt;&lt; endl; for (const vector&lt;int> &amp;pa : result) &#123; for (int i = 0; i &lt; pa.size() - 1; i++) &#123; cout &lt;&lt; pa[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; pa[pa.size() - 1] &lt;&lt; endl; &#125; return 0; &#125; // dfs void dfs(vector&lt;vector&lt;int>> &amp;graph, int x, int n)&#123; if (x == n)&#123; result.push_back(path); return; &#125; for (int i = 1; i &lt;= n; i++)&#123; if (graph[x][i] == 1)&#123; path.push_back(i); dfs(graph, i, n); path.pop_back(); &#125; &#125; &#125; Problem 2 岛屿数量题目描述： 给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。 输入描述： 第一行包含两个整数 N, M，表示矩阵的行数和列数。 后续 N 行，每行包含 M 个数字，数字为 1 或者 0。 输出描述： 输出一个整数，表示岛屿的数量。如果不存在岛屿，则输出 0。 /*dfs*/ #include &lt;iostream> #include &lt;vector> using namespace std; int dir[4][2] = &#123;0,1,1,0,0,-1,-1,0&#125;; void dfs(const vector&lt;vector&lt;int>> &amp;grid, vector&lt;vector&lt;bool>> &amp;visited, int i, int j)&#123; if (grid[i][j] == 0 || visited[i][j] == true) return; visited[i][j] = true; for (int k = 0; k &lt; 4; k++)&#123; int nextx = i; int nexty = j; nextx += dir[k][0]; nexty += dir[k][1]; if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; dfs(grid, visited, nextx, nexty); &#125; &#125; int main()&#123; int n,m; cin >> n >> m; vector&lt;vector&lt;int>> grid(n, vector&lt;int>(m,0)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin >> grid[i][j]; &#125; &#125; int result = 0; vector&lt;vector&lt;bool>> visited(n, vector&lt;bool>(m, false)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (visited[i][j] == false &amp;&amp; grid[i][j] == 1)&#123; result++; dfs(grid, visited, i, j); &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0; &#125; /*bfs*/ #include &lt;iostream> #include &lt;vector> #include &lt;queue> using namespace std; int dir[4][2] = &#123;0,1,1,0,0,-1,-1,0&#125;; void bfs(const vector&lt;vector&lt;int>> &amp;grid, vector&lt;vector&lt;bool>> &amp;visited, int i, int j)&#123; queue &lt;pair&lt;int,int>> que; que.push(&#123;i,j&#125;); visited[i][j] = true; while (!que.empty())&#123; pair&lt;int, int> cur = que.front(); que.pop(); for (int k = 0; k &lt; 4; k++)&#123; int nextx = cur.first; int nexty = cur.second; nextx += dir[k][0]; nexty += dir[k][1]; if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; if (visited[nextx][nexty] == false &amp;&amp; grid[nextx][nexty] == 1)&#123; que.push(&#123;nextx, nexty&#125;); visited[nextx][nexty] = true; &#125; &#125; &#125; &#125; int main()&#123; int n,m; cin >> n >> m; vector&lt;vector&lt;int>> grid(n, vector&lt;int>(m,0)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin >> grid[i][j]; &#125; &#125; int result = 0; vector&lt;vector&lt;bool>> visited(n, vector&lt;bool>(m, false)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (visited[i][j] == false &amp;&amp; grid[i][j] == 1)&#123; result++; bfs(grid, visited, i, j); &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0; &#125; Problem 3 岛屿的最大面积题目描述 给定一个由 1（陆地）和 0（水）组成的矩阵，计算岛屿的最大面积。岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。 输入描述 第一行包含两个整数 N, M，表示矩阵的行数和列数。后续 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。 输出描述 输出一个整数，表示岛屿的最大面积。如果不存在岛屿，则输出 0。 #include &lt;iostream> #include &lt;vector> using namespace std; int dir[4][2] = &#123;0,1,1,0,0,-1,-1,0&#125;; void dfs(const vector&lt;vector&lt;int>> &amp;grid, vector&lt;vector&lt;bool>> &amp;visited, int x, int y, int &amp;area)&#123; if (visited[x][y] || grid[x][y] == 0) return; // 逻辑在加入新节点时考虑，而不是在下面的遍历中考虑 visited[x][y] = true; area ++; for (int i = 0; i &lt; 4; i++)&#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; dfs(grid, visited, nextx, nexty, area); &#125; &#125; int main()&#123; int result = 0; int n, m; int area = 0; cin >> n >> m; vector&lt;vector&lt;int>> grid(n , vector&lt;int>(m, 0)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin >> grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool>> visited(n, vector&lt;bool>(m,false)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (!visited[i][j] &amp;&amp; grid[i][j])&#123; area = 0; dfs(grid,visited,i, j, area); result = max(result, area); &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0; &#125; Problem 4 岛屿的总面积题目描述 给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。 现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。 输入描述 第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0。 输出描述 输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。 /* 1. 把四条边上连接的岛屿都清零 2. 遍历网格 */ #include &lt;iostream> #include &lt;vector> using namespace std; int dir[4][2] = &#123;1,0,0,1,0,-1,-1,0&#125;; void dfs(vector&lt;vector&lt;int>> &amp;grid, vector&lt;vector&lt;bool>> &amp;visited, int x, int y) &#123; if (grid[x][y] == 0 || visited[x][y]) return; visited[x][y] = true; grid[x][y] = 0; for (int k = 0; k &lt; 4; k++)&#123; int nextx = x + dir[k][0]; int nexty = y + dir[k][1]; if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; dfs(grid, visited, nextx, nexty); &#125; &#125; int main()&#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> grid(n , vector&lt;int>(m, 0)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin >> grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool>> visited(n, vector&lt;bool>(m, false)); // 0,n-1行遍历 for (int i = 0; i &lt; m; i++) dfs(grid, visited, 0, i); for (int i = 0; i &lt; m; i++) dfs(grid, visited, n-1, i); // 0,m-1列遍历 for (int i = 0; i &lt; n; i++) dfs(grid, visited, i, 0); for (int i = 0; i &lt; n; i++) dfs(grid, visited, i, m-1); // result int result = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (grid[i][j] == 1) result++; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0; &#125; Problem 5 沉没孤岛题目描述： 给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。 现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。 输入描述： 第一行包含两个整数 N, M，表示矩阵的行数和列数。 之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。 输出描述 输出将孤岛“沉没”之后的岛屿矩阵。 /* 和上一题本质上一样 */ #include &lt;iostream> #include &lt;vector> using namespace std; int dir[4][2] = &#123;1,0,0,1,0,-1,-1,0&#125;; void dfs(vector&lt;vector&lt;int>> &amp;grid, vector&lt;vector&lt;bool>> &amp;visited, int x, int y) &#123; if (grid[x][y] == 0 || visited[x][y]) return; visited[x][y] = true; grid[x][y] += 1; for (int k = 0; k &lt; 4; k++)&#123; int nextx = x + dir[k][0]; int nexty = y + dir[k][1]; if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; dfs(grid, visited, nextx, nexty); &#125; &#125; int main()&#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> grid(n , vector&lt;int>(m, 0)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin >> grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool>> visited(n, vector&lt;bool>(m, false)); // 0,n-1行遍历 for (int i = 0; i &lt; m; i++) dfs(grid, visited, 0, i); for (int i = 0; i &lt; m; i++) dfs(grid, visited, n-1, i); // 0,m-1列遍历 for (int i = 0; i &lt; n; i++) dfs(grid, visited, i, 0); for (int i = 0; i &lt; n; i++) dfs(grid, visited, i, m-1); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (grid[i][j] > 0) grid[i][j] -= 1; cout &lt;&lt; grid[i][j] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125; return 0; &#125; Problem 6 水流问题题目描述： 现有一个 N × M 的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。 矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。 输入描述： 第一行包含两个整数 N 和 M，分别表示矩阵的行数和列数。 后续 N 行，每行包含 M 个整数，表示矩阵中的每个单元格的高度。 输出描述： 输出共有多行，每行输出两个整数，用一个空格隔开，表示可达第一组边界和第二组边界的单元格的坐标，输出顺序任意。 /* 思想：从两个边界出发，反向遍历，两个条件都满足的交叉点即为答案 */ #include &lt;iostream> #include &lt;vector> using namespace std; int dir[4][2] = &#123;1,0,0,1,0,-1,-1,0&#125;; void dfs(vector&lt;vector&lt;int>> &amp;grid, vector&lt;vector&lt;bool>> &amp;visited, int x, int y)&#123; if (visited[x][y] == true) return; visited[x][y] = true; for (int k = 0; k &lt; 4; k++)&#123; int nextx = x + dir[k][0]; int nexty = y + dir[k][1]; if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; if (grid[x][y] > grid[nextx][nexty]) continue; dfs(grid, visited, nextx, nexty); &#125; &#125; int main()&#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> grid(n , vector&lt;int>(m , 0)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin >> grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool>> firstvisited(n, vector&lt;bool>(m, false)); vector&lt;vector&lt;bool>> secondvisited(n, vector&lt;bool>(m, false)); // 边界1 反向遍历 for (int i = 0; i &lt; n; i++) dfs(grid, firstvisited, i, 0); for (int i = 0; i &lt; m; i++) dfs(grid, firstvisited, 0, i); // 边界2 反向遍历 for (int i = 0; i &lt; n; i++) dfs(grid, secondvisited, i, m-1); for (int i = 0; i &lt; m; i++) dfs(grid, secondvisited, n-1, i); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (firstvisited[i][j] &amp;&amp; secondvisited[i][j]) cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl; &#125; &#125; return 0; &#125; Problem 7 建造最大岛屿题目描述： 给定一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。 岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。 输入描述： 第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。 输出描述： 输出一个整数，表示最大的岛屿面积。 #include &lt;iostream> #include &lt;vector> #include &lt;unordered_set> #include &lt;unordered_map> using namespace std; int n, m; int count; int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; void dfs(vector&lt;vector&lt;int>>&amp; grid, vector&lt;vector&lt;bool>>&amp; visited, int x, int y, int mark) &#123; if (visited[x][y] || grid[x][y] == 0) return; visited[x][y] = true; grid[x][y] = mark; // 给陆地标记新标签 count++; for (int i = 0; i &lt; 4; i++) &#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx >= n || nexty &lt; 0 || nexty >= m) continue; dfs(grid, visited, nextx, nexty, mark); &#125; &#125; int main() &#123; cin >> n >> m; vector&lt;vector&lt;int>> grid(n, vector&lt;int>(m, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin >> grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool>> visited(n, vector&lt;bool>(m, false)); // 标记访问过的点 unordered_map&lt;int ,int> gridNum; int mark = 1; // 记录每个岛屿的编号 bool isAllGrid = true; // 标记是否整个地图都是陆地 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (grid[i][j] == 0) isAllGrid = false; if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123; count = 0; dfs(grid, visited, i, j, mark); gridNum[mark] = count; // 记录每一个岛屿的面积 mark++; // 记录下一个岛屿编号 &#125; &#125; &#125; if (isAllGrid) &#123; cout &lt;&lt; n * m &lt;&lt; endl; // 如果都是陆地，返回全面积 return 0; &#125; // 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和 int result = 0; unordered_set&lt;int> visitedGrid; // 标记访问过的岛屿 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; count = 1; // 记录连接之后的岛屿数量 visitedGrid.clear(); // 每次使用时，清空 if (grid[i][j] == 0) &#123; for (int k = 0; k &lt; 4; k++) &#123; int neari = i + dir[k][1]; // 计算相邻坐标 int nearj = j + dir[k][0]; if (neari &lt; 0 || neari >= n || nearj &lt; 0 || nearj >= m) continue; if (visitedGrid.count(grid[neari][nearj])) continue; // 添加过的岛屿不要重复添加 count += gridNum[grid[neari][nearj]]; visitedGrid.insert(grid[neari][nearj]); // 标记该岛屿已经添加过 &#125; &#125; result = max(result, count); &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; &#125; Problem 8 岛屿的周长题目描述 给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。 你可以假设矩阵外均被水包围。在矩阵中恰好拥有一个岛屿，假设组成岛屿的陆地边长都为 1，请计算岛屿的周长。岛屿内部没有水域。 输入描述 第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。 输出描述 输出一个整数，表示岛屿的周长。 /* 有一对相邻的岛屿就会少2条边 */ #include &lt;iostream> #include &lt;vector> using namespace std; int main() &#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> grid(n, vector&lt;int>(m, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin >> grid[i][j]; &#125; &#125; int sum = 0; // 陆地数量 int cover = 0; // 相邻数量 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (grid[i][j] == 1) &#123; sum++; // 统计总的陆地数量 // 统计上边相邻陆地 if(i - 1 >= 0 &amp;&amp; grid[i - 1][j] == 1) cover++; // 统计左边相邻陆地 if(j - 1 >= 0 &amp;&amp; grid[i][j - 1] == 1) cover++; // 为什么没统计下边和右边？ 因为避免重复计算 &#125; &#125; &#125; cout &lt;&lt; sum * 4 - cover * 2 &lt;&lt; endl; &#125; Problem 9 字符串接龙题目描述 字典 strList 中从字符串 beginStr 和 endStr 的转换序列是一个按下述规格形成的序列： 序列中第一个字符串是 beginStr。 序列中最后一个字符串是 endStr。 每次转换只能改变一个位置的字符（例如 ftr 可以转化 fty ，但 ftr 不能转化 frx）。 转换过程中的中间字符串必须是字典 strList 中的字符串。 beginStr 和 endStr 不在 字典 strList 中 字符串中只有小写的26个字母 给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr 到 endStr 的最短转换序列中的字符串数目。如果不存在这样的转换序列，返回 0。 输入描述 第一行包含一个整数 N，表示字典 strList 中的字符串数量。 第二行包含两个字符串，用空格隔开，分别代表 beginStr 和 endStr。 后续 N 行，每行一个字符串，代表 strList 中的字符串。 输出描述 输出一个整数，代表从 beginStr 转换到 endStr 需要的最短转换序列中的字符串数量。如果不存在这样的转换序列，则输出 0。 /* 无权图中，用广搜求最短路径最为合适，广搜只要搜到了终点，就一定是最短路径 */ #include &lt;iostream> #include &lt;vector> #include &lt;queue> #include &lt;string> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; int main()&#123; string beginstr, endstr, str; int n; cin >> n; cin >> beginstr >> endstr; unordered_set&lt;string> strlist; for (int i = 0; i &lt; n; i++)&#123; cin >> str; strlist.insert(str); &#125; // 记录strset里面的字符串是否被访问过，同时记录路径长度 unordered_map&lt;string, int> visitedmap; // init visitedmap.insert(pair&lt;string, int>(beginstr, 1)); queue&lt;string> que; que.push(beginstr); while (!que.empty())&#123; string word = que.front(); que.pop(); int path = visitedmap[word]; for (int i = 0; i &lt; word.size(); i++)&#123; string newword = word; for (int j = 0; j &lt; 26; j++)&#123; newword[i] = j + 'a'; // 字符串集合中有newword, 且newword没有被访问过 if (strlist.find(newword) != strlist.end() &amp;&amp; visitedmap.find(newword) == visitedmap.end()) &#123; visitedmap.insert(pair&lt;string, int>(newword, path + 1)); que.push(newword); &#125; // 最终目标 if (newword == endstr)&#123; path += 1; cout &lt;&lt; path &lt;&lt; endl; return 0; &#125; &#125; &#125; &#125; // 没找到输出0 cout &lt;&lt; 0 &lt;&lt; endl; &#125; Problem 10 有向图的完全连通【题目描述】 给定一个有向图，包含 N 个节点，节点编号分别为 1，2，…，N。现从 1 号节点开始，如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。 【输入描述】 第一行包含两个正整数，表示节点数量 N 和边的数量 K。 后续 K 行，每行两个正整数 s 和 t，表示从 s 节点有一条边单向连接到 t 节点。 【输出描述】 如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。 /* 稀疏图用邻接表做数据结构 */ #include &lt;iostream> #include &lt;vector> #include &lt;list> using namespace std; int n, m; void dfs(const vector&lt;list&lt;int>> &amp;grid, vector&lt;bool> &amp;visited, int x)&#123; if (visited[x] == true) return; visited[x] = true; list&lt;int> keys = grid[x]; for (auto &amp;key : keys)&#123; dfs(grid, visited, key); &#125; &#125; int main()&#123; // input 邻接表 cin >> n >> m; vector&lt;list&lt;int>> grid(n+1); int x, y; for (int i = 0; i &lt; m; i++)&#123; cin >> x >> y; grid[x].push_back(y); &#125; vector&lt;bool> visited(n+1, false); dfs(grid, visited, 1 ); // check 是否都访问到了 for (int i = 1; i &lt;= n; i++) &#123; if (visited[i] == false) &#123; cout &lt;&lt; -1 &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; 1 &lt;&lt; endl; return 0; &#125; Problem 11 寻找存在的路径题目描述 给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。 你的任务是判断是否有一条从节点 source 出发到节点 destination 的路径存在。 输入描述 第一行包含两个正整数 N 和 M，N 代表节点的个数，M 代表边的个数。 后续 M 行，每行两个正整数 s 和 t，代表从节点 s 与节点 t 之间有一条边。 最后一行包含两个正整数，代表起始节点 source 和目标节点 destination。 输出描述 输出一个整数，代表是否存在从节点 source 到节点 destination 的路径。如果存在，输出 1；否则，输出 0。 #include &lt;iostream> #include &lt;vector> using namespace std; int n; // 并查集，比题目限定输入长度大就行 vector&lt;int> father = vector&lt;int>(101, 0); void init(void)&#123; for (int i = 1; i &lt;= n; i++) father[i] = i; &#125; int findfather(int a)&#123; if (a == father[a]) return a; /* father[a] = findfather(father[a]); return father[a]; */ else return father[a] = findfather(father[a]); &#125; bool issame(int a, int b)&#123; a = findfather(a); b = findfather(b); if (a == b) return true; else return false; &#125; void join(int a , int b)&#123; if (issame(a,b)) return; a = findfather(a); b = findfather(b); father[a] = b; &#125; int main()&#123; int m; int source, destination; cin >> n >> m; init(); while (m--)&#123; int x, y; cin >> x >> y; join(x, y); &#125; cin >> source >> destination; if (issame(source, destination) == true) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; endl; return 0; &#125; Problem 12 冗余连接有一个图，它是一棵树，他是拥有 n 个节点（节点编号1到n）和 n - 1 条边的连通无环无向图（其实就是一个线形图），如图： 现在在这棵树上的基础上，添加一条边（依然是n个节点，但有n条边），使这个图变成了有环图，如图 先请你找出冗余边，删除后，使该图可以重新变成一棵树。 输入描述 第一行包含一个整数 N，表示图的节点个数和边的个数。 后续 N 行，每行包含两个整数 s 和 t，表示图中 s 和 t 之间有一条边。 输出描述 输出一条可以删除的边。如果有多个答案，请删除标准输入中最后出现的那条边。 #include &lt;iostream> #include &lt;vector> using namespace std; int n; // 并查集，比题目限定输入长度大就行 vector&lt;int> father = vector&lt;int>(101, 0); void init(void)&#123; for (int i = 1; i &lt;= n; i++) father[i] = i; &#125; int findfather(int a)&#123; if (a == father[a]) return a; /* father[a] = findfather(father[a]); return father[a]; */ else return father[a] = findfather(father[a]); &#125; bool issame(int a, int b)&#123; a = findfather(a); b = findfather(b); if (a == b) return true; else return false; &#125; void join(int a , int b)&#123; if (issame(a,b)) return; a = findfather(a); b = findfather(b); father[a] = b; &#125; int main()&#123; cin >> n; init(); int s, t; while (n --)&#123; cin >> s >> t; if (issame(s, t)) &#123; cout &lt;&lt; s &lt;&lt; \" \" &lt;&lt; t &lt;&lt; endl; return 0; &#125; else &#123; join(s, t); &#125; &#125; &#125; Problem 13 冗余连接Ⅱ题目描述 有一种有向树,该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。有向树拥有 n 个节点和 n - 1 条边。如图： 现在有一个有向图，有向图是在有向树中的两个没有直接链接的节点中间添加一条有向边。如图： 输入一个有向图，该图由一个有着 n 个节点(节点编号 从 1 到 n)，n 条边，请返回一条可以删除的边，使得删除该条边之后该有向图可以被当作一颗有向树。 输入描述 第一行输入一个整数 N，表示有向图中节点和边的个数。 后续 N 行，每行输入两个整数 s 和 t，代表这是 s 节点连接并指向 t 节点的单向边 输出描述 输出一条可以删除的边，若有多条边可以删除，请输出标准输入中最后出现的一条边。 /* 题解，有些难 */ #include &lt;iostream> #include &lt;vector> using namespace std; int n; vector&lt;int> father (1001, 0); // 并查集初始化 void init() &#123; for (int i = 1; i &lt;= n; ++i) &#123; father[i] = i; &#125; &#125; // 并查集里寻根的过程 int find(int u) &#123; return u == father[u] ? u : father[u] = find(father[u]); &#125; // 将v->u 这条边加入并查集 void join(int u, int v) &#123; u = find(u); v = find(v); if (u == v) return ; father[v] = u; &#125; // 判断 u 和 v是否找到同一个根 bool same(int u, int v) &#123; u = find(u); v = find(v); return u == v; &#125; // 在有向图里找到删除的那条边，使其变成树 void getRemoveEdge(const vector&lt;vector&lt;int>>&amp; edges) &#123; init(); // 初始化并查集 for (int i = 0; i &lt; n; i++) &#123; // 遍历所有的边 if (same(edges[i][0], edges[i][1])) &#123; // 构成有向环了，就是要删除的边 cout &lt;&lt; edges[i][0] &lt;&lt; \" \" &lt;&lt; edges[i][1]; return; &#125; else &#123; join(edges[i][0], edges[i][1]); &#125; &#125; &#125; // 删一条边之后判断是不是树 bool isTreeAfterRemoveEdge(const vector&lt;vector&lt;int>>&amp; edges, int deleteEdge) &#123; init(); // 初始化并查集 for (int i = 0; i &lt; n; i++) &#123; if (i == deleteEdge) continue; if (same(edges[i][0], edges[i][1])) &#123; // 构成有向环了，一定不是树 return false; &#125; join(edges[i][0], edges[i][1]); &#125; return true; &#125; int main() &#123; int s, t; vector&lt;vector&lt;int>> edges; cin >> n; vector&lt;int> inDegree(n + 1, 0); // 记录节点入度 for (int i = 0; i &lt; n; i++) &#123; cin >> s >> t; inDegree[t]++; edges.push_back(&#123;s, t&#125;); &#125; vector&lt;int> vec; // 记录入度为2的边（如果有的话就两条边） // 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边 for (int i = n - 1; i >= 0; i--) &#123; if (inDegree[edges[i][1]] == 2) &#123; vec.push_back(i); &#125; &#125; // 情况一、情况二 if (vec.size() > 0) &#123; // 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边 if (isTreeAfterRemoveEdge(edges, vec[0])) &#123; cout &lt;&lt; edges[vec[0]][0] &lt;&lt; \" \" &lt;&lt; edges[vec[0]][1]; &#125; else &#123; cout &lt;&lt; edges[vec[1]][0] &lt;&lt; \" \" &lt;&lt; edges[vec[1]][1]; &#125; return 0; &#125; // 处理情况三 // 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了 getRemoveEdge(edges); &#125; &nbsp; 代码随想录一刷结束了，纪念一下。","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://miustannis.github.io/tags/CS/"}]},{"title":"冈萨雷斯《数字图像处理》Study Log","slug":"250519","date":"2025-05-19T03:38:44.000Z","updated":"2025-07-28T11:40:21.770Z","comments":true,"path":"2025/05/19/250519/","link":"","permalink":"https://miustannis.github.io/2025/05/19/250519/","excerpt":"","text":"目录： Ch0 数字图像的概念 图像分类：模拟图像与数字图像 数字图像处理的基本特点 数字图像处理的基本内容 Ch1 图像技术基础 图像与像素 数字化过程 像素的属性 像素间的基本关系 像素间的距离 印刷品中的半调输出技术 图像坐标变换 图像的质量 图像储存的数据结构 图像文件格式 *光盘读取原理 Ch2 空间域图像增强 灰度映射 图像求反（负片） 幂次变换 动态范围压缩 阶梯量化 灰度切分/阈值切分 位平面切片 图像运算（逐像素进行） 算术运算（一般用于灰度图像） 代数运算 逻辑运算 直方图变换 *直方图均衡化方法： *直方图规定化方法： 镜头边界的检测 图像空间平滑滤波增强 图像中的噪声 邻域平均线性滤波（均值滤波） 中值滤波法 空间域滤波推广 基本低通滤波器设计原则： 微分滤波器模板系数设计 高增益滤波 Ch3 频域图像增强 理论基础 二维卷积 二维离散傅里叶变换 基本性质 DFT的问题 频域图像增强 一般步骤 频域平面与图像空域特性的关系 滤波器 理想低通滤波器的定义 理想低通滤波器的分析 Butterworth低通滤波器 理想高通滤波器及其分析 Butterworth高通滤波器 同形滤波器 空间域滤波和频域滤波之间的关系 Ch4 图像复原与恢复 图像复原的基本概念 图像退化 图像复原 图像退化模型 噪声介绍 图像复原的方法 无约束还原法 反向滤波法 维纳滤波/最小均方误差滤波 有约束还原法 最大平滑复原 运动模糊图像的复原 根据先验知识（退化的原因为已知） 大气湍流造成的传递函数 光学系统散焦的传递函数 匀速直线运动模糊下的传递函数 根据图像中的点或者线估计(后验知识) 由功率谱估计传递函数 噪声的确定 图像的几何校正 空间变换 灰度插值 图像复原的应用 图像复原的空间滤波器（只存在噪声） 自适应局部噪声消除滤波器 自适应中值滤波器 图像复原的频率域滤波器 带通滤波器 带阻滤波器 陷波滤波器 小结 Ch5 彩色图像处理 彩色空间 彩色空间的转换（RGB与其他） 伪彩色图像处理 强度分层技术 全彩色图像处理 彩色变换 彩色图像平滑和尖锐化 Ch6 形态学图像处理 基础知识 二值图像的基本逻辑运算 膨胀与腐蚀 膨胀： 腐蚀 开操作和闭操作 击中或击不中变换 一些基本的形态学算法 边界提取 区域填充 凸壳 细化 粗化 骨架 裁剪等 二值形态学的五个基本结构元素（B） 灰度级形态学 膨胀 &amp; 腐蚀 开操作与闭操作 灰度级形态学处理的一些应用 形态学平滑处理 形态学图像梯度（边缘增强） Top-hat变换 粒度测定 纹理分割 Ch7 图像分割 基础知识 分类： 间断检测 点检测 线检测 边缘检测 梯度算子 拉普拉斯算子 边缘连接 局部处理 轮廓跟踪和图搜索 哈夫变换 阈值分割 全局阈值 基本自适应阈值 通过边界特性选择阈值 聚类分割 区域分割 区域生长法 基于区域灰度差（字面意思） 基于区域内灰度分布统计性质 基于区域形状 分裂合并 基于形态学分水岭的分割 &nbsp; &nbsp; Ch0 数字图像的概念观察系统使用的光波段：可见光、红外、射线、微波、超声波等 视觉在人类获取信息来源中占70% 图：反射光或者透射光的分布，或物体自身发出的能量—客观 像：人的视觉系统对图的接收在大脑中形成的印象或认识—主观 图像处理：是对图像信息进行加工处理，以满足人的视觉心理和实际应用的需求。包括光学和电子学两种方法 图像分类：模拟图像与数字图像 模拟图像：理论上不存在，即使高密度胶片成像也无法称为模拟图像，个人认为可将人眼获得的像近似为模拟图像 数字图像： 由连续的模拟图像通过采样和量化得到。数字图像的基本单位是像素，所以数字图像是像素的集合 数字图像是以像素为元素的矩阵，像素的值代表图像在该位置的亮度/色度，称为图像的灰度值/色度值 数字图像像素具有整数坐标与整数灰度值 数字图像处理的基本特点 信息量大 占用频带宽：电视图像的带宽为5~6MHz（细节越多，画质越高带宽越大，不过现代数字编码技术可以通过压缩方法，比如MPEG-4、H.265等方式大幅减少带宽需求），语音的带宽只有4kHz，频带越宽，技术实现难度就越大 数字图像处理的基本内容（部分内容与图形学互为逆过程） 增强：改善质量 几何处理：平移、缩放、旋转、扭曲 复原重建：去噪、去模糊、重建原始图像 编码压缩：减少存储量和传输量 分割：区域分割和理解、目标表达和描述 理解：图像感知、解释、推理 应用场景：影视图像处理、医学影像处理、刑侦辅助 &nbsp; &nbsp; Ch1 图像技术基础图像与像素图像—二维函数f(x,y)，其中x,y是空间坐标【空间上的离散化，即采样】，f(x,y)是该点的幅值【即量化】 图像类别 特征 黑白图像 二值 灰度图像 单分量，f(x,y)表示亮度 彩色图像 多分量，由3个或多个二维灰度函数f(x,y)组成（如RGB,HSV） 数字化过程 扫描：对一幅图像内给定位置进行寻址，将图像分割为矩形网络，即栅格化，扫描的最小单元为像素 采样：在一幅图像的每个像素位置上测量灰度值，由传感元件将光的亮度转化为电压值 量化：将测量的灰度值用整数来表示（ADC） ${f}_{i j}=\\left[\\begin{array}{cccc} f_{00} & f_{01} & \\cdots & f_{0*(N-1)} \\\\ f_{10} & f_{11} & \\cdots & f_{1*(N-1))} \\\\ \\vdots & \\vdots & \\cdots & \\vdots \\\\ f_{(N-1)*0} & f_{(N-1)*1} & \\cdots & f_{(N-1)*(N-1)} \\end{array}\\right] \\approx f(x, y)$ 像素的属性 大小：与空间分辨率有关，长采样间隔产生低的空间分辨率 灰度：与灰度分辨率有关 位深度：用来存放像素颜色值所用的位数：1/4/8/24（真彩） 灰度级：对应位深度，表示像素明暗程度的整数量，为$2^n$ 像素间的基本关系 neighbor 邻域：4-邻域；D-邻域；8-邻域 adjacency 连接性 ​ 两个像素连接的两个必要条件： 两个像素的位置邻接（按上述neighbor种类可划分为 4-连接、8-连接，以及m-连接） 两个像素的灰度值满足特定的相似性准则（值要在某一范围内近似相等） 特殊情况：*m-连接，包括两种情况（视觉上看不允许有三角阶梯形的连接图案） 4-连接 像素A∈像素B的D-邻域，且两个像素的4-邻域不包含同样值的像素 距离（像素A到像素B的路径，是不同像素的序列）可用定义连接的方法定义路径，其中m-连接所得的m-路径更适用于边缘提取。 connection 像素在图像子集中连通 两个像素在图像中能有一条完全由像素组成的路径，则两个像素连通，连接是连通的一种特殊情况 connected component 连通成分 对于图像中的任意像素A，图像中所有连接到A的像素的集合被称为图像的连通成分，同样可按连接方式划分 像素间的距离 欧几里得距离 p与q之间的欧几里得距离定义为： $De(p,q) = [(x-s)^2 + (y-t)^2]^{(1/2)}$ 对于图像来说计算量太大，一般不用。 D4距离/街区距离/城市距离 $D4(p,q) = |x-s| + |y-t|$ 区别于欧几里得距离（到某像素距离等于某个值的像素形成一个圆形），到某像素D4距离小于等于某个值的像素形成一个菱形 D8距离/棋盘距离：用于边缘提取时设置距离的阈值 $D8(p,q) =max(|x-s| , |y-t|) $ 如下图所示： 印刷品中的半调输出技术 节选自维基百科：半色调（Halftone）是指为了模拟出连续调影像（色阶）的视觉感觉，一般用墨点（半色调网点）的大小或频率的改变，来模拟明暗的变化。半色调技术是传统印刷中用来处理阶调并模拟连续调（continue tone）的方法，通常也称为过网（screening）技术。半色调是相对于连续调表示阶调的一种方法，一般我们所看到银盐相片上的影像是由连续的层次所构成，像这样的影像称之为连续调影像。相对而言，印刷机或打印机上所打印的图像，只能借由着墨或不着墨两种阶调来表现层次，像这样的两值化影像称为半色调影像。只要借由调整不同形式、不同大小的墨点，利用人眼可以将图像中邻近墨点进行视觉积分的原理，在一定的距离观察下，便可以使二值化影像重现连续调的感觉。也就是说，当这些墨点越小时，二值化影像就可以在越短的观测距离下，被人眼观测积分成近似连续调的影像。 图像坐标变换可借助矩阵写为 $\\boldsymbol{v}^{\\prime}=\\boldsymbol{A} \\boldsymbol{v}$ 其中A为变换矩阵，v‘为变换后的坐标矢量，v为变换前的坐标矢量 平移变换 $\\boldsymbol{T}=\\left[\\begin{array}{ccc} 1 & 0 & x_{0} \\\\ 0 & 1 & y_{0} \\\\ 0 & 0 & 1 \\end{array}\\right]$ 尺度变换 $\\boldsymbol{S}=\\left[\\begin{array}{ccc} S_{x} & 0 & 0 \\\\ 0 & S_{y} & 0 \\\\ 0 & 0 & 1 \\end{array}\\right]$ 旋转变换 $\\boldsymbol{R}=\\left[\\begin{array}{ccc} \\cos \\gamma & \\sin \\gamma & 0 \\\\ -\\sin \\gamma & \\cos \\gamma & 0 \\\\ 0 & 0 & 1 \\end{array}\\right]$ 图像的质量清晰度：亮度，对比度，主题内容的大小，细微层次，颜色饱和度 对比度 = 最大亮度 / 最小亮度 图像储存的数据结构 一维数组，行列储存 多波段储存 图像文件格式BMP, GIF, TIFF, JPEG等 &nbsp; &nbsp; *光盘读取原理无论是CD光盘还是DVD光盘，其存储方式与磁盘一样，都是以二进制数据的形式来存储信息。要在这些光盘上存储数据，需要借助激光把二进制数据刻在扁平、具有反射能力的盘片上。为了识别数据，定义激光刻出的小坑就代表二进制的“1”，而空白处则代表二进制的“0”。（凹坑和平坦区域的 边缘变化【如从凹坑到平坦，或反之】代表”1”，无变化代表”0”）DVD的记录凹坑比CD小，且螺旋存储凹坑之间的距离也更小。 CD光驱或DVD光驱的主要部分就是激光发生器和光监测器。激光发生器（激光二极管），可以产生对应波长的激光光束，然后经过一系列的处理后照到光盘上。经由光监测器捕捉反射信号而识别实际的数据。然后计算机将这些二进制代码转换成为原来的数据或程序。当光盘在光驱中作高速旋转，激光头在电机的控制下作径向移动，数据就这样源源不断地读取出来。 根据数据密度的差别可分为CD, DVD, BD等。 光盘与机械硬盘的工作原理区别可见以下博客： https://zhuanlan.zhihu.com/p/51572176 &nbsp; &nbsp; &nbsp; Ch2 空间域图像增强定义：直接作用于像素的增强方法，根据具体操作是在像素点位置上还是像素点的邻域上可分为点操作和模板操作（邻域操作） 灰度映射通过映射函数:$ t= T(s)$（可根据增强的目的来设计映射函数）将原始图像中的每个像素的灰度都映射到新的灰度。 图像求反（负片）一一对应 幂次变换$t= cs^{γ}$ $γ&lt;1$时在正比函数上方，使得图像变亮，把输入窄带暗值映射到宽带输出； $γ&gt;1$时在正比函数下方，使得图像变暗，把输入窄带亮值映射到宽带输出。 动态范围压缩由于某些设备的局限性，采用动态范围压缩，目标与增强图片的对比度相反（同等范围的原始灰度级数变换后范围变化减小） 阶梯量化将图像灰度分范围量化，变成数据量较少的级数，获得数据量压缩的效果（有点像素化风格） 灰度切分/阈值切分只留下两个灰度值，获得最大的对比度以及最少的细节 *分段变换： 位平面切片以256灰度级图像为例，该图像的灰度级可以用8位表示。可假设图像是由8个1位平面组成，即位平面0~7，其中位平面0包含图像中像素的最低位，位平面7包含像素的最高位。 较高位(前4位)包含大多数视觉重要数据。较低位(后4位)包含对微小细节重要的数据，位平面切片可以分析每一位在图像中的相对重要性。 &nbsp; 图像运算（逐像素进行）算术运算（一般用于灰度图像）代数运算加法：$C(x,y) = A(x,y) + B(x,y)$ 应用场景：1. 去除叠加性噪声（图像均值化将降低噪声的影响）2. 生成图像叠加效果 减法：$C(x,y) = A(x,y) - B(x,y)$ 应用场景：1. 显示两幅图之间的差异，如视频中的镜头边界的检测 2. 去除不需要的叠加性图案（gb\\bb剪辑） 3. 图像分割 乘法：$C(x,y) = A(x,y) * B(x,y)$ 应用场景：局部显示——用二值蒙版图像与原图像做乘法 逻辑运算与、或、异或、非 部分运算方法与加减法有类似的地方 非：$g(x,y) = 255 - f(x,y)$ 可获得一个负片图像（补图像） *负片： 灰度图像公式如上；RGB图像需要分别进行非运算；非线性色域需要先进行线性校正后再对不同通道分别校正 与：$g(x,y) = h(x,y) ∧ f(x,y)$ ；或：$g(x,y) = h(x,y) Ｖ f(x,y)$ 可以提取相交子图或合并子图像 &nbsp; 直方图变换灰度直方图是关于灰度级的离散函数，描述图像中各灰度级的像素个数，一般归一化后描述 直方图只能反映图像的灰度分布情况，不能反映图像像素的位置 一幅图对应唯一的灰度直方图 *高对比度的图像有更平坦的直方图，对于图像分割，识别领域，一幅图像应该利用全部或者几乎全部可能的灰度级 应用： 利用直方图分布进行阈值分割，如果某灰度图像的灰度直方图有两个明显的尖峰，取两个尖峰之间的谷点作为分割点，可以得到较好的二值处理的效果 直方图均衡化，通过将像素个数多的灰度级进行展宽，对像素个数少的灰度级进行缩减，将原始图像的直方图变为均衡分布的形式，由于各灰度之间有均匀的概率分布，图像看起来可以更清晰 *直方图均衡化方法： 为使得图像的直方图均衡化，同时保持灰度值的单调性和范围不变，构造的灰度变换函数$ t= T(s)$需要满足以下两个条件： $T(s)$是单调递增函数，且$0≤T(s)≤1$：保证变换后的灰度值保持从黑到白的变换顺序，避免灰度值反转，保证变换后的灰度值在0~1的范围内（归一化后） 原始图像的累积分布函数(CDF，即概率密度曲线包围的面积)可满足以上条件 $t = T(s) = \\int_{0}^{s}p(w)dw, p(w)是概率值$ $T^{-1}(s)$存在且单调递增，允许均衡化后的灰度值t反向映射回原始灰度值，反函数单调递增可以保证反向映射时仍然保持灰度顺序不变，避免引入新的非线性失真 $T(s)$是CDF，其反函数可以通过查找或者数值方式求得 因为数字图像处理是离散化的，因此需要对上述方法离散化： 设一幅图像的像素总数为n，分L个灰度级，其中第k个灰度级出现的概率为$p(s_{k}) = n_{k}/n$，其中$0≤s_k≤1,k = 0,1,2,…L-1$. 变换函数，即离散CDF为$T(s_k) = \\sum_{j=0}^{k} p(s_{k}) = \\sum_{j=0}^{k} n_j/n$ 算法步骤： 计算每个灰度级的像素个数在整个图像中所占的概率 计算每个灰度级的离散CDF 根据变换后的$t_{k}$的值判断变换后的灰度级（区间拟合，比如round()） 拟合后会合并部分灰度级，宏观上对灰度级分布均衡化，微观上不可能拉平，灰度级层次减少，对比度提高 这种方法使得原本集中在狭窄区间的像素值变换到更广的范围内，增加了像素灰度值的有效动态范围 优点：自动得到近似均匀分布的直方图，但由于变换函数采用CDF，只能近似，因此在一些有特定需求的场景下采用直方图规定化方法 &nbsp; *直方图规定化方法：将原始直方图转换为期望直方图 算法步骤： 对原始图像进行灰度均衡化（按照上述直方图均衡化方法） 计算目标直方图的离散CDF 将原始直方图映射到目标直方图 映射规则： 单映射规则（灰度级一一对应） &amp; 组映射规则（灰度级分组后平均后对应，效果好） &nbsp; 镜头边界的检测定义：一个镜头指一系列连续记录的图像帧，用于表示一个时间段或者相同地点连续的动作 镜头边界的检测即检测由镜头切换而产生的关键帧 方法： 两幅图图像相减（检测像素变化的数目是否超过阈值）可通过滤波降低对摄像机运动敏感的问题影响 连续帧的直方图相减（统计相邻两帧中所有像素在不同灰度上的分布差异之和是否超过阈值）对目标的空间变化不敏感 时空切片分析（颜色和纹理的不连续） &nbsp; 图像空间平滑滤波增强图像中的噪声引起原因：敏感元器件的内部噪声，传输通道的干扰以及量化噪声 噪声分类： 加性噪声：与图像信号无关。信道噪声、扫描时产生的噪声 乘性噪声：某像素处的噪声只与该像素处的图像信号有关（或者与其邻域信号也有关） 根据噪声的分布特性可以分为：椒盐噪声（泊松噪声）、高斯噪声、颗粒噪声等 邻域平均线性滤波（均值滤波） 思想：将一个像素及其邻域内的所有像素的平均灰度值赋给平滑图像中对应的像素，从而达到平滑的目的 常用的邻域有4-邻域和8-邻域 作用：减噪，去除不相干的细节，对灰度级不足引起的伪轮廓进行平滑 example：非加权3*3邻域均值滤波器模板 $H_{0}=\\frac{1}{9}\\left[\\begin{array}{ccc} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{array}\\right]$ 加权3*3均值滤波器模板 $H_{0}=\\frac{1}{10}\\left[\\begin{array}{ccc} 1 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 1 \\end{array}\\right]$ 中心像素为待处理像素 那么可知道，当像素处于图像边缘时，这个滤波器有一部分是没有值对应的，此时有两种方法进行补充： 镜像反射 补0 邻域平均法算法步骤： 确定mask大小 对待处理的图像边缘进行扩充 将mask在图像中游走，计算平均 用均值代替中心像素值 *模板越大，对图像的模糊作用就越强，但也可以在提取较大目标之前先去除太小的细节或噪声 *加权邻域平均可以一定程度上缓解非加权滤波导致的边缘模糊的问题，其中心元素占的比例越小，越平滑，图像越模糊 &nbsp; 中值滤波法虽然邻域平均法可以平滑图像，但在消除噪声的同时，会使得图像中的一些细节变得模糊。中值滤波则在消除噪声的同时还能保持图像中的细节部分。 思想：对模板内的像素进行大小顺序排列，如此最亮的和最暗的点会排在两侧，用中间位置像素值代替原灰度值 作用：消除噪声，保留图像细节，防止边缘模糊。对脉冲噪声和椒盐噪声的抑制效果好 中值滤波算法步骤： 确定mask大小与形状 对待处理的图像边缘进行扩充 将mask在图像中游走，对模板内像素值进行排序 用中间值代替中心像素值 mask形状一般有方形与十字形 注： 有尖顶角几何结构的图像，一般采用十字窗，大小不超过最小有效物体的尺寸 有较多的点、线细节的结构，一般不用中值滤波 由中值滤波推广到统计排序滤波器：最大值滤波器（寻找最亮点）&amp; 最小值滤波器（寻找最暗点） &nbsp; 空间域滤波推广 钝化滤波器-平滑滤波器：低通滤波 &amp; 中值滤波 锐化滤波器：高通滤波 &amp; 微分滤波 &amp; 高增益滤波 基本低通滤波器设计原则：如同邻域平均法，模板系数需大于0，都选1或者中间选1，周围选0.5 图像锐化： 补偿图像的轮廓，突出图像中物体的边缘或细节，使得图像更为清晰 思想：图像模糊的原因——图像被平均或积分，因此为实现图像的锐化，需要进行反运算“微分”——&gt;以此增强高频分量，使图像边缘变得清晰，但同时也增强了噪声 条件：原始图像信噪比质量要高 边缘检测原理：图像中物体边缘是灰度值发生突变的地方，常用差分或者梯度计算来检测边缘 基本高通滤波设计原则： 1)系数中心为正值，外周为负值 2)滤波器各系数之和为0 注： 计算时会出现负值，常用归0处理 像素值相同或者变化平缓的区域，结果为0或者很小，图像亮度降低 微分滤波器 引入微分算子的概念 已知：一阶偏导数没有各向同性 $\\frac{\\partial f}{\\partial x} ≠ \\frac{\\partial f}{\\partial y}$ 而数学上可以证明：偏导数的平方和是各向同性的，因此梯度运算、拉普拉斯运算都符合与方向无关性。即：无论边界是什么走向，只要幅度相同，算子的输出就相同。 梯度法： $G[f(x,y)] = [\\frac{\\partial f}{\\partial x} \\frac{\\partial f}{\\partial y}]^{T}$ 梯度的方向是$f(x,y)$变化率最大的方向 梯度的偏导数可以用该处偏导数的平方和开根号表示。 对于数字图像，显然是要用差分来代替微分的 同时用绝对值来近似平方和的表达 如上图所示两种方法，第一种是用4-邻域进行近似，第二种是交叉差(Roberts梯度法) 微分滤波器模板系数设计 Roberts交叉梯度算子 $H_{0}=\\left[\\begin{array}{ccc} 1 & 0 \\\\ 0 & -1 \\end{array}\\right], H_{1}=\\left[\\begin{array}{ccc} 0 & 1 \\\\ -1 & 0 \\end{array}\\right]$ Prewitt梯度算子 $H_{0}=\\left[\\begin{array}{ccc} -1 & -1 & -1 \\\\ 0 & 0 & 0 \\\\ 1 & 1 & 1 \\end{array}\\right], H_{1}=\\left[\\begin{array}{ccc} -1 & 0 & 1 \\\\ -1 & 0 & 1 \\\\ -1 & 0 & 1 \\end{array}\\right]$ Sobel梯度算子：有一定的平滑作用 $H_{0}=\\left[\\begin{array}{ccc} -1 & -2 & -1 \\\\ 0 & 0 & 0 \\\\ 1 & 2 & 1 \\end{array}\\right], H_{1}=\\left[\\begin{array}{ccc} -1 & 0 & 1 \\\\ -2 & 0 & 2 \\\\ -1 & 0 & 1 \\end{array}\\right]$ Scharr梯度算子：更加精确 $H_{0}=\\left[\\begin{array}{ccc} -3 & -10 & -3 \\\\ 0 & 0 & 0 \\\\ 3 & 10 & 3 \\end{array}\\right], H_{1}=\\left[\\begin{array}{ccc} -3 & 0 & 3 \\\\ -10 & 0 & 10 \\\\ -3 & 0 & 3 \\end{array}\\right]$ 所有锐化算子的系数之和为0 拉普拉斯算子：求二阶微分，适用于改善因为光线的漫反射造成的图像模糊 应用 经过梯度算子计算后的值： 若梯度大于25，则给原像素赋最大值255，否则赋原值——边增强且背景保留 若梯度大于25，则给原像素赋最大值255，否则赋0——边增强且图像二值化 &nbsp; 高增益滤波思想：弥补高通滤波的缺陷，在增强边缘和细节的同时，不丢失原图像的低频成分，即增加一部分原图像到高通之中，算子可在高通基础上增益 高通 = 原图 - 低通 高增益 = A原图 - 低通 &nbsp; &nbsp; &nbsp; Ch3 频域图像增强理论基础空间域图像变换到频域的具体实现——图像离散傅里叶变换与反变换 频域图像的表达特点——经过中心变换后，低频位于中心，高频在外 空间频率的定义：图像灰度值随空间坐标变化的快慢也可以用频率来度量，称为空间频率 二维卷积对于二维平面函数，二维卷积定义： $ h(x, y)=f^{*} g=\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} f(u, v) g(x-u, y-v) d u d v $ *注： 深度学习中，CNN中的卷积其实是“互相关运算”，即kernel不翻转，与上面的二维卷积定义无法完全对应。 在数字图像中，需要离散化，离散二维卷积： $ h(x, y)=f^{*} g=\\sum_{m} \\sum_{n} f(m, n) g(x-m, y-n) $ 二维离散傅里叶变换\\begin{array}{l}F(u, v)=\\frac{1}{M N} \\sum_{x=0}^{M-1} \\sum_{y=0}^{N-1} f(x, y) \\mathrm{e}^{[-\\mathrm{j} 2 \\pi(u x / M+v y / N)]} \\\\f(x, y)=\\sum_{u=0}^{M-1} \\sum_{v=0}^{N-1} F(u, v) \\mathrm{e}^{[\\mathrm{j} 2 \\pi(u x / M+v y / N)]}\\end{array} M，N表示图像在x，y方向上的大小 基本性质 可分离性：可以将二维DFT转换成一维计算，先做一个方向上的： \\begin{aligned}F(u, v) &amp; =\\frac{1}{N^{2}} \\sum_{x=0}^{N-1} \\mathrm{e}^{-\\mathrm{j} 2 \\pi u x / N} \\bullet \\sum_{y=0}^{N-1} f(x, y) \\mathrm{e}^{-\\mathrm{j} 2 \\pi v y / N} \\\\f(x, y) &amp; =\\sum_{u=0}^{N-1} \\mathrm{e}^{-\\mathrm{j} 2 \\pi u x / N} \\bullet \\sum_{v=0}^{N-1} F(u, v) \\mathrm{e}^{-\\mathrm{j} 2 \\pi v y / N}\\end{aligned} 再做第二个方向上的： \\begin{array}{l}F(u, v)=F_{x}\\left\\{F_{y}[f(x, y)]\\right\\}=F_{y}\\left\\{F_{x}[f(x, y)]\\right\\} \\\\f(x, y)=F_{u}^{-1}\\left\\{F_{v}^{-1}[F(u, v)]\\right\\}=F_{v}^{-1}\\left\\{F_{u}^{-1}[F(u, v)]\\right\\} \\\\F(u, v)=\\frac{1}{N} \\sum_{x=0}^{N-1} F(x, v) \\mathrm{e}^{-\\mathrm{j} 2 \\pi u x / N} \\\\\\text { 其中: } F(x, v)=N\\left[\\frac{1}{N} \\sum_{y=0}^{N-1} f(x, y) \\mathrm{e}^{-\\mathrm{j} 2 \\pi v x / N}\\right]\\end{array} 平移性——&gt;图像中心化 \\begin{aligned}f(x, y) e^{j 2 \\pi\\left(\\frac{u_{0} x}{M}+\\frac{v_{0} y}{N}\\right)} &amp; \\Leftrightarrow F\\left(u-u_{0}, v-v_{0}\\right) \\\\f\\left(x-x_{0}, y-y_{0}\\right) &amp; \\Leftrightarrow F(u, v) e^{-j 2 \\pi\\left(\\frac{u x_{0}}{M}+\\frac{v y_{0}}{N}\\right)}\\end{aligned} 第一个公式表明，将f(x,y)与一个指数项相乘就相当于把其变换后的频域中心移动到新的位置。 第二个公式表明，将F(u,v)与一个指数项相乘，相当于把其变换后的空间域中心移动到新的位置。 同时可以看出，对f(x,y)的平移不会影响其傅里叶变换的幅值，将u0 = M/2 和 v0 = N/2代入公式，指数部分就变成：$e^{j 2 \\pi\\left(\\frac{u_{0} x}{M}+\\frac{\\nu_{0} y}{N}\\right)}=e^{j \\pi(x+y)}=(-1)^{(x+y)} $ 代入上面的公式有： \\begin{array}{ll}f(x, y)(-1)^{(x+y)} &amp; \\Leftrightarrow F(u-M / 2, v-N / 2) \\\\f(x-M / 2, y-N / 2) &amp; \\Leftrightarrow F(u, v)(-1)^{(u+v)}\\end{array} 因此有结论，对数字图像的每一个像素点的取值直接乘上$(-1)^{x+y}$，之后在做傅里叶变换，可以得到中心化后的频域图。这和在频域移动M/2和N/2是一样的效果。 周期性：DFT和他的逆变换是以M，N为周期的 共轭对称性 旋转不变性 加法有分配性，乘法有比例性 平均值：将$u = v = 0$代入二维DFT公式，可得原图像均值就是该DFT在$(0,0)$处的值 DFT的问题计算量大，收敛慢 引入FFT：对于任何N = 2m的DFT，通过计算两个N/2的DFT，来计算N的DFT 有按位倒序排列等方法 小结：二维离散傅里叶变换在图像处理中是一个比较基本的数学工具，利用这个工具，可以对图像的频谱进行各种各样的处理，比如滤波、降噪、增强等。 除离散傅里叶变换之外，还有沃尔什和哈达玛变换这两种重要的正交变换，他们将信号从时域或者空间域转换到一种由二进制函数(如矩形波)构成的频域，类似于傅里叶变换，但计算更加高效(只涉及加减运算，无需复数运算) &nbsp; 频域图像增强有了二维离散傅里叶变换的基础，下面可以考虑具体的应用了 一般步骤有被处理图像f(x,y)， 变换函数h(x,y)，以及最终的目标图像g(x,y) 首先对上述原始图像进行线性位置操作，比如利用DFT的平移性质进行图像中心化 然后根据自己的需求确定变换函数 空间域的卷积等于频域的乘积 $g(x,y) = h(x,y)* f(x,y),G(u,v) = H(u,v)F(u,v)$ 最后对目标图像的傅里叶变换进行傅里叶反变换(也利用平移性质，具体可见上一小节的公式)，即可得到目标图像的空间域信号 频域平面与图像空域特性的关系 图像变化平缓的部分(低频区域)靠近频率平面的圆心 图像中边界，噪声，变化陡峭的部分，以放射方向离开频率平面的圆心，称为高频区域 滤波器理想低通滤波器的定义 $H(u, v)=\\left\\{\\begin{array}{ll} 1 & \\operatorname{,D}(u, v) \\leq D_{0} \\\\ 0 & \\operatorname{,D}(u, v)>D_{0} \\end{array}\\right.$ 其中，D0为截止频率在频率平面内到原点的距离，D(u,v)为距离函数$D(u,v) = (u^2+v^2)^{\\frac{1}{2}}$不过因为是在频域，说是距离有些问题，应该可以把这个说成是水平空间频率u和垂直空间频率v组成的向量的模 理想低通滤波器的分析 整个能量的90%都被一个很小的小圆周包含，大部分尖锐的细节信息都存在于被去掉的10%的能量中 被钝化的图像有一种非常严重的振铃效果 Butterworth低通滤波器定义：一个截止频率在与原点距离为D0的n阶butterworth滤波器的变换函数如下： $H(u, v)=\\frac{1}{1+\\left[D(u, v) / D_{0}\\right]^{2 n}}$ 其中，D0为截止频率在频率平面内到原点的距离，D(u,v)为距离函数$D(u,v) = (u^2+v^2)^{\\frac{1}{2}}$ 与理想低通滤波器的区别是，巴特沃斯低通滤波器在通带与被滤除的频率之间没有明显的截断，可以缓解振铃效果 在某些文献中，巴特沃斯滤波器的传递函数可能是指数形式，例如： $H(u, v)=e^{-\\left(\\frac{D(u, v)}{D_{0}}\\right)^{2 n}}$ 这是因为在x较大时，两种传递函数的主体部分衰减的趋势相似，且指数形式在某些情况下计算更为方便。 这时可以把巴特沃斯滤波器看作高斯滤波器的一种推广。 理想高通滤波器及其分析可根据低通滤波器特性类比 Butterworth高通滤波器 $H(u, v)=\\frac{1}{1+\\left[{D}_{0} / {D}({u}, {v})\\right]^{2 n}}$ Butterworth高通滤波器的分析 低频成分被严重地削弱，使图像失去层次 改进措施： 加一个常数项到变换函数中 为解决变暗地趋势，在变换后地图像上再进行一次直方图均衡化（后滤波处理） 同形滤波器消除图像上照明不均的问题，增加暗区的图像细节，同时又不损失亮区的图像细节，它在频域中同时将亮度范围进行压缩，且将图像对比度进行增强 首先，一个图像也可以用其亮度和反射分量的乘积来表示： $f(x,y) = i(x,y)r(x,y)$ 同形滤波器针对上面两个分量，同时进行滤波处理，但因为两个函数乘积的傅里叶变换是不可以分离的，所以采用取对数ln来操作 个人认为可以理解同形滤波器是一定程度上的图像带通滤波 空间域滤波和频域滤波之间的关系 频域低通滤波器越窄，滤除的低频成分就越多，图像越模糊；在空间域，这意味着低通滤波器越宽，模板越大 频域可以凭借直观指定滤波器 空间域滤波器效果取决于空间模板的大小 &nbsp; &nbsp; &nbsp; Ch4 图像复原与恢复图像复原的基本概念图像退化定义：图像的质量下降叫做退化 形式：模糊、失真、有噪声等 原因：无论是由光学、光电或者电子方法获得的图像，均会有不同程度的退化。比如传感器噪声，物体与摄像设备之间的相对移动等 在图像采集过程中产生的许多退化常称为模糊，在图像记录过程中产生的退化常称为噪声 如果对退化的类型、机制和过程都十分清楚，就可以利用其反过程来复原图像 图像复原对降质了的图像恢复成原来的图像。具体方法：针对引起图像退化的原因，以及降质过程的某先验知识，建立起退化模型，再针对降质过程采取相反的方向，恢复图像。本质上是一种逆过程。 一般来讲，复原的好坏有一个规定的客观标准，以便对复原的结果作出某种最佳的评估。 &nbsp; 图像退化模型退化过程可以看作对原图像作线性运算 $ g(x,y) = H f(x,y) + n(x,y)$ 其中H是退化模型，n(x,y)是噪声，退化模型被建模为一个退化函数和一个加性噪声项 在后续的讨论中，对退化模型H作出以下的假设： H是线性的 H是空间（或位移）不变的 在这里先省略噪声项，可将一幅图像看作是由一系列冲激函数组成的，利用冲激函数的偶函数性质与抽样性质：$\\int_{-\\infty}^{+\\infty} f(t) \\delta\\left(t-t_{0}\\right) d t=f\\left(t_{0}\\right)$，可推广到二维空间：$f(x, y)=\\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(\\alpha, \\beta) \\delta(x-\\alpha, y-\\beta) \\mathrm{d} \\alpha \\mathrm{~d} \\beta$，则有$g(x, y)=H \\cdot \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(\\alpha, \\beta) \\delta(x-\\alpha, y-\\beta) \\mathrm{d} \\alpha \\mathrm{~d} \\beta$ 由模型H的两个假设性质可得： H是线性的：$g(x,y) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty}H f(\\alpha, \\beta) \\delta(x-\\alpha, y-\\beta) \\mathrm{d} \\alpha \\mathrm{~d} \\beta$ H是空间位移不变的： $g(x,y) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty}f(\\alpha, \\beta) H \\delta(x-\\alpha, y-\\beta) \\mathrm{d} \\alpha \\mathrm{~d} \\beta$ $= \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty}f(\\alpha, \\beta) h(x-\\alpha, y-\\beta) \\mathrm{d} \\alpha \\mathrm{~d} \\beta$ 称$h(x,\\alpha;y,\\beta)$为扩散函数(PSF)或者系统冲激响应 在光学中冲激为一个光点，退化可以理解为系统冲激响应造成的图像的降质 上述公式符合二维卷积的定义，有： $g(x,y) = f(x,y)* h(x,y)$ 如果H是一个可分离系统，即$h(x,\\alpha;y,\\beta) = h_1(x,\\alpha)h_2(y,\\beta)$，则二维运算可以分解为列和行两次一维运算来代替 此时在加上噪声： $g(x,y) = f(x,y)+h(x,y) + n(x,y)$ 结论：一个线性系统完全可以由它的点扩散函数PSF来表征。若系统的点扩散函数已知，则系统在(x,y)处的输出响应可以看成是不同坐标$(\\alpha,\\beta)$处输入函数$f(\\alpha,\\beta)$所产生的脉冲响应在$(x,y)$处的叠加。 恢复方法： 空间域中的卷积等于频域中的乘积，频域表示为 $G(u,v) = H(u,v)F(u,v)+N(u,v)$ 若略去噪音，有$F(u,v) = \\frac{G(u,v)}{H(u,v)}$ 对上式进行傅里叶反变换，可以求得空间域恢复图像 *在数字图像中，需要对上述所有内容进行离散化处理 &nbsp; 噪声介绍噪声概率密度函数 高斯噪声 $p(z)=\\frac{1}{\\sqrt{2 \\pi} \\sigma} \\exp \\left[-\\frac{(z-\\mu)^{2}}{2 \\sigma^{2}}\\right]$ 均匀噪声 $p(z)=\\left\\{\\begin{array}{ll} 1 /(b-a) & \\text { 如果 } \\quad a \\leqslant z \\leqslant b \\\\ 0 & \\text { 其他 } \\end{array}\\right.$ 椒盐噪声（脉冲噪声） $ p(z)=\\left\\{\\begin{array}{lll} P_{a} & \\text { 如果 } & z=a \\\\ P_{b} & \\text { 如果 } & z=b \\\\ 0 & \\text { 其他 } & \\end{array}\\right. $ 高斯噪声源于电子电路噪声和由低照明度或高温带来的传感器噪声 瑞利噪声对分布再图像范围内特征化噪声有用 gamma分布和指数分布用于激光成像的噪声 均匀密度分布作为模拟随机数产生器的基础 脉冲噪声用于成像中的短暂停留中，比如错误的开关操作 &nbsp; 图像复原的方法无约束还原法反向滤波法有退化模型：$g(x,y) = h(x,y)*f(x,y)+n(x,y)$ 无约束的反向滤波法过程如下： $ \\begin{array}{l} \\hat{f}(x, y)=g(x, y)^{*} h_{I}(x, y)=\\left[h(x, y)^{*} f(x, y)+n(x, y)\\right]^{*} h_{I}(x, y) \\\\ \\hat{F}(u, v)=[H(u, v) F(u, v)+N(u, v)] H_{I}(u, v) \\\\ \\text { 设: } \\quad H_{I}(u, v)=\\frac{1}{H(u, v)} \\Rightarrow \\hat{F}(u, v)=F(u, v)+\\frac{N(u, v)}{H(u, v)} \\end{array}$ 当$H(u,v)$为0或者很小时，复原图像的傅里叶变换趋近于正无穷，噪声完全淹没图像 解决退化函数为0或者非常小的方法：限制滤波的频率，使其接近原点 维纳滤波/最小均方误差滤波维纳滤波恢复正是在假定图像信号可以近似看作平稳随机过程的前提下，按照使原图像$f(x,y)$和恢复后的图像$\\hat{f}(x,y)$之间的均方误差达到最小的准则，来实现图像恢复，如下： $e^{2}=\\min exp\\left\\{[f(x, y)-\\hat{f}(x, y)]^{2}\\right\\}$ 满足这一要求的转移函数为： $H_{w}(u, v)=\\frac{H^{*}(u, v)}{|H(u, v)|^{2}+\\frac{S_{n}(u, v)}{S_{f}(u, v)}}$ 其中，$H^{*}(u, v)$是退化函数的复共轭函数，$S_n$是噪声图像功率谱，$S_f$是原始图像功率谱 推广到最小均方误差滤波器： $\\hat{F}(u, v)=\\left[\\frac{1}{H(u, v)} \\times \\frac{|H(u, v)|^{2}}{|H(u, v)|^{2}+s\\left[S_{n}(u, v) / S_{f}(u, v)\\right]}\\right] G(u, v)$ 如果 $s = 1$，方括号内的项就是维纳滤波器 如果s是变量，此时该滤波器被称为参数维纳滤波器 当没有噪声，$S_n(u,v) = 0$时，维纳滤波器退化成反向滤波器中的理想滤波器 有约束还原法最大平滑复原准则：以函数平滑为基础 使得函数的二阶导数为最小 用内积来考察函数的平滑性 &nbsp; 运动模糊图像的复原根据先验知识（退化的原因为已知）大气湍流造成的传递函数 $H(u, v)=\\exp \\left[-c\\left(u^{2}+v^{2}\\right)^{5 / 6}\\right]$ c是与湍流性质有关的常数 光学系统散焦的传递函数 $ H(u, v)=J_{1}(\\pi \\mathrm{~d} \\rho) / \\pi \\mathrm{d} \\rho \\\\ $ 此处$\\rho=\\sqrt{u^{2}+v^{2}} $，d是光学系统散焦点扩散函数的直径 $J_1()$是第一类一阶贝塞尔函数 $ J_{1}(Z)=\\frac{Z}{2} \\sum_{k=0}^{\\infty} \\frac{(-1)^{k} Z^{2 k}}{2^{2 k} \\cdot k(k+1)} $ 当光学系统散焦时，点光源的像将变成圆盘。从公式可以看出，散焦系统的传递函数在以原点为中心，d为半径处存在零点，形成一些同心的暗环，由散焦图像的频谱上估计出这些同心圆的半径，可以得到$H(u,v)$ 匀速直线运动模糊下的传递函数相机与景物之间相对运动造成图像降质 设相机不动，对象运动，运动分量x，y分别为$x_0(t),y_0(t)$，相机快门速度是理想的，快门开启时间（曝光时间为$T_0$, 这里的模糊后的图像值为： $ g(x, y)=\\int_{0}^{T} f\\left[x-x_{0}(t), y-y_{0}(t)\\right] \\mathrm{d} t $ 模糊传递函数为 $H(u,v) = \\frac{sin\\pi l w}{\\pi l w}$ 这里的l为由于运动造成的点位移的长度，$w = ucons\\phi + v sin\\phi$ &nbsp; 根据图像中的点或者线估计(后验知识)由功率谱估计传递函数噪声的确定只要噪声带宽远大于图像带宽即可作白噪声处理 &nbsp; 图像的几何校正概念：几何校正是一种几何变换，是图像的几何畸变的反运算，与几何变换类似。 步骤：空间变换，灰度插值 几何基准图像的坐标系统用$(x,y)$来表示，需要校正的图像的坐标系统用 $(x^{‘},y^{‘})$表示，两个坐标系统之间的关系用解析式表示： $\\begin{array}{l} x^{\\prime}=h_{1}(x, y) \\\\ y^{\\prime}=h_{2}(x, y) \\end{array}$ 通常可以用多项式表示 $\\begin{aligned} x^{\\prime} & =\\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} a_{i j} x^{i} y^{j} \\\\ y^{\\prime} & =\\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} b_{i j} x^{i} y^{j} \\end{aligned}$ 空间变换对于空间变换，通常可以用线性畸变来近似较小的几何畸变 $\\begin{array}{l} x^{\\prime}=a_{0}+a_{1} x+a_{2} y \\\\ y^{\\prime}=b_{0}+b_{1} x+b_{2} y \\end{array}$ 也可以用更精确一些的二次型来近似 对于线性畸变，可以在基准图上找出三个点，在畸变图上也找出对应的三个点 联立解出上面的6个系数 二次畸变方程与系数量更多 灰度插值由输出图像坐标反算出输入图像坐标时，若该坐标并非整数，需要进行灰度再采样 有以下几种方法： 最邻近插值：最简单，但会有块状效应 双线性插值：2*2邻域采样点的平均值 双三次插值：4*4邻域，计算函数为三次函数，效果最好，计算量最大 &nbsp; 图像复原的应用图像复原的空间滤波器（只存在噪声） 均值滤波器（可见图像增强笔记） 顺序统计滤波器（可见图像增强笔记） 自适应滤波器 行为变化基于由mxn矩形窗口定义的区域$S_{xy}$内的图像统计特性 与前述滤波器相比，性能更优，但也增加了算法复杂度 包括自适应局部噪声消除滤波器和自适应中值滤波器 自适应局部噪声消除滤波器滤波器响应基于以下4个量： $g(x,y)$,表示噪声图像在点$(x,y)$上的值 $\\sigma_{\\eta}^{2}$，$g(x,y)$的噪声方差 $m_L$，在$S_{xy}$上像素点的局部均值 $\\sigma_{L}^{2}$，在$S_{xy}$上像素点的局部方差 有： $\\hat{f}(x, y)=g(x, y)-\\frac{\\sigma_{\\eta}^{2}}{\\sigma_{L}^{2}}\\left[g(x, y)-m_{L}\\right]$ 唯一需要知道或者估计的未知量是噪声方差$\\sigma_{\\eta}^{2}$，其他参数可以从$S_{xy}$中的像素计算出来 自适应中值滤波器两个进程，是推理窗口扩大的过程 图像复原的频率域滤波器带通滤波器带阻滤波器陷波滤波器理想滤波器 &amp; 巴特沃斯滤波器 &amp; 高斯滤波器，同图像增强章节 &nbsp; 小结图像增强与图像复原有交叉部分 图像增强主要是主观过程，而图像复原主要是客观过程 &nbsp; &nbsp; &nbsp; Ch5 彩色图像处理彩色图像处理可以分为： 全彩色处理：数码相机，彩色扫描仪 伪彩色处理：对不同灰度或灰度范围赋予不同的颜色 &nbsp; 彩色空间——也称为彩色模型或者彩色系统 ——example: RGB \\ CMY &amp; CMYK \\ HSI \\ YIQ \\ YUV \\ YCbCr RGB CCD或者CMOS技术直接感知RGB三个分量（本身光电传感器无法识别颜色，增加滤光片之后可以分辨） CMY &amp; CMYK CMY（青色，品红，黄）CMYK（青、品红、黄、黑） 大多数在纸上沉积彩色颜料的设备，比如彩色打印机和复印机、印刷设备 打印中的主要颜色是黑色，等量的CMY原色可以产生黑色，但不纯 HSI HSI（色调，饱和度，亮度） I分量与图像的彩色信息无关 H和S分量与人感受颜色的方式是紧密相连的 广泛用于计算机视觉、图像检索和视频检索 YIQ &amp; YUV Y指亮度，即灰度值 I和Q指色调，描述色彩及饱和度，U和V也指色调，与前者不同 用于彩色电视广播，YIQ被北美的电视系统所采用，YUV被欧洲的电视系统所采用 Y分量可提供黑白电视机的所有影像信息 YCbCr Y指亮度 Cb和Cr由U和V调整得到 JPEG采用的彩色空间 &nbsp; 彩色空间的转换（RGB与其他）CMY 将所有值都归一化之后： $ \\left[\\begin{array}{l} C \\\\ M \\\\ Y \\end{array}\\right]=\\left[\\begin{array}{l} 1 \\\\ 1 \\\\ 1 \\end{array}\\right]-\\left[\\begin{array}{l} R \\\\ G \\\\ B \\end{array}\\right] $ RGB-&gt;HSI $ \\begin{array}{l} H=\\left\\{\\begin{array}{ll} \\theta & B \\leq G \\\\ 360-\\theta & B>G \\end{array}\\right. \\\\ \\theta=\\arccos \\left\\{\\frac{\\frac{1}{2}[(R-G)+(R-B)]}{\\left[(R-G)^{2}+(R-G)(G-B)\\right]^{\\frac{1}{2}}}\\right\\} \\\\ S=1-\\frac{3}{(R+G+B)}[\\min (R, G, B)] \\\\ I=\\frac{1}{3}(R+G+B) \\end{array}$ HSI-&gt;RGB $\\begin{array}{l}0^{0} \\leq H&lt;120^{\\circ} \\\\R=I\\left[1+\\frac{S \\cos H}{\\cos \\left(60^{\\circ}-H\\right)}\\right] \\quad G=1-(R+B) \\quad B=I(1-s)\\end{array}$ $\\begin{array}{l}120^{0} \\leq H&lt;240^{\\circ} \\\\G=I\\left[1+\\frac{S \\cos H}{\\cos \\left(60^{\\circ}-H\\right)}\\right] \\quad B=1-(R+G) \\quad R=I(1-s)\\end{array}$ $\\begin{array}{l}240^{0} \\leq H&lt;360^{\\circ} \\\\B=I\\left[1+\\frac{S \\cos H}{\\cos \\left(60^{\\circ}-H\\right)}\\right] \\quad R=1-(G+B) \\quad G=I(1-s)\\end{array}$ 其他 需要数值矩阵 &nbsp; 伪彩色图像处理思想：根据一定的准则对灰度值赋值以彩色的处理 为什么需要：人类可以辨别上千种颜色和强度，但只能辨别二十几种灰度，因此需要一种能够帮助人类观察与解释灰度图像的技术 如何：强度分层技术 &amp; 灰度级到彩色转换技术 强度分层技术简单来说就是对图像灰度分层切割之后分配彩色值 灰度级到彩色的转换 对任何输入像素的灰度级执行3个独立变换 3个变换结果分别送入彩色监视器的红绿蓝三个通道，产生一幅合成图像 应用：X光扫描行李箱 &nbsp; 全彩色图像处理分为两大类： 分别处理每一个分量的图像后合成彩色图像 直接对彩色图像处理：3个颜色分量表示像素向量 &nbsp; 彩色变换彩色变换函数： $ g(x, y)=T[f(x, y)]\\\\ f(x, y) 是彩色输入图像 \\\\ g(x, y) 是变换或处理过的彩色输出图像 \\\\T 是在空间邻域 (x, y) 上对 f 的操作 $ 对于某一个点处彩色分量的变量： $ s_{i}=T_{i}\\left(r_{1}, r_{2}, \\ldots, r_{n}\\right) \\quad i=1,2, \\ldots, n\\\\ r_{i} 和 S_{i} 是 f(x, y) 和 g(x, y) 在任何点处彩色分量的变量\\\\ \\left\\{T_{1}, T_{2}, \\ldots T_{n}\\right\\} 是一个对 r_{i} 操作产生 s_{i} 的变换或彩色映射函数集$ 补色：在彩色环上，与一种色调直接相对立的另一种色调称为补色 色调校正：实验性地调整图像亮度和对比度 彩色平衡： 偏色： 采样过程中，由于设备、环境的原因会造成图象的三个颜色分量不同的变换关系，使图象中所有物体的颜色偏离了其原有的真实色彩，这种现象被称为偏色。 如何检查彩色图像的偏色问题：即检查在现实种应该是灰色的物体，在图像中是否是灰色 色彩平衡算法：需要选取灰色区域，按某一个RGB分量作为线性校正的基准 &nbsp; 彩色图像平滑和尖锐化同灰度图像，有空间域滤波与频率微分，只是输入通道换成了对应彩色空间的n个分量 彩色空间分割： HSI：可用直方图分割 RGB：可用不同像素的颜色向量与分割样本的颜色向量之间的欧氏距离为判据 &nbsp; &nbsp; &nbsp; Ch6 形态学图像处理基础知识形态学：是生物学中研究动物和植物结构的一个分支。 数学形态学（图像代数）：以形态为基础对图像进行分析的数学工具。 形态学图像处理的应用：可以简化图像数据，保持它们基本的形状特性，并除去不相干的结构。 思想：用具有一定形态的结构元素，去度量和提取图像中的对应形状，以达到对图像分析和识别的目的 发展：初期的数学形态学方法仅可以应用于二值图像，所以需要将灰度图像先进行二值化。后来灰度形态学得到发展，使得数学形态学方法不仅可以用于二值图像，也可以应用于各种灰度与彩色图像。 &nbsp; 二值形态学中的运算对象是集合，但实际运算中当涉及两个集合时并不把他们看作是互相对等的，一般设A为图像集合，B为结构元素，数学形态学运算是用B对A进行操作。 结构元素本身实际上也是一个图像集合。对每个结构元素，先要指定一个原点，它是结构元素参与形态学运算的参考点。注意原点可以包含在结构元素中，也可以不包含在结构元素中（即原点并不一定要属于结构元素），但两种情况下的运算结果常不相同 。 集合论中的基本概念：并，交，补，差 有公式： 集合A的平移，平移到z(z1,z2) $(A)_{z}=\\{c \\mid c=a+z, a \\in A\\}$ B的反射：关于结构元素的原点 $\\hat{B}=\\{w \\mid w=-b, b \\in B\\}$ 示意图如下： &nbsp; 二值图像的基本逻辑运算 &nbsp; 膨胀与腐蚀膨胀与腐蚀是形态学算法的基础 膨胀：使得图像扩大 腐蚀：使得图像缩小 膨胀：A被B膨胀的定义： $A \\oplus B=\\left\\{z \\mid(\\hat{B})_{z} \\cap A \\neq \\varnothing\\right\\}$ A为图像元素，B为结构元素，上述式子表明，B的反射进行平移后与A的交集不为空 反射的目的：确保膨胀的空间对称性 算法实现过程： 对B进行反射，反射后B的原点移动至集合A的某一点 将反射后B的坐标与集合A中该店坐标相加，得到膨胀运算结果 对集合A中所有元素重复上述过程 example: 应用：将裂缝桥接起来 &nbsp; 腐蚀B对A的腐蚀是一个用z平移的B包含在A中所有的点z的集合，可以理解为，B完全包含在A中时，B的原点位置的集合 定义： $A \\ominus B=\\left\\{z \\mid(B)_{z} \\subseteq A\\right\\}$ 膨胀和腐蚀这两种运算是紧密联系在一起的，一个运算对图像目标的操作相当于另一个运算对图像背景的操作 example： 应用：在数学形态学运算中的作用是消除物体边界点，可以把小于结构元素的物体（毛刺、小突起）去除，因此选取不同大小的结构元素，就可以在原始图像中去除不同大小的物体，达到筛选的目的 &nbsp; 开操作和闭操作开操作：使图像的轮廓变得光滑，断开狭窄的连接和消除细的突出物 $A \\circ B=(A \\ominus B) \\oplus B$ 先用B对A腐蚀，然后用B对结果进行膨胀 &nbsp; 闭操作：同样使得图像的轮廓变得光滑，但与开操作相反，能消除狭窄的间断与长细的鸿沟，消除小的空洞，并填补轮廓线中的裂痕 $A \\bullet B=(A \\oplus B) \\ominus B$ 先用B对A膨胀，然后用B对结果进行腐蚀 &nbsp; 击中或击不中变换 一般来说，一个物体的结构可以由物体内部各种成分之间的关系来确定。为了研究物体（在这里指图像）的结构，可以逐个地利用其各种成分 （例如各种结构元素）对其进行检验，判定哪些成分包括在图像内，哪些在图像外，从而最终确定图像的结构。 设有两幅图像A &amp; B，如果A与B的交集不为空集，那么称B击中A，否则称B击不中A &nbsp; 一些基本的形态学算法边界提取 $\\beta(A)=A-(A \\ominus B)$ 先用B对A腐蚀，然后用A减去腐蚀的结果 使用3x3的结构元素提取的边界宽度为1像素 区域填充使用迭代法进行区域填充 $X_{k}=\\left(X_{k-1} \\oplus B\\right) \\cap A^{c}$ 如下图所示：$X_7 = X_8$，当$X_k = X_{k-1}$时，算法在迭代的第k步结束 *如果公式不加与A的补集的交集，则结果将会无限膨胀 凸壳 细化 粗化 骨架 裁剪等二值形态学的五个基本结构元素（B） &nbsp; 灰度级形态学膨胀 &amp; 腐蚀膨胀： $(f \\oplus b)(s, t)=\\max \\left\\{f(s-x, t-y)+b(x, y)(s-x),(t-y) \\in D_{f} ;(x, y) \\in D_{b}\\right\\} $ 亮特征变强，暗特征变弱 腐蚀： $(f \\ominus b)(s, t)=\\min \\left\\{f(s+x, t+y)-b(x, y)(s+x),(t+y) \\in D_{f} ;(x, y) \\in D_{b}\\right\\} $ 亮特征变弱，暗特征变强 开操作与闭操作与二值化图像操作的构成相同 &nbsp; 灰度级形态学处理的一些应用形态学平滑处理先开操作，再闭操作：消除/减弱人为的亮和暗的细节 形态学图像梯度（边缘增强）类似于微分 or 梯度操作 膨胀粗化图像中的目标区域，腐蚀细化它们，两者之差强调了区域间的边界 $g=(f \\oplus b)-(f \\ominus b)$ Top-hat变换可增强阴影细节 $h=f-(f \\circ b)$ 粒度测定 选择各类合适半径尺寸的圆盘结构元对图像进行开操作 对于每一次开操作，计算像素值的和 表面区域是圆盘形结构元半径的函数 *为什么不直接腐蚀：单纯腐蚀会导致颗粒尺寸被低估，开操作通过结构元素与颗粒的匹配度筛选尺寸，结果更接近真实分布 纹理分割 对原图执行闭操作删除小圆点 执行开操作删除大圆点之间的亮间隔，得到分割边界 &nbsp; &nbsp; &nbsp; Ch7 图像分割基础知识图像分割是指把图像分成各个具有相应特性的区域并提取出感兴趣目标的技术和过程 特性包括：灰度、颜色、纹理等，目标可以对应单个区域，也可以对应多个区域 分类： 按幅度不同分割：幅度分割 按边缘不同分割：边缘检测 按形状不同分割：区域检测 对灰度图像的分割常可以基于像素灰度值的两个性质： 不连续性和相似性。区域内部的像素一般具有灰度相似性，而在区域之间的边界上一般具有灰度不连续性。不连续性-&gt;基于边界的分割；相似性-&gt;基于区域的分割 &nbsp; 间断检测点检测使用模板 $R = w_1z_1+w_2z_2+w_3z_3+...+w_9z_9 = \\sum_{i=1}^{9}w_iz_i$ 人为设置阈值，且如果模板的响应为0，则表示在灰度级为常数的区域 线检测有4个线检测模板，分别在水平，+45°，垂直以及-45°方向上有最大响应 边缘检测 边缘是一组相连的像素集合，这些像素位于两个区域的边界上。灰度边缘是灰度值不连续的结果。 一阶导数与二阶导数在识别图像的边缘中具有重要的作用 数字边缘的模型有：理想数字边缘模型 &amp; 斜坡数字边缘模型。理想数字边缘模型是一种阶跃型的信号，而斜坡数字边缘模型与边缘的模糊程度成比例关系。 如上图所示，以斜坡数字边缘模型为例，可对其求导，在边缘斜面上，一阶导数为正，其他区域为0；在边缘与黑色交界处，二阶导数为正，在边缘与亮色交界处，二阶导数为负；沿着斜坡和灰度为常数的区域为0。 因此有： 一阶导数可以用于检测图像中的一个点是否在边缘上 二阶导数的符号可以判断一个边缘像素是在边缘的亮侧还是在边缘的暗侧 一阶导数使用梯度算子，二阶导数使用拉普拉斯算子 *微弱的噪声对导数的影像非常严重，所以预处理要先降噪/平滑处理 边缘检测算子 梯度算子 or 差分算子 Laplace算子 Canny算子 &nbsp; 梯度算子$\\nabla f(x, y) = G[f(x,y)] = [\\frac{\\partial f}{\\partial x} \\frac{\\partial f}{\\partial y}]^{T}$ 梯度的模：$|\\nabla f(x, y)|=\\sqrt{\\left(\\frac{\\partial f}{\\partial x}\\right)^{2}+\\left(\\frac{\\partial f}{\\partial y}\\right)^{2}}$ 方向角：$\\phi(x, y)=\\arctan \\left(G_{x} / G_{y}\\right)$ 离散化后为：$\\nabla f(x, y)=|f(x, y)-f(x+1, y+1)|+|f(x+1, y)-f(x, y+1)|$ 在空间域图像增强的基础上增加梯度算子Kirsch： 由8个方向模板组成，每个模板的值有不同的趋向性，将8个模板分别与图像相乘，选取最大的一个值，作为中央像素的边缘强度。使得梯度算子一定程度上具有了方向性。 &nbsp; 拉普拉斯算子公式与模板： $ \\begin{array}{l} \\nabla^{2} f(x, y)=\\frac{\\partial^{2} f(x, y)}{\\partial x^{2}}+\\frac{\\partial^{2} f(x, y)}{\\partial y^{2}} \\\\ =f(x+1, y)+f(x-1, y)+f(x, y-1)+4 f(x, y) \\\\\\\\ {\\left[\\begin{array}{ccc} 0 & -1 & 0 \\\\ -1 & 4 & -1 \\\\ 0 & -1 & 0 \\end{array}\\right] \\quad\\left[\\begin{array}{ccc} -1 & -1 & -1 \\\\ -1 & 8 & -1 \\\\ -1 & -1 & -1 \\end{array}\\right] \\quad\\left[\\begin{array}{ccc} 1 & -2 & 1 \\\\ -2 & 4 & -2 \\\\ 1 & -2 & 1 \\end{array}\\right] } \\end{array} $ 推广： 为减少噪声对拉普拉斯算子的影响，在其基础上实现的马尔算子，它先用一个2D的高斯平滑模板与源图像进行卷积，之后再进行拉普拉斯算子套用。 &nbsp; 最优边缘检测算法——Canny算子 好的图像边缘检测需要满足下面两个条件： 能有效地抑制噪声 能精确地定位到边缘的位置 类似于马尔算子，Canny算子也属于先平滑后求导的方法 算法步骤 用高斯滤波器平滑图像： $G(x, y)=f(x, y) * H(x, y)$ 用一阶偏导的有限差分来计算梯度的幅值和方向 $\\begin{array}{l} H_{1}=\\left|\\begin{array}{cc} -1 & -1 \\\\ 1 & 1 \\end{array}\\right| \\quad H_{2}=\\left|\\begin{array}{ll} 1 & -1 \\\\ 1 & -1 \\end{array}\\right| \\\\ \\varphi_{1}(m, n)=f(m, n) * H_{1}(m, n) \\\\ \\varphi_{2}(m, n)=f(m, n) * H_{2}(m, n) \\\\ \\varphi(m, n)=\\sqrt{\\varphi_{1}^{2}(m, n)+\\varphi_{2}^{2}(m, n)} \\\\ \\theta_{\\varphi}(m, n)=\\tan ^{-1} \\frac{\\varphi_{2}(m, n)}{\\varphi_{1}(m, n)} \\end{array}$ 非极大值抑制——细化边缘 利用梯度的方向，保留局部梯度最大的点 $\\xi[\\mathbf{i}, \\mathbf{j}]=\\operatorname{Sector}(\\theta[\\mathbf{i}, \\mathbf{j}])$ 在一个3x3的邻域中，4种类型的边缘方向的边缘法线有一定的角度范围，在每一点上，邻域的中心像素M与沿着梯度线的两个像素相比。如果M的梯度值不比沿梯度线的两个相邻像素梯度值大，则令M = 0. $\\mathbf{N}[\\mathbf{i}, \\mathbf{j}]=\\mathbf{N M S}(\\mathbf{M}[\\mathbf{i}, \\mathbf{j}], \\xi[\\mathbf{i}, \\mathbf{j}])$ 阈值化 对N使用一个阈值，将低于阈值的所有值赋0，解决方法为双阈值算法 &nbsp; 边缘连接在边缘检测后，仅仅得到位置在边缘上的像素点，实际上得到的这些像素点由于各种原因很少能完整地组成一条边缘，因此在使用边缘检测算法之后，需要使用连接过程将边缘像素组合成有意义的边缘。 局部处理如何确定边缘像素的相似性 对于两个边缘像素，若以下两个值： 边缘像素梯度算子的响应强度 边缘像素梯度算子的方向 在自己设定的阈值范围内，则可以将两点连接起来 轮廓跟踪和图搜索 确定作为搜索起点的边缘点 确定和采取一种合适的数据结构和搜索机理，在已经发现的轮廓点基础上确定新的轮廓点 确定搜索终结的准则或者终止条件，满足条件时停止进程，结束搜索 个人认为算是一种路径搜索算法，边界点和边界段可以用图结构表示，通过在图中进行搜索对应最小代价的通道也可以找到闭合边界。 边缘元素是2个互为4-近邻的像素的边缘，每个由像素p和q确定的边缘元素对应一个代价函数： $ c(p,q) = H- [f(p)-f(q)] $ 其中H为图像中的最大灰度值，代价函数的取值与像素之间的灰度差成反比，需要找寻的边界时代价最小的路径 example： 哈夫变换利用图像的全局特性直接检测目标轮廓 提出：从像素之间的整体关系出发，检测目标边界 把在图像空间里的直线检测问题转换为参数空间里对点的检测问题，通过在参数空间里进行简单的累加统计完成检测任务。 涉及到坐标系变换与解析，可看其他资料进一步了解并理解推导。 &nbsp; 阈值分割字面理解，阈值分割方法的关键是选取合适的阈值 有以下几种方法： 全局阈值 局部阈值 动态/自适应阈值 全局阈值自动获取阈值T的方法： 选取一个T的初始估计值，一般取图像的平均灰度 用T分割图像，G1为所有灰度值大于T的，剩余为G2 对G1和G2中所有像素计算平均灰度值g1和g2 计算新的阈值$T_1 = \\frac{1}{2}(g_1+g_2)$ 重复步骤2~4，直到迭代得到的T值小于等于T初始值 基本自适应阈值单一全局阈值存在的问题：不均匀亮度图像无法有效分割 解决方法：将图像进一步细分为子图像，并对不同的子图像使用不同的阈值处理 问题：如何将图像进行细分，且如何为得到的子图像估计阈值 对于仅包含2个主要灰度级的区域，令z表示灰度级值，则两个灰度区域的直方图可以看作其概率密度函数的估计p(z)，如果p(z)已知，则它能够确定一个最有阈值，将图像分割成两个可以区分的部分，下式中P1是属于目标对象的概率，P2是属于背景像素的概率，有$P_1+P_2 = 1$ 最优阈值： $T=\\frac{\\mu_{1}+\\mu_{2}}{2}+\\frac{\\sigma^{2}}{\\mu_{1}-\\mu_{2}} \\ln \\left(\\frac{P_{2}}{P_{1}}\\right)$ 数学推导略复杂，遂省略 通过边界特性选择阈值基本思想，将直方图修正为较为直观的形态：波峰高且窄，对称，且被很深的波谷分开。 修正方法：用微分算子处理图像，使得图像只剩下边界中心两边的值，因此直方图也只剩下边缘的像素。边缘上的点在区域内和区域外的概率相等，因此可以增加波峰的对称性 &nbsp; 聚类分割机器学习常见算法 &nbsp; 区域分割概念：将整幅图像区域划分为n个子区域，满足完备性、连通性、独立性、互斥性 区域生长法一种从单个像素出发，逐渐合并以形成所需分割区域的技术 核心：相似条件的确定 生长准则： 基于区域灰度差（字面意思）基于区域内灰度分布统计性质 把像素分成互不重叠的小区域； 比较邻接区域的累积灰度直方图，根据灰度分布的相似性进行区域合并； 设定终止准则，通过反复进行上一个步骤中的操作将各个区域依次合并直到满足终止准则 基于区域形状方法1：把图像分割成灰度固定的区域，设两相邻区域的周长为P1和P2，把两区域共同边界线两侧灰度差小于给定值的那部分设为L，如果有：（T1为预定的阈值） $\\frac{L}{\\min \\left\\{P_{1}, P_{2}\\right\\}}>T_{1} $ 则合并两区域 方法2：把图像分割成灰度固定的区域，设两邻接区域的共同边界长度为B，把两区域共同边界线两侧灰度差小于给定值的那部分长度设为L，如果有：（T2为预定阈值） $\\frac{L}{B}>T_{2} $ 则合并两个区域 第一种方法是合并两邻接区域的共同边界中对比度较低部分占整个区域边界份额较大的区域， 第二种方法则是合并两邻接区域的共同边界中对比度较低部分比较多的区域。 &nbsp; 分裂合并思想：先把图像分成任意大小且不重叠的区域，然后根据准则合并或者分裂这些区域，迭代直到实现分割 &nbsp; 基于形态学分水岭的分割又称为watershed变换，是一种借鉴形态学理论的分割方法。它利用图像区域特性来分割图像，将边缘检测与区域生长的优点结合起来，能够得到单像素的、连通的、封闭的且位置准确的轮廓 把图像看成3-D地形的表示，即2-D的地基（对应图像空间）加上第3维的高度（对应图像灰度） &nbsp; &nbsp; 《数字图像处理》这本书看了七七八八，有一些内容很有趣，知道opencv库的一些底层原理还是有必要的。其中有一些内容，例如：图像理解、数字图像编码技术、图像模式分类等，没有再继续看。希望可以在实践中巩固这些知识。","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"https://miustannis.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"手持红外热成像仪V2.0-加载图像算法并嵌入轻量级神经网络","slug":"250510","date":"2025-05-10T02:05:52.000Z","updated":"2025-08-20T04:14:46.405Z","comments":true,"path":"2025/05/10/250510/","link":"","permalink":"https://miustannis.github.io/2025/05/10/250510/","excerpt":"","text":"在之前的基础上改进了一部分 硬件上把串口和SWD下载口引出来了，夹具下载有点不稳定 同时把手头上的LCD模组和红外传感器模组给用了，没有额外购买物资，成品图如下： 左边是V1，右边是V2 &nbsp; 软件部分增加了一些图像处理的功能： 图像平滑：双线性插值 void interpolateTemperature(float *src, float *dst, uint8_t src_w, uint8_t src_h, uint8_t dst_w, uint8_t dst_h) &#123; float x_ratio = (float)(src_w-1) / dst_w; float y_ratio = (float)(src_h-1) / dst_h; for (int y = 0; y &lt; dst_h; y++) &#123; for (int x = 0; x &lt; dst_w; x++) &#123; float x_src = x * x_ratio; float y_src = y * y_ratio; int x0 = (int)x_src, y0 = (int)y_src; float x_diff = x_src - x0; float y_diff = y_src - y0; float val = src[y0*src_w + x0] * (1-x_diff)*(1-y_diff) + src[y0*src_w + x0+1] * x_diff*(1-y_diff) + src[(y0+1)*src_w + x0] * (1-x_diff)*y_diff + src[(y0+1)*src_w + x0+1] * x_diff*y_diff; dst[y*dst_w + x] = val; &#125; &#125; &#125; 最近邻插值 void nearestNeighborInterpolate(float *src, float *dst, uint8_t src_w, uint8_t src_h, uint8_t dst_w, uint8_t dst_h) &#123; float x_ratio = (float)src_w / dst_w; float y_ratio = (float)src_h / dst_h; for (int y = 0; y &lt; dst_h; y++) &#123; for (int x = 0; x &lt; dst_w; x++) &#123; int src_x = (int)(x * x_ratio); int src_y = (int)(y * y_ratio); // 防止越界 if (src_x >= src_w) src_x = src_w - 1; if (src_y >= src_h) src_y = src_h - 1; dst[y * dst_w + x] = src[src_y * src_w + src_x]; &#125; &#125; &#125; 边缘提取// Sobel 算子卷积核 const int sobel_x[3][3] = &#123; &#123;-1, 0, 1&#125;, &#123;-2, 0, 2&#125;, &#123;-1, 0, 1&#125; &#125;; const int sobel_y[3][3] = &#123; &#123;-1, -2, -1&#125;, &#123; 0, 0, 0&#125;, &#123; 1, 2, 1&#125; &#125;; void detectEdges(float *input, uint8_t *output, uint8_t width, uint8_t height) &#123; for (int y = 1; y &lt; height - 1; y++) &#123; for (int x = 1; x &lt; width - 1; x++) &#123; float gx = 0, gy = 0; // 3x3 邻域卷积 for (int j = -1; j &lt;= 1; j++) &#123; for (int i = -1; i &lt;= 1; i++) &#123; float pixel = input[(y + j) * width + (x + i)]; gx += pixel * sobel_x[j + 1][i + 1]; gy += pixel * sobel_y[j + 1][i + 1]; &#125; &#125; uint8_t edge_strength = (uint8_t)(fabs(gx) + fabs(gy)); edge_strength = (edge_strength > 255) ? 255 : edge_strength; output[y * width + x] = edge_strength; &#125; &#125; &#125; static void drawPicture3(void) &#123; uint8_t cell_size = 4; uint8_t start_x = 0; uint8_t start_y = 16; float interpolated_temp[32 * 24]; uint8_t edge_map[32 * 24]; //双线性插值 interpolateTemperature(tempValues, interpolated_temp, 32, 24, 32, 24); //边缘检测 detectEdges(interpolated_temp, edge_map, 32, 24); //只绘制边缘（白色），其余区域黑色 for (int y = 0; y &lt; 24; y++) &#123; for (int x = 0; x &lt; 32; x++) &#123; uint16_t color = ST7735_BLACK; // 默认黑色 // 如果边缘强度足够高，则显示白色 if ((edge_map[y * 32 + x] > 10 ) &amp;&amp; (edge_map[y * 32 + x] &lt; 40 ))&#123; // 阈值可调 color = ST7735_WHITE; &#125; ST7735_FillRectangle( start_x + x * cell_size, start_y + (23 - y) * cell_size, cell_size, cell_size, color ); &#125; &#125; &#125; 图像识别准备往设备里嵌一个轻量级的神经网络，尝试一下更深层次的边缘计算 应用场景是经典手势识别，设置了1~5的数据集，其实就是自己用串口传到PC进行数据清洗 网络结构如下： 特征提取层：包含两个步长为2的3x3卷积层（通道数从1→4→8），每层后接ReLU激活，将输入从 [1,32,24] 逐步下采样至 [8,8,6]。 分类器层：将特征展平后，经过一个8维的线性层（含ReLU），最终输出5类概率。总参数量约3KB，RAM占用&lt;8KB 在pyTorch中秒搭建模型 class MicroTempNet(nn.Module): def __init__(self, num_classes=5): super().__init__() # 特征提取 self.features = nn.Sequential( nn.Conv2d(1, 4, kernel_size=3, stride=2, padding=1), # [4, 16, 12] nn.ReLU(), nn.Conv2d(4, 8, kernel_size=3, stride=2, padding=1), # [8, 8, 6] nn.ReLU(), ) # 分类器 (参数量: 8*8*6*8 + 8 + 8*5 + 5 = 2,669) self.classifier = nn.Sequential( nn.Linear(8*8*6, 8), nn.ReLU(), nn.Linear(8, num_classes) ) def forward(self, x): x = x.unsqueeze(1) # 添加通道维度 [B,1,32,24] x = self.features(x) x = torch.flatten(x, 1) x = self.classifier(x) return x 将模型以权重模式保存并导出到c头文件 torch.save(model.state_dict(), 'micro_temp_net_params.pth') 之后将每个部分转C，这里大量使用ai工具，还是比较给力的 &#x2F;&#x2F; ReLU static void relu(float* data, int size) &#123; for (int i &#x3D; 0; i &lt; size; i++) &#123; data[i] &#x3D; data[i] &gt; 0 ? data[i] : 0; &#125; &#125; &#x2F;&#x2F; 2d convolution stride &#x3D; 2 static void conv2d_stride2(const float* input, const float* weights, const float* bias, float* output, int in_channels, int out_channels, int height, int width, int kernel_size) &#123; int out_h &#x3D; height &#x2F; 2; int out_w &#x3D; width &#x2F; 2; for (int oc &#x3D; 0; oc &lt; out_channels; oc++) &#123; for (int oh &#x3D; 0; oh &lt; out_h; oh++) &#123; for (int ow &#x3D; 0; ow &lt; out_w; ow++) &#123; float sum &#x3D; bias[oc]; int ih &#x3D; oh * 2; int iw &#x3D; ow * 2; for (int ic &#x3D; 0; ic &lt; in_channels; ic++) &#123; for (int kh &#x3D; 0; kh &lt; kernel_size; kh++) &#123; for (int kw &#x3D; 0; kw &lt; kernel_size; kw++) &#123; int input_idx &#x3D; ic * height * width + (ih + kh) * width + (iw + kw); int weight_idx &#x3D; oc * in_channels * kernel_size * kernel_size + ic * kernel_size * kernel_size + kh * kernel_size + kw; sum +&#x3D; input[input_idx] * weights[weight_idx]; &#125; &#125; &#125; int output_idx &#x3D; oc * out_h * out_w + oh * out_w + ow; output[output_idx] &#x3D; sum; &#125; &#125; &#125; &#125; &#x2F;&#x2F; fc static void dense(const float* input, const float* weights, const float* bias, float* output, int in_features, int out_features) &#123; for (int i &#x3D; 0; i &lt; out_features; i++) &#123; output[i] &#x3D; bias[i]; for (int j &#x3D; 0; j &lt; in_features; j++) &#123; output[i] +&#x3D; input[j] * weights[i * in_features + j]; &#125; &#125; &#125; &#x2F;&#x2F; initialize void micro_temp_net_init(MicroTempNet* net, const float* conv1_w, const float* conv1_b, const float* conv2_w, const float* conv2_b, const float* fc1_w, const float* fc1_b, const float* fc2_w, const float* fc2_b) &#123; net-&gt;conv1_weight &#x3D; conv1_w; net-&gt;conv1_bias &#x3D; conv1_b; net-&gt;conv2_weight &#x3D; conv2_w; net-&gt;conv2_bias &#x3D; conv2_b; net-&gt;fc1_weight &#x3D; fc1_w; net-&gt;fc1_bias &#x3D; fc1_b; net-&gt;fc2_weight &#x3D; fc2_w; net-&gt;fc2_bias &#x3D; fc2_b; &#125; &#x2F;&#x2F; predict void micro_temp_net_predict(const MicroTempNet* net, float* input, float* output) &#123; &#x2F;&#x2F; [1,32,24] -&gt; [4,16,12] float conv1_out[4 * 16 * 12]; conv2d_stride2(input, net-&gt;conv1_weight, net-&gt;conv1_bias, conv1_out, 1, 4, 32, 24, 3); relu(conv1_out, 4 * 16 * 12); &#x2F;&#x2F; [4,16,12] -&gt; [8,8,6] float conv2_out[8 * 8 * 6]; conv2d_stride2(conv1_out, net-&gt;conv2_weight, net-&gt;conv2_bias, conv2_out, 4, 8, 16, 12, 3); relu(conv2_out, 8 * 8 * 6); &#x2F;&#x2F; [8,8,6] -&gt; 384 float flattened[8 * 8 * 6]; memcpy(flattened, conv2_out, sizeof(flattened)); &#x2F;&#x2F; 384-&gt;8 float fc1_out[8]; dense(flattened, net-&gt;fc1_weight, net-&gt;fc1_bias, fc1_out, 8 * 8 * 6, 8); relu(fc1_out, 8); &#x2F;&#x2F; 8-&gt;5 dense(fc1_out, net-&gt;fc2_weight, net-&gt;fc2_bias, output, 8, NUM_CLASSES); &#125; 主函数里按数据预处理，推理，分类的顺序写了逻辑，注意要和python中一样把数据归一化 void CNN_PROC(void)&#123; //input for (int y = 0; y &lt; 24; y++) &#123; for (int x = 0; x &lt; 32; x++)&#123; input[y * 32 + x] = tempValues[(31- x) + (y * 32)]; &#125; &#125; z_score_normalize(input,768); // airun float output[NUM_CLASSES]; micro_temp_net_predict(&amp;CNNmodel, input, output); // postproc int predicted_class = 0; float max_prob = output[0]; for (int i = 1; i &lt; NUM_CLASSES; i++) &#123; if (output[i] > max_prob) &#123; max_prob = output[i]; predicted_class = i; &#125; &#125; predicted_class += 1; sprintf(tempbuffer, \"%d \" , predicted_class); ST7735_WriteString(65, 115, tempbuffer, Font_7x10, ST7735_WHITE, ST7735_BLACK); &#125; void z_score_normalize(float* input, int size) &#123; for (int i = 0; i &lt; size; i++) &#123; input[i] = (input[i] - INPUT_MEAN) / INPUT_STD; &#125; &#125; 不过最后分类效果有点烂，就3和5效果比较好，当作一次边缘设备部署ai的经历还是挺有趣的","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://miustannis.github.io/tags/Algorithm/"},{"name":"图像处理","slug":"图像处理","permalink":"https://miustannis.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"Hexo博客插入数学公式","slug":"250327","date":"2025-03-27T04:22:29.000Z","updated":"2025-08-20T04:14:55.897Z","comments":true,"path":"2025/03/27/250327/","link":"","permalink":"https://miustannis.github.io/2025/03/27/250327/","excerpt":"","text":"目录： Step 1 : 安装MathJax引擎并更换渲染引擎： Step 2 : 更新MathJax的cdn链接 Step 3 : 更改部分转义规则 Step 4 (可选) : 主题未预配置下使用Hexo-filter-mathjax 测试 在写一些内容时，会遇到需要添加数学公式的地方，Hexo部分主题不支持公式的渲染，比如我正在使用的vivia主题，在查阅一些资料之后，我使用MathJax引擎实现了vivia主题下的数学公式渲染。 MathJax简介：https://www.osgeo.cn/mathjax/basic/mathjax.html 该引擎是一款可在所有现代浏览器中工作的开源js显示引擎，辅助页面作者编写含有数学公式的文档 Step 1 : 安装MathJax引擎并更换渲染引擎：​ 操作包括卸载Hexo自带的Hexo-math，卸载默认的对MathJax不友好的marked引擎 npm uninstall hexo-math --save npm install hexo-renderer-mathjax --save npm uninstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save Step 2 : 更新MathJax的cdn链接Step 3 : 更改部分转义规则 hexo 默认的转义规则会将一些字符进行转义，所以要对默认的规则进行修改。首先， 打开/node_modules/kramed/lib/rules/inline.js 把： escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_>])/, em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 更改为： escape: /^\\\\([`*\\[\\]()# +\\-.!_>])/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, Step 4 (可选) : 主题未预配置下使用Hexo-filter-mathjax对于已经配置MathJax的主题来说，在相关config文件里打开控件即可，对于未配置的主题，可以使用Hexo-filter-mathjax来帮助实现 Hexo-filter-mathjax项目地址：https://github.com/next-theme/hexo-filter-mathjax 安装： npm install hexo-filter-mathjax --save 对需要开启的博文，在其Front-Matter处增加mathjax: true这一行即可，如： --- title: xxxxxx categories: xxxxx date: xxxx-xx-xx mathjax: true --- &nbsp; 测试公式： $\\Bbb{\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6} }$ $\\frak{\\cos 2\\theta = \\cos^2 \\theta - \\sin^2 \\theta = 2 \\cos^2 \\theta-1}$ 矩阵运算： $\\left( \\begin{array}{c} s \\\\ t \\end{array}\\right)=\\left( \\begin{array}{cc} cos(b) &amp; -sin(b) \\\\ sin(b) &amp; cos(b) \\end{array}\\right)\\left( \\begin{array}{c} x \\\\ y \\end{array}\\right)$ *注意到有的cdn版本MathJax框架下公式字体对行间公式有一定影响，可能会一些字体会被渲染成主题相同字体，且移动端不能很好地显示 参考资料： https://www.cnblogs.com/wangxin37/p/8185688.html https://heartlessly.github.io/others/latex-mathjax-gong-shi-zi-ti-mei-hua/","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://miustannis.github.io/tags/Hexo/"}]},{"title":"Harvard CS50 Study Log","slug":"250306","date":"2025-03-06T12:39:18.000Z","updated":"2025-07-04T07:49:40.106Z","comments":true,"path":"2025/03/06/250306/","link":"","permalink":"https://miustannis.github.io/2025/03/06/250306/","excerpt":"","text":"目录： Lecture 0 Scratch Lecture 1 C Lecture 2 Arrays Lecture 3 Algorithms Lecture 4 Memory Lecture 5 Data Structures Lecture 6 Python, Artificial Intelligence Lecture 7 SQL Lecture 8 HTML, CSS, JavaScript Lecture 9 Flask Lecture 10 Cybersecurity Lecture 0 ScratchLecture 1 CLecture 2 ArraysLecture 3 Algorithms Time Complexity is an important metric used to measure the relationship between the running time of an algorithm and the size of the input. It describes how the execution time of an algorithm increases as the input size grows. Time complexity helps us assess the efficiency of an algorithm under different problem sizes, allowing us to choose the most appropriate algorithm. Time complexity is usually expressed using Big $O$ notation. selection sort: $ O(n^2) $ bubble sort： $ O(n^2) $ insertion sort： $ O(n^2) $ merge sort： $ O(nlogn) $ &nbsp; Lecture 4 Memory This section basically start from the pixels which formed by RGB code, for example 0xFF0000(using hexadecimal or base16 — 0x) . Why hexadecimal ? Using binary, it takes 4 bits to represent 16 possibilities. Using hexadecimal, 4 bits -&gt; one digit, that’s easier. So one byte, two of them, is a common unit of measurement. Then it comes to the tool or variable commonly used in C language which is pointer. A pointer is an address. int n = 50; printf(\"%i\\n\", n); // --50 printf(\"%p\\n\", &amp;n); // -- some address //the following sytanx are slightly differrent! int *p = &amp;n; // also int* p = &amp;n; they are the same, to specify a data type printf(\"%p\\n\", p);// -- same address above printf(\"%i\\n\", *p);// *p: go there --50 “&amp;a” means the address of a, “*“ is a dereference operator, which allows you to take an address, and go to it. By convention, pointers take up more space, they account for 8 bytes. 32-bit machine differs from 64-bit machine in the width of address bus, where 64-bit machine has larger memory. Strings, arrays of char so to speak, live at some address. They are continuous in memory from left to right, with 1 byte from each other. string s = \"CS50!\"; printf(\"%s\\n\",s);//--CS50! printf(\"%p\\n\",s);//--some address printf(\"%p\\n\",&amp;s[0]);//--address same as above printf(\"%p\\n\",&amp;s[1]);//--address above + 0x1 //technically string is not an actual datatype string s = \"CS50!\"; char* s = \"CS50!\"; //typedef char* string; !! //char* s = \"CS50!\"; \"&amp;\" is not needed here because CLANG puts the address of the first char in the variable when a double quote shows up. s is technically a pointer, to find the beginning of the string. pointer arithmetic: doing math on addresses char *s = \"CS50\"; printf(\"%c\\n\", s[0]); // -- C printf(\"%c\\n\", s[1]); // -- S printf(\"%c\\n\", *s); // -- C printf(\"%c\\n\", *(s+1)); // -- S memory allocate: FREE &amp; MALLOC 特性 栈（Stack） 堆（Heap） 管理方式 自动（编译器/操作系统） 手动（程序员malloc） 分配速度 快（直接移动指针） 慢（需要查找可用内存） 生命周期 函数调用结束就释放 显式释放（free） 大小限制 较小（几MB） 较大（受系统内存限制） 存储内容 局部变量、函数调用信息 动态分配的对象、大型数据 碎片问题 无 可能产生内存碎片 //program for string operating #include &lt;ctype.h> #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;cs50.h> int main(void) &#123; char *s = get_string(\"s: \"); // fuction from cs50.h char *t = malloc(strlen(s) + 1); // malloc : memory allocate // return the first address of the memory if(t == NULL)&#123; return 1; &#125; // \"NULL\" no memory available for(int i = 0, n = strlen(s); i&lt;=n ; i++)&#123; t[i] = s[i]; &#125; strcpy(t,s);// equivalent if (strlen(t) > 0)&#123; t[0] = toupper(t[0]); &#125; printf(\"%s\\n\", s); printf(\"%s\\n\", t); free(t); //free the memory mallocated，always remember to free return 0; &#125; // Upper the first Character valgrind: prog that check memory mistake garbage values matter of scope “{ }” passing by reference void swap( int* a , int* b)&#123; int temp = *a; *a = *b; *b = temp &#125; File I/O //program for file writing --phonebook #include &lt;cs50.h> #include &lt;stdio.h> #include &lt;string.h> int main(void) &#123; FILE *file = fopen(\"phonebook.csv\", \"a\"); if (file == NULL)&#123; return 1; &#125; char *name = get_string(\"Name: \"); char *number = get_string(\"Number: \"); fprintf(file, \"%s,%s\\n,name,number\"); fclose(file); &#125; //program for file copy #include &lt;stdio.h> #include &lt;stdint.h> typedef uint8_t BYTE; int main(int argc, char *argv[]) // use command line &#123; FILE *src = fopen(argv[1], \"rb\"); FILE *dst = fopen(argv[2], \"wb\"); BYTE b; while (fread(&amp;b, sizeof(b), 1, src) != 0)&#123; fwrite(&amp;b, sizeof(b), 1, dst); &#125; fclose(dst); fclose(src); &#125; &nbsp; Lecture 5 Data Structures abstract data types queues: FIFO (enqueue &amp; dequeue) stacks: LIFO (like email systems, push &amp; pop) //prog for dynamic memory allocate without linked list #include &lt;stdio.h> #include &lt;stdlib.h> int main(void) &#123; int *list = malloc(3 * sizeof(int)); if (list == NULL)&#123; return 1; &#125; // if more space is needed to be allocated dynamicly int *tmp = malloc(4 * sizeof(int)); if (tmp == NULL)&#123; // free the original memory free(list); return 1; &#125; for (int i = 0; i &lt; 3; i++)&#123; tmp[i] = list[i]; &#125; tmp[3] = 4; // free the original memory free(list); // reorientation list = tmp; &#125; linked list //template typedef struct node &#123; int number; struct node *next; &#125; node; //create a linked list with one node node *list = NULL; node *n = malloc(sizeof(node)); n -> number = 1; //(*n).number = 1; n -> next = NULL; list = n; // enter a linked list and print #include &lt;stdio.h> #include &lt;stdlib.h> typedef struct node&#123; int number; struct node *next; &#125; node; int main (int argc, char *argv[]) &#123; node *list = NULL; for (int i = 1; i &lt; argc; i++)&#123; int number = atoi(argv[i]); node *n = malloc(sizeof(node)); if(n == NULL)&#123; //Free memory thus far return 1; &#125; n->number = number; n->next = list; list = n; &#125; //print whole list node *ptr = list; while (ptr != NULL)&#123; printf(\"%i\\n\",ptr->number); ptr = ptr->next; &#125; &#125; adding nodes： $ O(1) $ searching nodes： $ O(n) $ // enter a reverse linked list and print #include &lt;stdio.h> #include &lt;stdlib.h> typedef struct node&#123; int number; struct node *next; &#125; node; int main (int argc, char *argv[]) &#123; node *list = NULL; for (int i = 1; i &lt; argc; i++)&#123; int number = atoi(argv[i]); node *n = malloc(sizeof(node)); if(n == NULL)&#123; //Free memory thus far return 1; &#125; n->number = number; n->next = NULL; //if list is empty if (list == NULL )&#123; list = n; &#125; else&#123; for (node *ptr = list; ptr != NULL ; ptr = ptr->next)&#123; if(ptr->next == NULL)&#123; ptr->next = n; break; &#125; &#125; &#125; &#125; //print whole list node *ptr = list; while (ptr != NULL)&#123; printf(\"%i\\n\",ptr->number); ptr = ptr->next; &#125; &#125; adding nodes： $ O(n) $ // enter a sequenced linked list #include &lt;stdio.h> #include &lt;stdlib.h> typedef struct node&#123; int number; struct node *next; &#125; node; int main (int argc, char *argv[]) &#123; node *list = NULL; for (int i = 1; i &lt; argc; i++)&#123; int number = atoi(argv[i]); node *n = malloc(sizeof(node)); if(n == NULL)&#123; //Free memory thus far return 1; &#125; n->number = number; n->next = NULL; //if list is empty if (list == NULL )&#123; list = n; &#125; // if number belongs at beginning of the list else if (n->number &lt; list->number)&#123; n->next = list; list = n; &#125; // if number belongs later of the list else&#123; for (node *ptr = list; ptr != NULL ; ptr = ptr->next)&#123; // at end if(ptr->next == NULL)&#123; ptr->next = n; break; &#125; //in middle if (n->number &lt; ptr->next->number)&#123; n->next = ptr->next; ptr->next = n; break; &#125; &#125; &#125; &#125; //print whole list node *ptr = list; while (ptr != NULL)&#123; printf(\"%i\\n\",ptr->number); ptr = ptr->next; &#125; &#125; adding nodes： $ O(n) $ trees binary search trees typedef struct node&#123; int number; struct node *left; struct node *right; &#125; node; searching nodes： $ O(logn) $ dictionaries hashing : mapping objects into finite number of outputs hashing function hash tables: array of linked lists collision expectation $ O(n/k) - O(n) $ tries: a tree of arrays $ O(k)- O(1)$ &nbsp; Lecture 6 Python, Artificial Intelligence Python manages your memory automatically. It may take more memory than C. # python version of hash table in Problem set 5 words = set() def check(word): return word.lower() in words def load(dictionary): with open(dictionary) as file: words.update(file.read().splitlines()) return True def size(): return len(words) def unload(); return True Python has greater ecosystem for developers, basically more libs. Example: Face detection common IO syntax, you don’t have to specify the type of your variables answer = input(\"input:\") print(\"output, \" + answer) print(\"output,\", answer) print(f\"output,&#123;answer&#125;\") #type: bool float int str list set ... intent matters object oriented program(OOP): s = input(\"opinion: \") s = s.lower() # s = input(\"opinion: \").lower() if s in [\"y\",\"yes\"]: print(\"agreed\", end = \"\") elif s in [\"n\",\"no\"]: print(\"not agreed\") #loop for _ in range(3): print(\"test\") #function exception def get_int(prompt): while True: try: return int(input(prompt)) except ValueError: print(\"not an integer\") #for loop can end with an else people = [ &#123;\"name\":\"carter1\",\"number\":\"+1-555-986-1004\"&#125; &#123;\"name\":\"carter2\",\"number\":\"+1-555-986-1004\"&#125; &#123;\"name\":\"carter3\",\"number\":\"+1-555-986-1004\"&#125; ] name = input(\"Name: \") for person in people: if person[\"name\"] == name: number = person[\"number\"] print(f\"Found &#123;number&#125;\") break else: print(\"Not found\") the Artificial Intelligence part is more “introductory” and basic for learning prompt engineering minimax behavior machine learning reinforce learning (in robotics) explore vs exploit. deep learning generative artificial intelligence(large language models\\transformer\\attention values) &nbsp; Lecture 7 SQL SQL: a database-centric language (Structured Query Language) flat file database example: csv #csv example import csv with open(\"favorites.csv\",\"r\") as file: reader = csv.DictReader(file) counts = &#123;&#125; for row in reader: favorite = row[\"language\"] if favorite in counts: counts[favorite] += 1 else: counts[favorite] = 1 for favorite in sorted(counts, key = counts.get): print(f\"&#123;favorite&#125;: &#123;counts[favorite]&#125;\") relational database: CRUD(create read update delete || insert drop) this lecture uses sqlite3, for mobile database. $ sqlite3 favorites.db sqlite&gt; .mode csv sqlite&gt; .import favorites.csv favorites --import csv to table sqlite&gt; .quit sqlite&gt; .schema --a sqlite command that shows the schema of the database sqlite&gt; SELECT * FROM favorites; --show entire content of the table sqlite&gt; SELECT language FROM favorites LIMIT 10; --show seletced content of the table sqlite&gt; SELECT COUNT(*) FROM favorites; --total count sqlite&gt; SELECT COUNT(DISTINCT(language)) FROM favorites; --type count sqlite&gt; SELECT COUNT(*) FROM favorites WHERE language &#x3D; &#39;C&#39;; sqlite&gt; SELECT COUNT(*) FROM favorites WHERE language &#x3D; &#39;C&#39; AND problem &#x3D; &#39;Hello, World&#39;; sqlite&gt; SELECT language, COUNT(*) FROM favorites GROUP BY language; --works as python code above sqlite&gt; INSERT INTO favotites(language, problem) VALUES(&#39;SQL&#39;, &#39;fiftyville&#39;); --appending a new row to table sqlite&gt; DELETE FROM favorites WHERE Timestamp IS NULL;--delete row sqlite&gt; UPDATE favorites SET language &#x3D; &#39;SQL&#39;, problem &#x3D; &#39;fiftyville&#39;;--update and now all content has been changed which can be justified by WHERE...(condition) link different tables together one-to-one: primary key &amp; foreign key -- IMDb example sqlite&gt; SELECT * FROM shows WHERE id IN ...&gt;(SELECT show_id FROM ratings WHERE rating &gt;&#x3D; 6.0) how to join two tables that have related keys? -- syntax &#39;JOIN&#39; sqlite&gt; SELECT * FROM shows JOIN ratings ON shows.id &#x3D; ratings.show_id WHERE rating&gt;&#x3D; 6.0 LIMIT 10; link different tables together: one-to-many ，many-to-many ​ just nested snytax. SQL injection attack just use placeholders and sanitize customer’s inputs &nbsp; Lecture 8 HTML, CSS, JavaScript routes &amp; packets；a pair of protocols: TCP/IP IPv4: #.#.#.# (0~255) 32 bits TCP: use sequence numbers to help servers multiplex, port numbers (80: HTTP 443: HTTPS) DNS (domain name system) servers domain name -&gt; IP address buy a domain name: pay someone(运营商) to associate an IP address with your domain name DHCP (dynamic host configuration protocol) 自动为设备分配地址 HTTP (hypertext transmit protocol) HTTPS (hypertext transmit protocol secure) Internet protocol that allows a web browser to request and receive information from a web server HTML: (hypertext marker language) a really easy language that you can learn in 30 minutes. VSCode makes it even more convenient. but it can take a lot of effort to make good websites. tags &amp; attributes: &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;!--html: tag lang = \"en\": attributes --> &lt;head> &lt;title> title &lt;/title> &lt;/head> &lt;body> body &lt;/body> &lt;/html> regular expressions: 正则表达式 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions you can change your local copy of html by using developer tools CSS: (Cascading Style Sheets) properties: example &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;title>title&lt;/title> &lt;/head> &lt;body style = \"text-align: center\"> &lt;p style = \"font-size: large\"> John Harvard &lt;/p> &lt;p style = \"font-size: medium\"> Welcome to my homepage &lt;/p> &lt;p style = \"font-size: small\"> Copyright &amp;#169; John Harvard &lt;/p> &lt;/body> &lt;/html> classes: your own style or style from third libraries &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;style> .centered&#123; text-align: center; &#125; .large&#123; font-size: large; &#125; .medium&#123; font-size: medium; &#125; .small&#123; font-size: small; &#125; &lt;/style> &lt;title>title&lt;/title> &lt;/head> &lt;body class = \"centered\"> &lt;head class = \"large\"> John Harvard &lt;/head> &lt;main class = \"medium\"> Welcome to my homepage &lt;/main> &lt;footer class = \"small\"> Copyright &amp;#169; John Harvard &lt;/footer> &lt;/body> &lt;/html> ​ 样式可使用外链 ​ #+… : ID JavaScript &nbsp; Lecture 9 Flask flask a python third party library for web microframework linking static(html) &amp; dynamic(python) files. We use the syntax “JINJA” to customize and formalize the outlook of the web. Following the lecture I made a simple web application to greet users, the GitHub link is https://github.com/miustannis/flask-greeting-web.git more web app examples There two other web examples for sports register and library system, which are more realistic with more functions and more html files. Data can be managed in a better way using SQL, other than just in SRAM. cookies tools that websites use to keep staying stateful. Server needs to remember something about the user, cookies will be sent back to server by browsers every time a user log in. problems: cookies may be used for ads and tracking. &nbsp; Lecture 10 Cybersecurity passwords brute-force attack two-factor authentication (mostly hardware equipment) one-time passwords server uses hash function to compare passwords cryptography: public key &amp; private key (HTTPS) passkeys: generate public key and send it to the company, and a private one for verifying your signature combining the public key. secure deletion -&gt; full disk encryption *看此课程以温习basic coding和补充一些计算机思维，老师讲的很有激情，时间花的还算比较有价值 ______ | see you | ====== \\ \\ \\ \\ / \\\\ //\\\\ |\\\\___/| / \\\\// \\\\\\\\ /0 0 \\\\__ / // | \\\\ \\\\ / / \\\\/_/ // | \\\\ \\\\ \\@_^_\\@'/ \\\\/_ // | \\\\ \\\\ //_^_/ \\\\/_ // | \\\\ \\\\ ( //) | \\\\/// | \\\\ \\\\ ( / /) _|_ / ) // | \\\\ _\\\\ ( // /) '/,_ _ _/ ( ; -. | _ _\\\\.-~ .-~~~^-. (( / / )) ,-&#123; _ `-.|.-~-. .~ `. (( // / )) '/\\\\ / ~-. _ .-~ .-~^-. \\\\ (( /// )) `. &#123; &#125; / \\\\ \\\\ (( / )) .----~-.\\\\ \\\\-' .~ \\\\ `. \\\\^-. ///.----..> \\\\ _ -~ `. ^-` ^-_ ///-._ _ _ _ _ _ _&#125;^ - - - - ~ ~-- ,.-~ /.-~","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://miustannis.github.io/tags/CS/"}]},{"title":"基于MLX90640的手持红外热成像仪","slug":"250226","date":"2025-02-26T02:05:52.000Z","updated":"2025-08-20T04:15:07.445Z","comments":true,"path":"2025/02/26/250226/","link":"","permalink":"https://miustannis.github.io/2025/02/26/250226/","excerpt":"","text":"项目背景： DIY好玩捏 电路工作时有时需要检查元件发热情况，但用手触摸元件有一定的风险，因此需要一种无接触式的多点测温设备 于是开始了解到热成像这个测温方式，以下是软硬件方案 方案：硬件部分​ 采用上下两块板子对插组合，为了减少复杂度，留了排母方便直插LCD与传感器模组。 BOARD1: MCU与外设 采用STM32F407作为主控，512KB Flash，其实没特别注意选型，只是手上有这个开发板，要压缩成本的话用其他型号也可以 红外传感模组为MLX90640 BAA，这个价格比较贵，比其他元件加起来都贵 屏幕模组为1.44寸TFT-LCD，也是现成的，买了俩还剩一个，下次做别的东西的时候给用了吧 留了串口测试点和烧录测试点 BOARD2: POWER 3.7V锂电池供电，可通过USB接口经过LGS4084H电源管理芯片给锂电池充电 经过一个LDO稳到3.3V给MCU整体供电，VDDA和VCC用磁珠滤波隔离了一下 电源板后续涉及锂电池供电DIY的倒是可以继续沿用 立创打样PCB，自己贴片，PCB板框留了一些M3螺孔方便组装。 软件部分通讯接口涉及IIC与SPI，以及图像测试的时候用了一下UART，均比较基础。使用硬件IIC进行传感器模组与MCU间的通信，模组官方提供了接口可调用，可读取温度值。RGB转换用了开源的函数： /*pass in value and figure out R G B several published ways to do this I basically graphed R G B and developed simple linear equations again a 5-6-5 color display will not need accurate temp to R G B color calculation equations based on http://web-tech.ga-usa.com/2012/05/creating-a-custom-hot-to-cold-temperature-color-gradient-for-use-with-rrdtool/index.html */ static uint16_t TempToColor(float val)&#123; red = constrain(255.0f / (c - b) * val - ((b * 255.0f) / (c - b)), 0, 255); if ((val > minTemp) &amp; (val &lt; a)) &#123; green = constrain(255.0f / (a - minTemp) * val - (255.0f * minTemp) / (a - minTemp), 0, 255); &#125; else if ((val >= a) &amp; (val &lt;= c)) &#123; green = 255; &#125; else if (val > c) &#123; green = constrain(255.0f / (c - d) * val - (d * 255.0f) / (c - d), 0, 255); &#125; else if ((val > d) | (val &lt; a)) &#123; green = 0; &#125; if (val &lt;= b) &#123; blue = constrain(255.0f / (a - b) * val - (255.0f * b) / (a - b), 0, 255); &#125; else if ((val > b) &amp; (val &lt;= d)) &#123; blue = 0; &#125; else if (val > d) &#123; blue = constrain(240.0f / (maxTemp - d) * val - (d * 240.0f) / (maxTemp - d), 0, 240); &#125; // use the displays color mapping function to get 5-6-5 color palet (R=5 bits, G=6 bits, B-5 bits) return BSP_LCD_GetColor565(red, green, blue); &#125; 该传感器成图32x24像素，而使用的LCD是128x128的，于是我用4个像素作为一个大像素来填充，并增加了一个图例和一个最大最小值来提供量化，并填充一下屏幕留白 static void drawPicture(void) &#123; uint8_t cell_size = 4; // 格子大小 4x4 uint8_t start_x = 0; // 水平居中（128 - 32*4 = 0） uint8_t start_y = 16; // 垂直居中（(128 - 24*4)/2 = 16） for (y = 0; y &lt; 24; y++) &#123; for (x = 0; x &lt; 32; x++) &#123; ST7735_FillRectangle( start_x + x * cell_size, start_y + (23 - y) * cell_size, cell_size, cell_size, TempToColor(tempValues[(31- x) + (y * 32)]) ); &#125; &#125; &#125; static void drawLegend(void) &#123; uint8_t legend_height = 5; // 图例高度（像素） uint8_t legend_y = 0; // 图例顶部位置（y=0） uint8_t legend_width = 120; // 图例宽度（留左右边距） uint8_t start_x = 4; // 图例左侧起始位置（x=4） // 绘制温度颜色渐变条（水平方向） float temp_range = maxTemp - minTemp; for (uint8_t x = 0; x &lt; legend_width; x++) &#123; float temp = minTemp + temp_range * (x / (float)legend_width); uint16_t color = TempToColor(temp); // 绘制水平线（从左到右） ST7735_DrawLine(start_x + x, legend_y, start_x + x, legend_y + legend_height, color); &#125; // 显示最小/最大温度标签 // memset(tempBuffer, 0, sizeof(tempBuffer)); sprintf(tempBuffer, \"&lt;%2.1f \", minTemp); ST7735_WriteString(2, 115, tempBuffer, Font_7x10, ST7735_WHITE, ST7735_BLACK); //// memset(tempBuffer, 0, sizeof(tempBuffer)); sprintf(tempBuffer, \"%2.1f> \", maxTemp); ST7735_WriteString(90, 115, tempBuffer, Font_7x10, ST7735_WHITE, ST7735_BLACK); &#125; 最后在主循环里轮询就可以了，屏幕刷新率一般，眨眼补帧。 整体软件部分比较清晰，本来想加一些按键交互，修改颜色范围，存储图片到外部flash之类的功能，然后懒了。 后续学了操作系统和LVGL库之后再搞点好玩的吧，感觉大部分DIY应用裸机完全够了… 小问题合集：problem1：使用ST-Link下载过一次程序后发现无法继续下载 检查设备管理器，确保有正确的ST-Link驱动 检查Keil软件配置，确保导入正确的型号版本 检查引脚配置，发现问题： ​ 配置的IIC通信引脚占用了SWD下载引脚（STM32默认的PA13 &amp;PA14），引脚输入输出模式不适配，显然后续无法下载，遂改之，问题解决。（图示仅供参考） problem2：HardFault中断触发栈空间不足，多分配点就ok","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"Xiaomi路由器BE3600快速救砖","slug":"250213","date":"2025-02-13T10:25:24.000Z","updated":"2025-08-22T15:43:45.354Z","comments":true,"path":"2025/02/13/250213/","link":"","permalink":"https://miustannis.github.io/2025/02/13/250213/","excerpt":"","text":"家里的路由器变砖了（具体原因不清楚） 指示灯由蓝色常亮变成橙色常亮，对于家用路由器这种消费电子产品，一般重启一下能解决90%的故障 但心血来潮想试一下给它刷个机 型号是这个： 刷机需要一根网线，PC，以及变砖的路由器 步骤如下： 在网址MiWiFi中找到刷机软件与对应型号的ROM固件 关闭PC的防火墙，将网线连接至路由器的LAN口，本型号WAN与LAN口二合一了,随便找个口插上就行 打开刷机软件并载入对应的固件 用工具按住路由器的reset键后通电源，这一步非常像之前给单片机内部flash进行ISP下载程序的步骤，因此感觉很熟悉 待指示灯闪烁后松开reset键，固件开始下载 路由器变为蓝灯闪烁，此时已经刷机完成，当新路由器用就行","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"STM32配置笔记","slug":"241121","date":"2024-11-21T10:45:34.000Z","updated":"2025-08-19T15:37:52.826Z","comments":true,"path":"2024/11/21/241121/","link":"","permalink":"https://miustannis.github.io/2024/11/21/241121/","excerpt":"大二学习STM32G4系列的笔记","text":"大二学习STM32G4系列的笔记 pdf嵌入使用了pdf.js插件，hexo-pdf这个插件在移动端不能很好地显示","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"UART收发处理函数","slug":"241020","date":"2024-10-20T02:51:00.000Z","updated":"2025-08-19T15:35:37.729Z","comments":true,"path":"2024/10/20/241020/","link":"","permalink":"https://miustannis.github.io/2024/10/20/241020/","excerpt":"","text":"UART（Universal Asynchronous Receiver/Transmitter）是一种串行通信协议，在嵌入式系统和微控制器间数据传输中发挥着核心作用。UART协议通过异步方式传输数据，不依赖于共享时钟信号，简化了通信线路的需求。每次传输包括起始位、数据位、可选的奇偶校验位以及停止位，这种结构支持从简单的传感器到复杂的处理器之间的可靠数据交换。 其重要性还体现在其广泛的兼容性和低成本实现上。它可以通过简单的两线（TX和RX）接口实现全双工通信，极大地降低了系统的硬件复杂性。此外，UART通信协议可以适应不同的波特率设置，使其能够灵活地调整以匹配特定应用的速度要求。在许多工业和消费电子产品中，UART仍然是实现可靠串行通信的首选技术，尤其在资源受限的环境中显示出其高效和经济的优势。（以上均为GPT生成） 在进行传感器测试时，常用到UART，这里mark一下自己常用的HAL库函数封装，免得后续一直翻之前的程序 函数需要用到的全局变量如下： char send[20] = &#123;0&#125;; //传输用字符数组，储存字符串 uint8_t rx_buffer = 0; //接收字符缓冲区 char rx_receiver[20] = &#123;0&#125;; //接收用字符数组 uint8_t rx_num = 0; //接收字符数量 uint8_t uart_start_flag = 0; //接收标志位 __IO uint32_t uart_gettick = 0; //系统时钟比较变量 /* 测试变量 uint16_t pwm_duty = 0; uint8_t startbegin = 0xff; uint8_t startbegin2 = 0x00; */ 在硬件配置时要打开UART中断： HAL_UART_Receive_IT(&amp;huart1 , &amp;rx_buffer, 1); 中断回调函数如下： void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) &#123; if(rx_num == 0)&#123; uart_gettick = uwTick; uart_start_flag = 1; &#125; if(uart_start_flag == 1)&#123; rx_receiver[rx_num] = rx_buffer; rx_num++; &#125; HAL_UART_Receive_IT(&amp;huart1 , &amp;rx_buffer, 1); &#125; 主循环中的处理函数如下： void UART_RX_PROC(void) &#123; if((( uwTick- uart_gettick ) >=10) &amp;&amp; (( uwTick- uart_gettick ) &lt;=600) &amp;&amp; (uart_start_flag == 1))&#123; if(rx_receiver[0] == '&amp;' )&#123; if( rx_num == 2) &#123; //示例：传输pwm占空比 pwm_duty = rx_receiver[1]-'0'; &#125; else if( rx_num == 3)&#123; pwm_duty = (rx_receiver[1]-'0')*10 + rx_receiver[2]-'0'; &#125; else if( rx_num == 4)&#123; pwm_duty = (rx_receiver[1]-'0')*100 + (rx_receiver[2]-'0')*10 + rx_receiver[3]-'0'; &#125; else if ( rx_num >= 5)&#123; pwm_duty = 1000; &#125; &#125; HAL_UART_Transmit(&amp;huart1, &amp;startbegin, 1,0xffff); HAL_UART_Transmit(&amp;huart1, &amp;startbegin2, 1,0xffff); HAL_UART_Transmit(&amp;huart1, &amp;startbegin, 1,0xffff); rx_num = 0; uart_start_flag = 0; &#125; &#125; 这里的函数主要是用以处理字符串的，应付一些的简单的应用已经够用了，当然，也能在此基础上扩展。","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"TFTLCD驱动","slug":"240928","date":"2024-09-28T06:00:30.000Z","updated":"2025-08-19T15:35:47.906Z","comments":true,"path":"2024/09/28/240928/","link":"","permalink":"https://miustannis.github.io/2024/09/28/240928/","excerpt":"","text":"在使用Img2LCD取模软件和ST7735S驱动IC控制LCD时，发现API中显示图片的函数调用后显示异常 原函数： void ST7735_DrawImage(uint16_t x, uint16_t y, uint16_t w, uint16_t h, const uint16_t* data) &#123; if((x >= ST7735_WIDTH) || (y >= ST7735_HEIGHT)) return; if((x + w - 1) >= ST7735_WIDTH) return; if((y + h - 1) >= ST7735_HEIGHT) return; ST7735_Select(); ST7735_SetAddressWindow(x, y, x+w-1, y+h-1); ST7735_WriteData((uint8_t*)data, sizeof(uint16_t)*w*h); ST7735_Unselect(); &#125; 输入数据要求16位rgb565格式图片，与Img2LCD取模软件两个8位数表示一个像素点的编码逻辑不同，首次修改仅改了原函数输入数据的格式：将data16位常量数据指针类型改为8位无符号变量指针类型，且在spi写入数据时将数据量乘以2，修改后的函数如下： void ST7735_DrawImage8bit_Img2LCD(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t* data) &#123; if((x >= ST7735_WIDTH) || (y >= ST7735_HEIGHT)) return; if((x + w - 1) >= ST7735_WIDTH) return; if((y + h - 1) >= ST7735_HEIGHT) return; ST7735_Select(); ST7735_SetAddressWindow(x, y, x+w-1, y+h-1); ST7735_WriteData((uint8_t*)data, sizeof(uint8_t)*w*h*2); ST7735_Unselect(); &#125; 但是烧录测试后LCD显示颜色异常且边缘模糊，初步推测是图片数据原本的问题，考虑到可能2个8位数据合并时高8位与低8位的顺序反了，在MATLAB中进行数组元素两两翻转验证： function swappedArray = swapPairs(inputArray) if iscolumn(inputArray) inputArray = inputArray'; end n = length(inputArray); if mod(n, 2) ~= 0 inputArray(end+1) = NaN; end swappedArray = inputArray; swappedArray(1:2:end) = inputArray(2:2:end); swappedArray(2:2:end) = inputArray(1:2:end); swappedArray = swappedArray(~isnan(swappedArray)); end 将原始图片数据处理后再进行烧录，发现显示正常，问题定位到数组元素的写入顺序，解决方法较多，这里我直接在函数中将原始数组变换，最终的函数如下： void ST7735_DrawImage8bit_Img2LCD(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t* data) &#123; uint32_t i = 0; uint8_t temp = 0; if((x >= ST7735_WIDTH) || (y >= ST7735_HEIGHT)) return; if((x + w - 1) >= ST7735_WIDTH) return; if((y + h - 1) >= ST7735_HEIGHT) return; /* Swap adjacent elements in the data array */ for ( i = 0; i &lt; w * h * 2; i += 2) &#123; if (i + 1 &lt; w * h * 2) &#123; temp = data[i]; data[i] = data[i + 1]; data[i + 1] = temp; &#125; &#125; ST7735_Select(); ST7735_SetAddressWindow(x, y, x+w-1, y+h-1); ST7735_WriteData((uint8_t*)data, sizeof(uint8_t)*w*h*2); ST7735_Unselect(); &#125; 看看显示效果：","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"Hexo博客插入图片","slug":"220321","date":"2022-03-21T01:32:46.000Z","updated":"2025-08-20T04:15:43.851Z","comments":true,"path":"2022/03/21/220321/","link":"","permalink":"https://miustannis.github.io/2022/03/21/220321/","excerpt":"","text":"目录： 插入图片 更改相对位置 插入图片之前打算在文章中插入图片，配置的过程中遇到了一些问题。 想在博客中引用外站图片问题不大，但Hexo默认插入图片只有这一个方法，对有本地化需求的人群来说不够方便，此时可以安装一个满足本地图片引用的插件，在国内某知名（c）专业（s）开发者（d）社区（n）里提供的90%的方案为以下命令：npm install hexo-asset-image –save该论坛上相互借鉴蔚然成风的壮景对我这个刚入门的小白真是非常险恶，此指令安装版本落后，无法有效显示图片，有效的版本安装命令如下：npm install https://github.com/CodeFalling/hexo-asset-image –save 修改_config.yml文件，将post_asset_folder:值改为true。 之后在新建一个博客的同时会生成同名文件夹，将需插入的图片放入该文件夹即可。文章中的具体引用代码为以下格式：(后来发现在source文件夹里新建一个名为images的文件夹存放图片也行)![](1/image.jpg) 更改相对位置但这种方法在PC端有一个默认的问题就是图片插入后会自动左对齐，想要实现居中对齐，可以在markdown引用代码外部添加center元素，或者直接添加html元素，如下所示：&lt;center> ![...](xxx) &lt;/center> &lt;!--or --> &lt;div align=center> ![...](xxx) &lt;/div>(因为我用VScode来打开博客的md文件进行编辑，在上传至本地网页时一开始发现图片无法加载，后来排查得出居中命令代码间的空行是必要的，不知道其他编辑器是否有这样的问题。) 还可以直接修改css文件，因为markdown插入图片的代码在最终渲染的时候变为html中的img元素。因此可以直接去博客主题文件的源代码中，找到控制文章内图片显示样式的css代码，将其修改成水平居中即可。前端编程中修改水平居中的方法非常多，以下是网上资源中提供的其中一种： 一般情况下可以在Hexo博客文件夹进入到主题模板的themes-&gt;(主题名称文件夹)-&gt;source-&gt;css-&gt;_partial中，找到post.styl文件，该post文件中保存的就是文章详情页里面的显示样式。然后找到里面正确的img元素，修改其样式，增加margin 0 auto这行指令。如下:.post-content position relative color c-666 img max-width 100% cursor pointer display block margin 0 auto然后可以实现了。但我在自己当前使用的主题中并没有找到相关语段，由于技术比较拉跨，我决定还是先老实用前两种吧。 [后期补丁：你需要一款名为Typora的markdown编辑软件]","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://miustannis.github.io/tags/Hexo/"}]},{"title":"Hexo博客启用测试","slug":"220314","date":"2022-03-14T07:08:39.000Z","updated":"2025-08-20T04:15:33.915Z","comments":true,"path":"2022/03/14/220314/","link":"","permalink":"https://miustannis.github.io/2022/03/14/220314/","excerpt":"","text":"test 测试 試験 テスト","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://miustannis.github.io/tags/Hexo/"}]}],"categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"},{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://miustannis.github.io/tags/CS/"},{"name":"Linux","slug":"Linux","permalink":"https://miustannis.github.io/tags/Linux/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://miustannis.github.io/tags/Algorithm/"},{"name":"Android","slug":"Android","permalink":"https://miustannis.github.io/tags/Android/"},{"name":"图像处理","slug":"图像处理","permalink":"https://miustannis.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"Hexo","slug":"Hexo","permalink":"https://miustannis.github.io/tags/Hexo/"}]}