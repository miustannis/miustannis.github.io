{"meta":{"title":"Miao's Blog","subtitle":null,"description":"","author":"miao","url":"https://miustannis.github.io","root":"/"},"pages":[{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2024-08-31T13:23:24.772Z","comments":true,"path":"404/index.html","permalink":"https://miustannis.github.io/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-04-01T03:49:27.000Z","updated":"2024-08-31T13:32:40.374Z","comments":true,"path":"categories/index.html","permalink":"https://miustannis.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2022-03-23T16:01:54.000Z","updated":"2025-05-10T02:49:33.093Z","comments":true,"path":"about/index.html","permalink":"https://miustannis.github.io/about/index.html","excerpt":"","text":"Education：B.Eng. Electrical Engineering and Automation Soochow University Hobbies：STEM ( Math | Engineering ) ART ( Music | Painting | Movies | Video Games ) DIY ( Model Crafting | Electronic Products ) Current Goals：Dedicated to interdisciplinary research in wearable devices and embodied intelligence. Get an Ph.D. in HCI, AIot or fields alike publish 5 papers write a song by myself Reasons why I start blogging：LIFE NOTES: to record daily life TECH/STUDY NOTES: to discipline myself with Feynman Technique PROJ NOTES: to check learning progress and to provide a sense of fulfillment"},{"title":"tags","date":"2024-08-31T13:20:15.000Z","updated":"2024-08-31T13:20:27.842Z","comments":true,"path":"tags/index.html","permalink":"https://miustannis.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"冈萨雷斯 《数字图像处理》Study Log (2) 空间域与频域滤波","slug":"250512","date":"2025-04-20T03:38:44.000Z","updated":"2025-05-12T08:59:06.549Z","comments":true,"path":"2025/04/20/250512/","link":"","permalink":"https://miustannis.github.io/2025/04/20/250512/","excerpt":"","text":"Ch3 空间域图像增强定义：直接作用于像素的增强方法，根据具体操作是在像素点位置上还是像素点的邻域上可分为点操作和模板操作（邻域操作） 灰度映射通过映射函数:$ t= T(s)$（可根据增强的目的来设计映射函数）将原始图像中的每个像素的灰度都映射到新的灰度。 图像求反（负片）一一对应 幂次变换$t= cs^{γ}$ $γ&lt;1$时在正比函数上方，使得图像变亮，把输入窄带暗值映射到宽带输出； $γ&gt;1$时在正比函数下方，使得图像变暗，把输入窄带亮值映射到宽带输出。 动态范围压缩由于某些设备的局限性，采用动态范围压缩，目标与增强图片的对比度相反（同等范围的原始灰度级数变换后范围变化减小） 阶梯量化将图像灰度分范围量化，变成数据量较少的级数，获得数据量压缩的效果（有点像素化风格） 灰度切分/阈值切分只留下两个灰度值，获得最大的对比度以及最少的细节 *分段变换： 位平面切片以256灰度级图像为例，该图像的灰度级可以用8位表示。可假设图像是由8个1位平面组成，即位平面0~7，其中位平面0包含图像中像素的最低位，位平面7包含像素的最高位。 较高位(前4位)包含大多数视觉重要数据。较低位(后4位)包含对微小细节重要的数据，位平面切片可以分析每一位在图像中的相对重要性。 &nbsp; 图像运算（逐像素进行）算术运算（一般用于灰度图像）代数运算加法：$C(x,y) = A(x,y) + B(x,y)$ 应用场景：1. 去除叠加性噪声（图像均值化将降低噪声的影响）2. 生成图像叠加效果 减法：$C(x,y) = A(x,y) - B(x,y)$ 应用场景：1. 显示两幅图之间的差异，如视频中的镜头边界的检测 2. 去除不需要的叠加性图案（gb\\bb剪辑） 3. 图像分割 乘法：$C(x,y) = A(x,y) * B(x,y)$ 应用场景：局部显示——用二值蒙版图像与原图像做乘法 逻辑运算与、或、异或、非 部分运算方法与加减法有类似的地方 非：$g(x,y) = 255 - f(x,y)$ 可获得一个负片图像（补图像） *负片： 灰度图像公式如上；RGB图像需要分别进行非运算；非线性色域需要先进行线性校正后再对不同通道分别校正 与：$g(x,y) = h(x,y) ∧ f(x,y)$ ；或：$g(x,y) = h(x,y) Ｖ f(x,y)$ 可以提取相交子图或合并子图像 &nbsp; 直方图变换灰度直方图是关于灰度级的离散函数，描述图像中各灰度级的像素个数，一般归一化后描述 直方图只能反映图像的灰度分布情况，不能反映图像像素的位置 一幅图对应唯一的灰度直方图 *高对比度的图像有更平坦的直方图，对于图像分割，识别领域，一幅图像应该利用全部或者几乎全部可能的灰度级 应用： 利用直方图分布进行阈值分割，如果某灰度图像的灰度直方图有两个明显的尖峰，取两个尖峰之间的谷点作为分割点，可以得到较好的二值处理的效果 直方图均衡化，通过将像素个数多的灰度级进行展宽，对像素个数少的灰度级进行缩减，将原始图像的直方图变为均衡分布的形式，由于各灰度之间有均匀的概率分布，图像看起来可以更清晰 *直方图均衡化方法： 为使得图像的直方图均衡化，同时保持灰度值的单调性和范围不变，构造的灰度变换函数$ t= T(s)$需要满足以下两个条件： $T(s)$是单调递增函数，且$0≤T(s)≤1$：保证变换后的灰度值保持从黑到白的变换顺序，避免灰度值反转，保证变换后的灰度值在0~1的范围内（归一化后） 原始图像的累积分布函数(CDF，即概率密度曲线包围的面积)可满足以上条件 $t = T(s) = \\int_{0}^{s}p_{s}(w)dw$ $p(s)$是s的概率密度函数 $T^{-1}(s)$存在且单调递增，允许均衡化后的灰度值t反向映射回原始灰度值，反函数单调递增可以保证反向映射时仍然保持灰度顺序不变，避免引入新的非线性失真 $T(s)$是CDF，其反函数可以通过查找或者数值方式求得 因为数字图像处理是离散化的，因此需要对上述方法离散化： 设一幅图像的像素总数为n，分L个灰度级，其中第k个灰度级出现的概率为$P(s_{k}) = n_{k}/n$，其中$0≤s_k≤1,k = 0,1,2,…L-1$. 离散CDF为$T(s_k) = \\sum_{j=0}^{k} n_j/n$ 算法步骤： 计算每个灰度级的像素个数在整个图像中所占的概率 计算每个灰度级的离散CDF 根据变换后的$t_{k}$的值判断变换后的灰度级（区间拟合，比如round()） 拟合后会合并部分灰度级，宏观上对灰度级分布均衡化，微观上不可能拉平，灰度级层次减少，对比度提高 这种方法使得原本集中在狭窄区间的像素值变换到更广的范围内，增加了像素灰度值的有效动态范围 优点：自动得到近似均匀分布的直方图，但由于变换函数采用CDF，只能近似，因此在一些有特定需求的场景下采用直方图规定化方法 &nbsp; *直方图规定化方法：将原始直方图转换为期望直方图 算法步骤： 对原始图像进行灰度均衡化（按照上述直方图均衡化方法） 计算目标直方图的离散CDF 将原始直方图映射到目标直方图 映射规则： 单映射规则（灰度级一一对应） &amp; 组映射规则（灰度级分组后平均后对应，效果好） &nbsp; 镜头边界的检测定义：一个镜头指一系列连续记录的图像帧，用于表示一个时间段或者相同地点连续的动作 镜头边界的检测即检测由镜头切换而产生的关键帧 方法： 两幅图图像相减（检测像素变化的数目是否超过阈值）可通过滤波降低对摄像机运动敏感的问题影响 连续帧的直方图相减（统计相邻两帧中所有像素在不同灰度上的分布差异之和是否超过阈值）对目标的空间变化不敏感 时空切片分析（颜色和纹理的不连续） &nbsp; 空间平滑滤波增强","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://miustannis.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"https://miustannis.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"冈萨雷斯 《数字图像处理》Study Log (1) 图像技术基础","slug":"250328","date":"2025-03-28T03:38:44.000Z","updated":"2025-05-12T03:16:32.941Z","comments":true,"path":"2025/03/28/250328/","link":"","permalink":"https://miustannis.github.io/2025/03/28/250328/","excerpt":"","text":"Ch1 数字图像的概念观察系统使用的光波段：可见光、红外、射线、微波、超声波等 视觉在人类获取信息来源中占70% 图：反射光或者透射光的分布，或物体自身发出的能量—客观 像：人的视觉系统对图的接收在大脑中形成的印象或认识—主观 图像处理：是对图像信息进行加工处理，以满足人的视觉心理和实际应用的需求。包括光学和电子学两种方法 图像分类：模拟图像 &amp; 数字图像 模拟图像：理论上不存在，即使高密度胶片成像也无法称为模拟图像，个人认为可将人眼获得的像近似为模拟图像 数字图像： 由连续的模拟图像通过采样和量化得到。数字图像的基本单位是像素，所以数字图像是像素的集合 数字图像是以像素为元素的矩阵，像素的值代表图像在该位置的亮度/色度，称为图像的灰度值/色度值 数字图像像素具有整数坐标与整数灰度值 数字图像处理的基本特点： 信息量大 占用频带宽：电视图像的带宽为5~6MHz（细节越多，画质越高带宽越大，不过现代数字编码技术可以通过压缩方法，比如MPEG-4、H.265等方式大幅减少带宽需求），语音的带宽只有4kHz，频带越宽，技术实现难度就越大 数字图像处理的基本内容 （部分内容与图形学互为逆过程） 增强：改善质量 几何处理：平移、缩放、旋转、扭曲 复原重建：去噪、去模糊、重建原始图像 编码压缩：减少存储量和传输量 分割：区域分割和理解、目标表达和描述 理解：图像感知、解释、推理 应用场景：影视图像处理、医学影像处理、刑侦辅助 &nbsp; &nbsp; Ch2 图像技术基础图像 &amp; 像素图像—二维函数f(x,y)，其中x,y是空间坐标【空间上的离散化，即采样】，f(x,y)是该点的幅值【即量化】 图像类别 特征 黑白图像 二值 灰度图像 单分量，f(x,y)表示亮度 彩色图像 多分量，由3个或多个二维灰度函数f(x,y)组成（如RGB,HSV） 数字化过程 扫描：对一幅图像内给定位置进行寻址，将图像分割为矩形网络，即栅格化，扫描的最小单元为像素 采样：在一幅图像的每个像素位置上测量灰度值，由传感元件将光的亮度转化为电压值 量化：将测量的灰度值用整数来表示（ADC） ${f}_{i j}=\\left[\\begin{array}{cccc} f_{00} & f_{01} & \\cdots & f_{0*(N-1)} \\\\ f_{10} & f_{11} & \\cdots & f_{1*(N-1))} \\\\ \\vdots & \\vdots & \\cdots & \\vdots \\\\ f_{(N-1)*0} & f_{(N-1)*1} & \\cdots & f_{(N-1)*(N-1)} \\end{array}\\right] \\approx f(x, y)$ 像素的属性 大小：与空间分辨率有关，长采样间隔产生低的空间分辨率 灰度：与灰度分辨率有关 位深度：用来存放像素颜色值所用的位数：1/4/8/24（真彩） 灰度级：对应位深度，表示像素明暗程度的整数量，为$2^n$ 像素间的基本关系 neighbor 邻域：4-邻域；D-邻域；8-邻域 adjacency 连接性 ​ 两个像素连接的两个必要条件： 两个像素的位置邻接（按上述neighbor种类可划分为 4-连接、8-连接，以及m-连接） 两个像素的灰度值满足特定的相似性准则（值要在某一范围内近似相等） 特殊情况：*m-连接，包括两种情况（视觉上看不允许有三角阶梯形的连接图案） 4-连接 像素A∈像素B的D-邻域，且两个像素的4-邻域不包含同样值的像素 距离（像素A到像素B的路径，是不同像素的序列）可用定义连接的方法定义路径，其中m-连接所得的m-路径更适用于边缘提取。 connection 像素在图像子集中连通 两个像素在图像中能有一条完全由像素组成的路径，则两个像素连通，连接是连通的一种特殊情况 connected component 连通成分 对于图像中的任意像素A，图像中所有连接到A的像素的集合被称为图像的连通成分，同样可按连接方式划分 像素间的距离 欧几里得距离 p与q之间的欧几里得距离定义为： $De(p,q) = [(x-s)^2 + (y-t)^2]^{(1/2)}$ 对于图像来说计算量太大，一般不用。 D4距离/街区距离/城市距离 $D4(p,q) = |x-s| + |y-t|$ 区别于欧几里得距离（到某像素距离等于某个值的像素形成一个圆形），到某像素D4距离小于等于某个值的像素形成一个菱形 D8距离/棋盘距离：用于边缘提取时设置距离的阈值 $D8(p,q) =max(|x-s| , |y-t|) $ 如下图所示： 印刷品中的半调输出技术 节选自维基百科：半色调（Halftone）是指为了模拟出连续调影像（色阶）的视觉感觉，一般用墨点（半色调网点）的大小或频率的改变，来模拟明暗的变化。半色调技术是传统印刷中用来处理阶调并模拟连续调（continue tone）的方法，通常也称为过网（screening）技术。半色调是相对于连续调表示阶调的一种方法，一般我们所看到银盐相片上的影像是由连续的层次所构成，像这样的影像称之为连续调影像。相对而言，印刷机或打印机上所打印的图像，只能借由着墨或不着墨两种阶调来表现层次，像这样的两值化影像称为半色调影像。只要借由调整不同形式、不同大小的墨点，利用人眼可以将图像中邻近墨点进行视觉积分的原理，在一定的距离观察下，便可以使二值化影像重现连续调的感觉。也就是说，当这些墨点越小时，二值化影像就可以在越短的观测距离下，被人眼观测积分成近似连续调的影像。 图像坐标变换可借助矩阵写为 $\\boldsymbol{v}^{\\prime}=\\boldsymbol{A} \\boldsymbol{v}$ 其中A为变换矩阵，v‘为变换后的坐标矢量，v为变换前的坐标矢量 平移变换 $\\boldsymbol{T}=\\left[\\begin{array}{ccc} 1 & 0 & x_{0} \\\\ 0 & 1 & y_{0} \\\\ 0 & 0 & 1 \\end{array}\\right]$ 尺度变换 $\\boldsymbol{S}=\\left[\\begin{array}{ccc} S_{x} & 0 & 0 \\\\ 0 & S_{y} & 0 \\\\ 0 & 0 & 1 \\end{array}\\right]$ 旋转变换 $\\boldsymbol{R}=\\left[\\begin{array}{ccc} \\cos \\gamma & \\sin \\gamma & 0 \\\\ -\\sin \\gamma & \\cos \\gamma & 0 \\\\ 0 & 0 & 1 \\end{array}\\right]$ 图像的质量清晰度：亮度，对比度，主题内容的大小，细微层次，颜色饱和度 对比度 = 最大亮度 / 最小亮度 图像储存的数据结构 一维数组，行列储存 多波段储存 图像文件格式BMP, GIF, TIFF, JPEG等 &nbsp; &nbsp; *光盘读取原理无论是CD光盘还是DVD光盘，其存储方式与磁盘一样，都是以二进制数据的形式来存储信息。要在这些光盘上存储数据，需要借助激光把二进制数据刻在扁平、具有反射能力的盘片上。为了识别数据，定义激光刻出的小坑就代表二进制的“1”，而空白处则代表二进制的“0”。（凹坑和平坦区域的 边缘变化【如从凹坑到平坦，或反之】代表”1”，无变化代表”0”）DVD的记录凹坑比CD小，且螺旋存储凹坑之间的距离也更小。 CD光驱或DVD光驱的主要部分就是激光发生器和光监测器。激光发生器（激光二极管），可以产生对应波长的激光光束，然后经过一系列的处理后照到光盘上。经由光监测器捕捉反射信号而识别实际的数据。然后计算机将这些二进制代码转换成为原来的数据或程序。当光盘在光驱中作高速旋转，激光头在电机的控制下作径向移动，数据就这样源源不断地读取出来。 根据数据密度的差别可分为CD, DVD, BD等。 光盘与机械硬盘的工作原理区别可见以下博客： https://zhuanlan.zhihu.com/p/51572176","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://miustannis.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"https://miustannis.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"Hexo博客插入数学公式","slug":"250327","date":"2025-03-27T04:22:29.000Z","updated":"2025-04-28T07:56:37.921Z","comments":true,"path":"2025/03/27/250327/","link":"","permalink":"https://miustannis.github.io/2025/03/27/250327/","excerpt":"","text":"在写一些内容时，会遇到需要添加数学公式的地方，Hexo部分主题不支持公式的渲染，比如我正在使用的vivia主题，在查阅一些资料之后，我使用MathJax引擎实现了vivia主题下的数学公式渲染。 MathJax简介：https://www.osgeo.cn/mathjax/basic/mathjax.html 该引擎是一款可在所有现代浏览器中工作的开源js显示引擎，辅助页面作者编写含有数学公式的文档 Step 1 : 安装MathJax引擎并更换渲染引擎：​ 操作包括卸载Hexo自带的Hexo-math，卸载默认的对MathJax不友好的marked引擎 npm uinstall hexo-math --save npm install hexo-renderer-mathjax --save npm uinstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save Step 2 : 更新MathJax的cdn链接Step 3 : 更改部分转义规则 hexo 默认的转义规则会将一些字符进行转义，所以要对默认的规则进行修改。首先， 打开/node_modules/kramed/lib/rules/inline.js 把： escape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_&gt;])/, em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 更改为： escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, Step 4 : 主题未预配置下使用Hexo-filter-mathjax对于已经配置MathJax的主题来说，在相关config文件里打开控件即可，对于未配置的主题，可以使用Hexo-filter-mathjax来帮助实现 Hexo-filter-mathjax项目地址：https://github.com/next-theme/hexo-filter-mathjax 安装： npm install hexo-filter-mathjax --save 对需要开启的博文，在其Front-Matter处增加mathjax: true这一行即可，如： --- title: xxxxxx categories: xxxxx date: xxxx-xx-xx mathjax: true --- 测试公式： 𝕟𝕚𝟘𝕚𝟚𝕟𝟚𝕟𝟚𝕟𝟙𝟞 矩阵运算： *注意到有的cdn版本MathJax框架下公式字体对行间公式有一定影响，可能会一些字体会被渲染成主题相同字体，且移动端不能很好地显示 参考资料： https://www.cnblogs.com/wangxin37/p/8185688.html https://heartlessly.github.io/others/latex-mathjax-gong-shi-zi-ti-mei-hua/","categories":[{"name":"DIY","slug":"DIY","permalink":"https://miustannis.github.io/categories/DIY/"}],"tags":[{"name":"html","slug":"html","permalink":"https://miustannis.github.io/tags/html/"},{"name":"Hexo","slug":"Hexo","permalink":"https://miustannis.github.io/tags/Hexo/"}]},{"title":"Harvard CS50 Study Log","slug":"250306","date":"2025-03-06T12:39:18.000Z","updated":"2025-05-12T03:29:08.667Z","comments":true,"path":"2025/03/06/250306/","link":"","permalink":"https://miustannis.github.io/2025/03/06/250306/","excerpt":"","text":"Lecture 0 ScratchLecture 1 CLecture 2 ArraysLecture 3 Algorithms Time Complexity is an important metric used to measure the relationship between the running time of an algorithm and the size of the input. It describes how the execution time of an algorithm increases as the input size grows. Time complexity helps us assess the efficiency of an algorithm under different problem sizes, allowing us to choose the most appropriate algorithm. Time complexity is usually expressed using Big notation. selection sort: bubble sort： insertion sort： merge sort： Lecture 4 Memory This section basically start from the pixels which formed by RGB code, for example 0xFF0000(using hexadecimal or base16 — 0x) . Why hexadecimal ? Using binary, it takes 4 bits to represent 16 possibilities. Using hexadecimal, 4 bits -&gt; one digit, that’s easier. So one byte, two of them, is a common unit of measurement. Then it comes to the tool or variable commonly used in C language which is pointer. A pointer is an address. int n = 50; printf(\"%i\\n\", n); // --50 printf(\"%p\\n\", &amp;n); // -- some address //the following sytanx are slightly differrent! int *p = &amp;n; // also int* p = &amp;n; they are the same, to specify a data type printf(\"%p\\n\", p);// -- same address above printf(\"%i\\n\", *p);// *p: go there --50 “&amp;a” means the address of a, “*“ is a dereference operator, which allows you to take an address, and go to it. By convention, pointers take up more space, they account for 8 bytes. 32-bit machine differs from 64-bit machine in the width of address bus, where 64-bit machine has larger memory. Strings, arrays of char so to speak, live at some address. They are continuous in memory from left to right, with 1 byte from each other. string s = \"CS50!\"; printf(\"%s\\n\",s);//--CS50! printf(\"%p\\n\",s);//--some address printf(\"%p\\n\",&amp;s[0]);//--address same as above printf(\"%p\\n\",&amp;s[1]);//--address above + 0x1 //technically string is not an actual datatype string s = \"CS50!\"; char* s = \"CS50!\"; //typedef char* string; !! //char* s = \"CS50!\"; \"&amp;\" is not needed here because CLANG puts the address of the first char in the variable when a double quote shows up. s is technically a pointer, to find the beginning of the string. pointer arithmetic: doing math on addresses char *s = \"CS50\"; printf(\"%c\\n\", s[0]); // -- C printf(\"%c\\n\", s[1]); // -- S printf(\"%c\\n\", *s); // -- C printf(\"%c\\n\", *(s+1)); // -- S memory allocate: FREE &amp; MALLOC 特性 栈（Stack） 堆（Heap） 管理方式 自动（编译器/操作系统） 手动（程序员malloc） 分配速度 快（直接移动指针） 慢（需要查找可用内存） 生命周期 函数调用结束就释放 显式释放（free） 大小限制 较小（几MB） 较大（受系统内存限制） 存储内容 局部变量、函数调用信息 动态分配的对象、大型数据 碎片问题 无 可能产生内存碎片 //program for string operating #include &lt;ctype.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;cs50.h&gt; int main(void) { char *s = get_string(\"s: \"); // fuction from cs50.h char *t = malloc(strlen(s) + 1); // malloc : memory allocate // return the first address of the memory if(t == NULL){ return 1; } // \"NULL\" no memory available for(int i = 0, n = strlen(s); i&lt;=n ; i++){ t[i] = s[i]; } strcpy(t,s);// equivalent if (strlen(t) &gt; 0){ t[0] = toupper(t[0]); } printf(\"%s\\n\", s); printf(\"%s\\n\", t); free(t); //free the memory mallocated，always remember to free return 0; } // Upper the first Character valgrind: prog that check memory mistake garbage values matter of scope “{ }” passing by reference void swap( int* a , int* b){ int temp = *a; *a = *b; *b = temp } File I/O //program for file writing --phonebook #include &lt;cs50.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { FILE *file = fopen(\"phonebook.csv\", \"a\"); if (file == NULL){ return 1; } char *name = get_string(\"Name: \"); char *number = get_string(\"Number: \"); fprintf(file, \"%s,%s\\n,name,number\"); fclose(file); } //program for file copy #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; typedef uint8_t BYTE; int main(int argc, char *argv[]) // use command line { FILE *src = fopen(argv[1], \"rb\"); FILE *dst = fopen(argv[2], \"wb\"); BYTE b; while (fread(&amp;b, sizeof(b), 1, src) != 0){ fwrite(&amp;b, sizeof(b), 1, dst); } fclose(dst); fclose(src); } Lecture 5 Data Structures abstract data types queues: FIFO (enqueue &amp; dequeue) stacks: LIFO (like email systems, push &amp; pop) //prog for dynamic memory allocate without linked list #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { int *list = malloc(3 * sizeof(int)); if (list == NULL){ return 1; } // if more space is needed to be allocated dynamicly int *tmp = malloc(4 * sizeof(int)); if (tmp == NULL){ // free the original memory free(list); return 1; } for (int i = 0; i &lt; 3; i++){ tmp[i] = list[i]; } tmp[3] = 4; // free the original memory free(list); // reorientation list = tmp; } linked list //template typedef struct node { int number; struct node *next; } node; //create a linked list with one node node *list = NULL; node *n = malloc(sizeof(node)); n -&gt; number = 1; //(*n).number = 1; n -&gt; next = NULL; list = n; // enter a linked list and print #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct node{ int number; struct node *next; } node; int main (int argc, char *argv[]) { node *list = NULL; for (int i = 1; i &lt; argc; i++){ int number = atoi(argv[i]); node *n = malloc(sizeof(node)); if(n == NULL){ //Free memory thus far return 1; } n-&gt;number = number; n-&gt;next = list; list = n; } //print whole list node *ptr = list; while (ptr != NULL){ printf(\"%i\\n\",ptr-&gt;number); ptr = ptr-&gt;next; } } adding nodes： searching nodes： // enter a reverse linked list and print #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct node{ int number; struct node *next; } node; int main (int argc, char *argv[]) { node *list = NULL; for (int i = 1; i &lt; argc; i++){ int number = atoi(argv[i]); node *n = malloc(sizeof(node)); if(n == NULL){ //Free memory thus far return 1; } n-&gt;number = number; n-&gt;next = NULL; //if list is empty if (list == NULL ){ list = n; } else{ for (node *ptr = list; ptr != NULL ; ptr = ptr-&gt;next){ if(ptr-&gt;next == NULL){ ptr-&gt;next = n; break; } } } } //print whole list node *ptr = list; while (ptr != NULL){ printf(\"%i\\n\",ptr-&gt;number); ptr = ptr-&gt;next; } } adding nodes： // enter a sequenced linked list #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct node{ int number; struct node *next; } node; int main (int argc, char *argv[]) { node *list = NULL; for (int i = 1; i &lt; argc; i++){ int number = atoi(argv[i]); node *n = malloc(sizeof(node)); if(n == NULL){ //Free memory thus far return 1; } n-&gt;number = number; n-&gt;next = NULL; //if list is empty if (list == NULL ){ list = n; } // if number belongs at beginning of the list else if (n-&gt;number &lt; list-&gt;number){ n-&gt;next = list; list = n; } // if number belongs later of the list else{ for (node *ptr = list; ptr != NULL ; ptr = ptr-&gt;next){ // at end if(ptr-&gt;next == NULL){ ptr-&gt;next = n; break; } //in middle if (n-&gt;number &lt; ptr-&gt;next-&gt;number){ n-&gt;next = ptr-&gt;next; ptr-&gt;next = n; break; } } } } //print whole list node *ptr = list; while (ptr != NULL){ printf(\"%i\\n\",ptr-&gt;number); ptr = ptr-&gt;next; } } adding nodes： trees binary search trees typedef struct node{ int number; struct node *left; struct node *right; } node; searching nodes： dictionaries hashing : mapping objects into finite number of outputs hashing function hash tables: array of linked lists collision expectation tries: a tree of arrays Lecture 6 Python &amp; Artificial Intelligence Python manages your memory automatically. It may take more memory than C. # python version of hash table in Problem set 5 words = set() def check(word): return word.lower() in words def load(dictionary): with open(dictionary) as file: words.update(file.read().splitlines()) return True def size(): return len(words) def unload(); return True Python has greater ecosystem for developers, basically more libs. Example: Face detection common IO syntax, you don’t have to specify the type of your variables answer = input(\"input:\") print(\"output, \" + answer) print(\"output,\", answer) print(f\"output,{answer}\") #type: bool float int str list set ... intent matters object oriented program(OOP): s = input(\"opinion: \") s = s.lower() # s = input(\"opinion: \").lower() if s in [\"y\",\"yes\"]: print(\"agreed\", end = \"\") elif s in [\"n\",\"no\"]: print(\"not agreed\") #loop for _ in range(3): print(\"test\") #function exception def get_int(prompt): while True: try: return int(input(prompt)) except ValueError: print(\"not an integer\") #for loop can end with an else people = [ {\"name\":\"carter1\",\"number\":\"+1-555-986-1004\"} {\"name\":\"carter2\",\"number\":\"+1-555-986-1004\"} {\"name\":\"carter3\",\"number\":\"+1-555-986-1004\"} ] name = input(\"Name: \") for person in people: if person[\"name\"] == name: number = person[\"number\"] print(f\"Found {number}\") break else: print(\"Not found\") the Artificial Intelligence part is more “introductory” and basic for learning prompt engineering minimax behavior machine learning reinforce learning (in robotics) explore vs exploit. deep learning generative artificial intelligence(large language models\\transformer\\attention values) Lecture 7 SQL SQL: a database-centric language (Structured Query Language) flat file database example: csv #csv example import csv with open(\"favorites.csv\",\"r\") as file: reader = csv.DictReader(file) counts = {} for row in reader: favorite = row[\"language\"] if favorite in counts: counts[favorite] += 1 else: counts[favorite] = 1 for favorite in sorted(counts, key = counts.get): print(f\"{favorite}: {counts[favorite]}\") relational database: CRUD(create read update delete || insert drop) this lecture uses sqlite3, for mobile database. $ sqlite3 favorites.db sqlite&gt; .mode csv sqlite&gt; .import favorites.csv favorites --import csv to table sqlite&gt; .quit sqlite&gt; .schema --a sqlite command that shows the schema of the database sqlite&gt; SELECT * FROM favorites; --show entire content of the table sqlite&gt; SELECT language FROM favorites LIMIT 10; --show seletced content of the table sqlite&gt; SELECT COUNT(*) FROM favorites; --total count sqlite&gt; SELECT COUNT(DISTINCT(language)) FROM favorites; --type count sqlite&gt; SELECT COUNT(*) FROM favorites WHERE language = 'C'; sqlite&gt; SELECT COUNT(*) FROM favorites WHERE language = 'C' AND problem = 'Hello, World'; sqlite&gt; SELECT language, COUNT(*) FROM favorites GROUP BY language; --works as python code above sqlite&gt; INSERT INTO favotites(language, problem) VALUES('SQL', 'fiftyville'); --appending a new row to table sqlite&gt; DELETE FROM favorites WHERE Timestamp IS NULL;--delete row sqlite&gt; UPDATE favorites SET language = 'SQL', problem = 'fiftyville';--update and now all content has been changed which can be justified by WHERE...(condition) link different tables together one-to-one: primary key &amp; foreign key -- IMDb example sqlite&gt; SELECT * FROM shows WHERE id IN ...&gt;(SELECT show_id FROM ratings WHERE rating &gt;= 6.0) how to join two tables that have related keys? -- syntax 'JOIN' sqlite&gt; SELECT * FROM shows JOIN ratings ON shows.id = ratings.show_id WHERE rating&gt;= 6.0 LIMIT 10; link different tables together: one-to-many ，many-to-many ​ just nested snytax. SQL injection attack just use placeholders and sanitize customer’s inputs Lecture 8 HTML, CSS, JavaScript routes &amp; packets；a pair of protocols: TCP/IP IPv4: #.#.#.# (0~255) 32 bits TCP: use sequence numbers to help servers multiplex, port numbers (80: HTTP 443: HTTPS) DNS (domain name system) servers domain name -&gt; IP address buy a domain name: pay someone(运营商) to associate an IP address with your domain name DHCP (dynamic host configuration protocol) 自动为设备分配地址 HTTP (hypertext transmit protocol) HTTPS (hypertext transmit protocol secure) Internet protocol that allows a web browser to request and receive information from a web server HTML: (hypertext marker language) a really easy language that you can learn in 30 minutes. VSCode makes it even more convenient. but it can take a lot of effort to make good websites. tags &amp; attributes: &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;!--html: tag lang = \"en\": attributes --&gt; &lt;head&gt; &lt;title&gt; title &lt;/title&gt; &lt;/head&gt; &lt;body&gt; body &lt;/body&gt; &lt;/html&gt; regular expressions: 正则表达式 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions you can change your local copy of html by using developer tools CSS: (Cascading Style Sheets) properties: example &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body style = \"text-align: center\"&gt; &lt;p style = \"font-size: large\"&gt; John Harvard &lt;/p&gt; &lt;p style = \"font-size: medium\"&gt; Welcome to my homepage &lt;/p&gt; &lt;p style = \"font-size: small\"&gt; Copyright &amp;#169; John Harvard &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; classes: your own style or style from third libraries &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;style&gt; .centered{ text-align: center; } .large{ font-size: large; } .medium{ font-size: medium; } .small{ font-size: small; } &lt;/style&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body class = \"centered\"&gt; &lt;head class = \"large\"&gt; John Harvard &lt;/head&gt; &lt;main class = \"medium\"&gt; Welcome to my homepage &lt;/main&gt; &lt;footer class = \"small\"&gt; Copyright &amp;#169; John Harvard &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; ​ 样式可使用外链 ​ #+… : ID JavaScript Lecture 9 Flask flask a python third party library for web microframework linking static(html) &amp; dynamic(python) files. We use the syntax “JINJA” to customize and formalize the outlook of the web. Following the lecture I made a simple web application to greet users, the GitHub link is https://github.com/miustannis/flask-greeting-web.git more web app examples There two other web examples for sports register and library system, which are more realistic with more functions and more html files. Data can be managed in a better way using SQL, other than just in SRAM. cookies tools that websites use to keep staying stateful. Server needs to remember something about the user, cookies will be sent back to server by browsers every time a user log in. problems: cookies may be used for ads and tracking. Lecture 10 Cybersecurity passwords brute-force attack two-factor authentication (mostly hardware equipment) one-time passwords server uses hash function to compare passwords cryptography: public key &amp; private key (HTTPS) passkeys: generate public key and send it to the company, and a private one for verifying your signature combining the public key. secure deletion -&gt; full disk encryption *看此课程以温习basic coding和补充一些计算机思维，老师讲的很有激情，时间花的还算比较有价值 ______ | see you | ====== \\ \\ \\ \\ / \\\\ //\\\\ |\\\\___/| / \\\\// \\\\\\\\ /0 0 \\\\__ / // | \\\\ \\\\ / / \\\\/_/ // | \\\\ \\\\ \\@_^_\\@'/ \\\\/_ // | \\\\ \\\\ //_^_/ \\\\/_ // | \\\\ \\\\ ( //) | \\\\/// | \\\\ \\\\ ( / /) _|_ / ) // | \\\\ _\\\\ ( // /) '/,_ _ _/ ( ; -. | _ _\\\\.-~ .-~~~^-. (( / / )) ,-{ _ `-.|.-~-. .~ `. (( // / )) '/\\\\ / ~-. _ .-~ .-~^-. \\\\ (( /// )) `. { } / \\\\ \\\\ (( / )) .----~-.\\\\ \\\\-' .~ \\\\ `. \\\\^-. ///.----..&gt; \\\\ _ -~ `. ^-` ^-_ ///-._ _ _ _ _ _ _}^ - - - - ~ ~-- ,.-~ /.-~","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://miustannis.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://miustannis.github.io/tags/CS/"}]},{"title":"基于MLX90640的手持红外热成像仪","slug":"250226","date":"2025-02-26T02:05:52.000Z","updated":"2025-05-06T01:55:42.991Z","comments":true,"path":"2025/02/26/250226/","link":"","permalink":"https://miustannis.github.io/2025/02/26/250226/","excerpt":"","text":"项目背景： DIY好玩捏 电路工作时有时需要检查元件发热情况，但用手触摸元件有一定的风险，因此需要一种无接触式的多点测温设备 于是开始了解到热成像这个测温方式，以下是软硬件方案 方案：硬件部分​ 采用上下两块板子对插组合，为了减少复杂度，留了排母方便直插LCD与传感器模组。 BOARD1: MCU与外设 采用STM32F407作为主控，512KB Flash，其实没特别注意选型，只是手上有这个开发板，要压缩成本的话用其他型号也可以 红外传感模组为MLX90640 BAA，这个价格比较贵，比其他元件加起来都贵 屏幕模组为1.44寸TFT-LCD，也是现成的，买了俩还剩一个，下次做别的东西的时候给用了吧 留了串口测试点和烧录测试点 BOARD2: POWER 3.7V锂电池供电，可通过USB接口经过LGS4084H电源管理芯片给锂电池充电 经过一个LDO稳到3.3V给MCU整体供电，VDDA和VCC用磁珠滤波隔离了一下 电源板后续涉及锂电池供电DIY的倒是可以继续沿用 立创打样PCB，自己贴片，PCB板框留了一些M3螺孔方便组装。 软件部分通讯接口涉及IIC与SPI，以及图像测试的时候用了一下UART，均比较基础。使用硬件IIC进行传感器模组与MCU间的通信，模组官方提供了接口可调用，可读取温度值。RGB转换用了开源的函数： /*pass in value and figure out R G B several published ways to do this I basically graphed R G B and developed simple linear equations again a 5-6-5 color display will not need accurate temp to R G B color calculation equations based on http://web-tech.ga-usa.com/2012/05/creating-a-custom-hot-to-cold-temperature-color-gradient-for-use-with-rrdtool/index.html */ static uint16_t TempToColor(float val)&#123; red = constrain(255.0f / (c - b) * val - ((b * 255.0f) / (c - b)), 0, 255); if ((val > minTemp) &amp; (val &lt; a)) &#123; green = constrain(255.0f / (a - minTemp) * val - (255.0f * minTemp) / (a - minTemp), 0, 255); &#125; else if ((val >= a) &amp; (val &lt;= c)) &#123; green = 255; &#125; else if (val > c) &#123; green = constrain(255.0f / (c - d) * val - (d * 255.0f) / (c - d), 0, 255); &#125; else if ((val > d) | (val &lt; a)) &#123; green = 0; &#125; if (val &lt;= b) &#123; blue = constrain(255.0f / (a - b) * val - (255.0f * b) / (a - b), 0, 255); &#125; else if ((val > b) &amp; (val &lt;= d)) &#123; blue = 0; &#125; else if (val > d) &#123; blue = constrain(240.0f / (maxTemp - d) * val - (d * 240.0f) / (maxTemp - d), 0, 240); &#125; // use the displays color mapping function to get 5-6-5 color palet (R=5 bits, G=6 bits, B-5 bits) return BSP_LCD_GetColor565(red, green, blue); &#125; 该传感器成图32x24像素，而使用的LCD是128x128的，于是我用4个像素作为一个大像素来填充，并增加了一个图例和一个最大最小值来提供量化，并填充一下屏幕留白 static void drawPicture(void) &#123; uint8_t cell_size = 4; // 格子大小 4x4 uint8_t start_x = 0; // 水平居中（128 - 32*4 = 0） uint8_t start_y = 16; // 垂直居中（(128 - 24*4)/2 = 16） for (y = 0; y &lt; 24; y++) &#123; for (x = 0; x &lt; 32; x++) &#123; ST7735_FillRectangle( start_x + x * cell_size, start_y + (23 - y) * cell_size, cell_size, cell_size, TempToColor(tempValues[(31- x) + (y * 32)]) ); &#125; &#125; &#125; static void drawLegend(void) &#123; uint8_t legend_height = 5; // 图例高度（像素） uint8_t legend_y = 0; // 图例顶部位置（y=0） uint8_t legend_width = 120; // 图例宽度（留左右边距） uint8_t start_x = 4; // 图例左侧起始位置（x=4） // 绘制温度颜色渐变条（水平方向） float temp_range = maxTemp - minTemp; for (uint8_t x = 0; x &lt; legend_width; x++) &#123; float temp = minTemp + temp_range * (x / (float)legend_width); uint16_t color = TempToColor(temp); // 绘制水平线（从左到右） ST7735_DrawLine(start_x + x, legend_y, start_x + x, legend_y + legend_height, color); &#125; // 显示最小/最大温度标签 // memset(tempBuffer, 0, sizeof(tempBuffer)); sprintf(tempBuffer, \"&lt;%2.1f \", minTemp); ST7735_WriteString(2, 115, tempBuffer, Font_7x10, ST7735_WHITE, ST7735_BLACK); //// memset(tempBuffer, 0, sizeof(tempBuffer)); sprintf(tempBuffer, \"%2.1f> \", maxTemp); ST7735_WriteString(90, 115, tempBuffer, Font_7x10, ST7735_WHITE, ST7735_BLACK); &#125; 最后在主循环里轮询就可以了，屏幕刷新率一般，眨眼补帧。 整体软件部分比较清晰，本来想加一些按键交互，修改颜色范围，存储图片到外部flash之类的功能，然后懒了。 后续学了操作系统和LVGL库之后再搞点好玩的吧，感觉大部分DIY应用裸机完全够了… 小问题合集：problem1：使用ST-Link下载过一次程序后发现无法继续下载 检查设备管理器，确保有正确的ST-Link驱动 检查Keil软件配置，确保导入正确的型号版本 检查引脚配置，发现问题： ​ 配置的IIC通信引脚占用了SWD下载引脚（STM32默认的PA13 &amp;PA14），引脚输入输出模式不适配，显然后续无法下载，遂改之，问题解决。（图示仅供参考） problem2：HardFault中断触发栈空间不足，多分配点就ok","categories":[{"name":"DIY","slug":"DIY","permalink":"https://miustannis.github.io/categories/DIY/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C","slug":"C","permalink":"https://miustannis.github.io/tags/C/"}]},{"title":"Xiaomi路由器BE3600快速救砖","slug":"250213","date":"2025-02-13T10:25:24.000Z","updated":"2025-02-14T16:19:47.813Z","comments":true,"path":"2025/02/13/250213/","link":"","permalink":"https://miustannis.github.io/2025/02/13/250213/","excerpt":"","text":"家里的路由器变砖了（具体原因不清楚） 指示灯由蓝色常亮变成橙色常亮，对于家用路由器这种消费电子产品，一般重启一下能解决90%的故障 但心血来潮想试一下给它刷个机 型号是这个： 刷机需要一根网线，PC，以及变砖的路由器 步骤如下： 在网址MiWiFi中找到刷机软件与对应型号的ROM固件 关闭PC的防火墙，将网线连接至路由器的LAN口，本型号WAN与LAN口二合一了,随便找个口插上就行 打开刷机软件并载入对应的固件 用工具按住路由器的reset键后通电源，这一步非常像之前给单片机内部flash进行ISP下载程序的步骤，因此感觉很熟悉 待指示灯闪烁后松开reset键，固件开始下载 路由器变为蓝灯闪烁，此时已经刷机完成，当新路由器用就行","categories":[{"name":"DIY","slug":"DIY","permalink":"https://miustannis.github.io/categories/DIY/"}],"tags":[{"name":"改装","slug":"改装","permalink":"https://miustannis.github.io/tags/%E6%94%B9%E8%A3%85/"}]},{"title":"2025 Feb Packing Up & Personal Step to Decluttering","slug":"250212","date":"2025-02-10T11:12:26.000Z","updated":"2025-04-13T11:36:52.715Z","comments":true,"path":"2025/02/10/250212/","link":"","permalink":"https://miustannis.github.io/2025/02/10/250212/","excerpt":"","text":"Overview寒假从公寓打包东西回家时，我感受到自己的行李数量过多，直观的表现是我用了四个大号搬家盒邮寄，但剩余的物品还是将我的行李箱塞得很满，导致拉链都很难拉上。 我有收藏的癖好，包括各种证件，证书，徽章等。很多时候我觉得这个习惯帮助自己成为一个有条理的人，因为对于收纳好的物品，我很少出现找不到东西的情况；但也有很多时候我感觉自己在已经过去的事情上花费了过多的精力，一定程度上影响了自己的生活节奏。 然而我始终认为很多东西是有纪念意义的，因此有必要在实现这个意义的方法上进行一些变通。近期，我在收纳整理方面做了一些思考与改变。 For Record在2023年我看到一些博主，使用一种叫手账的方式记录自己的日常生活，他们会在一些记事本（通常外观看起来比较好看）上通过文字，绘画与粘贴物品等方式呈现一种比日记更丰富的格式，个人风格十分鲜明。当时正值保研结束的暑假，是我大学以来最放松的一段时间，对现实与未来没有过多的想象与焦虑，仿佛生活随风而起，处处是可以随手采撷的格桑花。于是我一眼看上这种“生活的艺术”，买了一个手账本，一台用于打印照片的 Canon CP1500，以及一些用来切割的工具。 我会用图片记录下一些东西，将他们用照片打印机打印出来后，撕去相纸的背面硬支撑部分，用胶水将其粘贴在手账本上，并在一旁配上文字描述与相关心情。甚至在看完一部电影或是一部动漫之后，我会将它们的海报打印下来，一并粘贴上去。 一套流程下来，整理两页的手账得画上1~2个小时，尤其是媒体记录，其实在豆瓣上点一个“看过”大概只需要十几秒的时间。 本质上来说，“手账”以及其他的一些类似记录的方式属于一种对慢生活态度的实践，可能对于当时的我来说，需要一段时间来放空自己。 优点 缺点 放松 繁杂冗长 自我表达 效率低 组织与规划能力 过于追求细节 综上优缺点考量，我决定不再继续这种记录方式了，博客或其他电子设备记录是一种更可取的方式。 For 高达模型拼装模型是我从小到大的爱好，从军模到高达，我很享受把碎片构造成一个完整体的过程，有种化腐朽为神奇的感觉（尽管都是别人设计好的）。现在我保存的高达所剩不多了，据我记得的，拼好后丢失的就有：MG黄金百式2.0，RG命运女神，RG新安州异色版等，每一个高达拼完都花不小的功夫，现在想想没能保存下来非常可惜。 我的素组高达制作有以下三个步骤： 板件拼装（包括修剪水口与简易打磨） 水贴修饰 保护漆喷涂 我把之前的MG艾比安和MG能天使都拿出来喷了消光，正好用完之前剩下的半罐漆。 现在我的房间的一面长这样，堆了许多收藏的东西。","categories":[{"name":"Being","slug":"Being","permalink":"https://miustannis.github.io/categories/Being/"}],"tags":[{"name":"自言自语","slug":"自言自语","permalink":"https://miustannis.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"}]},{"title":"STM32配置笔记参考","slug":"241121","date":"2024-11-21T10:45:34.000Z","updated":"2025-05-10T06:34:27.529Z","comments":true,"path":"2024/11/21/241121/","link":"","permalink":"https://miustannis.github.io/2024/11/21/241121/","excerpt":"大二学习STM32G4系列的笔记，upload当乐高说明书看","text":"大二学习STM32G4系列的笔记，upload当乐高说明书看 pdf嵌入使用了pdf.js插件，hexo-pdf这个插件在移动端不能很好地显示","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://miustannis.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C","slug":"C","permalink":"https://miustannis.github.io/tags/C/"}]},{"title":"UART收发处理函数","slug":"241020","date":"2024-10-20T02:51:00.000Z","updated":"2024-12-11T06:10:18.125Z","comments":true,"path":"2024/10/20/241020/","link":"","permalink":"https://miustannis.github.io/2024/10/20/241020/","excerpt":"","text":"UART（Universal Asynchronous Receiver/Transmitter）是一种串行通信协议，在嵌入式系统和微控制器间数据传输中发挥着核心作用。UART协议通过异步方式传输数据，不依赖于共享时钟信号，简化了通信线路的需求。每次传输包括起始位、数据位、可选的奇偶校验位以及停止位，这种结构支持从简单的传感器到复杂的处理器之间的可靠数据交换。 其重要性还体现在其广泛的兼容性和低成本实现上。它可以通过简单的两线（TX和RX）接口实现全双工通信，极大地降低了系统的硬件复杂性。此外，UART通信协议可以适应不同的波特率设置，使其能够灵活地调整以匹配特定应用的速度要求。在许多工业和消费电子产品中，UART仍然是实现可靠串行通信的首选技术，尤其在资源受限的环境中显示出其高效和经济的优势。（以上均为GPT生成） 在进行传感器测试时，常用到UART，这里mark一下自己常用的HAL库函数封装，免得后续一直翻之前的程序 函数需要用到的全局变量如下： char send[20] = &#123;0&#125;; //传输用字符数组，储存字符串 uint8_t rx_buffer = 0; //接收字符缓冲区 char rx_receiver[20] = &#123;0&#125;; //接收用字符数组 uint8_t rx_num = 0; //接收字符数量 uint8_t uart_start_flag = 0; //接收标志位 __IO uint32_t uart_gettick = 0; //系统时钟比较变量 /* 测试变量 uint16_t pwm_duty = 0; uint8_t startbegin = 0xff; uint8_t startbegin2 = 0x00; */ 在硬件配置时要打开UART中断： HAL_UART_Receive_IT(&amp;huart1 , &amp;rx_buffer, 1); 中断回调函数如下： void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) &#123; if(rx_num == 0)&#123; uart_gettick = uwTick; uart_start_flag = 1; &#125; if(uart_start_flag == 1)&#123; rx_receiver[rx_num] = rx_buffer; rx_num++; &#125; HAL_UART_Receive_IT(&amp;huart1 , &amp;rx_buffer, 1); &#125; 主循环中的处理函数如下： void UART_RX_PROC(void) &#123; if((( uwTick- uart_gettick ) >=10) &amp;&amp; (( uwTick- uart_gettick ) &lt;=600) &amp;&amp; (uart_start_flag == 1))&#123; if(rx_receiver[0] == '&amp;' )&#123; if( rx_num == 2) &#123; //示例：传输pwm占空比 pwm_duty = rx_receiver[1]-'0'; &#125; else if( rx_num == 3)&#123; pwm_duty = (rx_receiver[1]-'0')*10 + rx_receiver[2]-'0'; &#125; else if( rx_num == 4)&#123; pwm_duty = (rx_receiver[1]-'0')*100 + (rx_receiver[2]-'0')*10 + rx_receiver[3]-'0'; &#125; else if ( rx_num >= 5)&#123; pwm_duty = 1000; &#125; &#125; HAL_UART_Transmit(&amp;huart1, &amp;startbegin, 1,0xffff); HAL_UART_Transmit(&amp;huart1, &amp;startbegin2, 1,0xffff); HAL_UART_Transmit(&amp;huart1, &amp;startbegin, 1,0xffff); rx_num = 0; uart_start_flag = 0; &#125; &#125; 这里的函数主要是用以处理字符串的，应付一些的简单的应用已经够用了，当然，也能在此基础上扩展。","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://miustannis.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C","slug":"C","permalink":"https://miustannis.github.io/tags/C/"}]},{"title":"TFTLCD驱动","slug":"240928","date":"2024-09-28T06:00:30.000Z","updated":"2024-12-11T06:13:31.973Z","comments":true,"path":"2024/09/28/240928/","link":"","permalink":"https://miustannis.github.io/2024/09/28/240928/","excerpt":"","text":"在使用Img2LCD取模软件和ST7735S驱动IC控制LCD时，发现API中显示图片的函数调用后显示异常 原函数： void ST7735_DrawImage(uint16_t x, uint16_t y, uint16_t w, uint16_t h, const uint16_t* data) &#123; if((x >= ST7735_WIDTH) || (y >= ST7735_HEIGHT)) return; if((x + w - 1) >= ST7735_WIDTH) return; if((y + h - 1) >= ST7735_HEIGHT) return; ST7735_Select(); ST7735_SetAddressWindow(x, y, x+w-1, y+h-1); ST7735_WriteData((uint8_t*)data, sizeof(uint16_t)*w*h); ST7735_Unselect(); &#125; 输入数据要求16位rgb565格式图片，与Img2LCD取模软件两个8位数表示一个像素点的编码逻辑不同，首次修改仅改了原函数输入数据的格式：将data16位常量数据指针类型改为8位无符号变量指针类型，且在spi写入数据时将数据量乘以2，修改后的函数如下： void ST7735_DrawImage8bit_Img2LCD(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t* data) &#123; if((x >= ST7735_WIDTH) || (y >= ST7735_HEIGHT)) return; if((x + w - 1) >= ST7735_WIDTH) return; if((y + h - 1) >= ST7735_HEIGHT) return; ST7735_Select(); ST7735_SetAddressWindow(x, y, x+w-1, y+h-1); ST7735_WriteData((uint8_t*)data, sizeof(uint8_t)*w*h*2); ST7735_Unselect(); &#125; 但是烧录测试后LCD显示颜色异常且边缘模糊，初步推测是图片数据原本的问题，考虑到可能2个8位数据合并时高8位与低8位的顺序反了，在MATLAB中进行数组元素两两翻转验证： function swappedArray = swapPairs(inputArray) if iscolumn(inputArray) inputArray = inputArray'; end n = length(inputArray); if mod(n, 2) ~= 0 inputArray(end+1) = NaN; end swappedArray = inputArray; swappedArray(1:2:end) = inputArray(2:2:end); swappedArray(2:2:end) = inputArray(1:2:end); swappedArray = swappedArray(~isnan(swappedArray)); end 将原始图片数据处理后再进行烧录，发现显示正常，问题定位到数组元素的写入顺序，解决方法较多，这里我直接在函数中将原始数组变换，最终的函数如下： void ST7735_DrawImage8bit_Img2LCD(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t* data) &#123; uint32_t i = 0; uint8_t temp = 0; if((x >= ST7735_WIDTH) || (y >= ST7735_HEIGHT)) return; if((x + w - 1) >= ST7735_WIDTH) return; if((y + h - 1) >= ST7735_HEIGHT) return; /* Swap adjacent elements in the data array */ for ( i = 0; i &lt; w * h * 2; i += 2) &#123; if (i + 1 &lt; w * h * 2) &#123; temp = data[i]; data[i] = data[i + 1]; data[i + 1] = temp; &#125; &#125; ST7735_Select(); ST7735_SetAddressWindow(x, y, x+w-1, y+h-1); ST7735_WriteData((uint8_t*)data, sizeof(uint8_t)*w*h*2); ST7735_Unselect(); &#125; 看看显示效果：","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://miustannis.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C","slug":"C","permalink":"https://miustannis.github.io/tags/C/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://miustannis.github.io/tags/MATLAB/"}]},{"title":"西南风光","slug":"240916","date":"2024-09-15T17:01:33.000Z","updated":"2025-04-13T12:47:10.899Z","comments":true,"path":"2024/09/16/240916/","link":"","permalink":"https://miustannis.github.io/2024/09/16/240916/","excerpt":"2024年8月 迟来的fine journey 稍纵即逝","text":"2024年8月 迟来的fine journey 稍纵即逝 醉后不知天在水 满船清梦压星河","categories":[{"name":"Being","slug":"Being","permalink":"https://miustannis.github.io/categories/Being/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"https://miustannis.github.io/tags/%E6%91%84%E5%BD%B1/"}]},{"title":"Reflections on my undergraduate life","slug":"231231","date":"2023-12-31T11:31:43.000Z","updated":"2025-04-22T01:46:30.785Z","comments":true,"path":"2023/12/31/231231/","link":"","permalink":"https://miustannis.github.io/2023/12/31/231231/","excerpt":"","text":"2020秋入学至今，我已进入我的Senior Year，成为学校中离毕业最近的那批人之一。 藏不住高考的阴霾，我在一个潮湿的周末办理了入学报到。对学校本身，我并没有太多想象，只是机械地和别人一样走着搬宿舍，入住，参观学校，军训的流程，对自己将要呆的地方没有丝毫好奇心，not to mention “归属感”。在做题多年所带来的优绩主义思想残留和想要改变现状的迫切心理交叉影响下，刚入学的我便决定好好学习，达到保研要求，去一个更好的平台读研。除此之外，我又想多尝试一些事情，当一个斜杠man，不想变成nerd，并且和这些人划清界线。 这两个指导思想，贯穿着我的大学生活。 对于保研去往更好的平台，这个目的本身并没有问题，我现在也认为，学习本身也是为了更好的生活。从当时和现在看来，保研无疑是比较平稳且有效的选择，是“本手”。 只是受限于达到保研要求这个悬在头顶的宝剑，我的目光和精力被束缚在GPA，加分政策等一系列数字与文书上，于是这三年，我并没有对自己的兴趣爱好进行充分的发掘，也并没有从埋头学习中收获太多的乐趣。或者说，我对自己想要成为一个什么样的人，完全没有进行过深度思考。即使是现在大四的我，也只是能说出几个模糊的未来愿景。依稀记得之前看到过一个视频，记者采访一个白人小女孩，她规划了一整套人生流程，从参加议会到参加总统选举，清晰明了，令人咋舌。Lockdown期间，我在家上网课，虽然缺失了一部分大学生活，好在发展了几个持续且有输出性质的爱好，比如这个site。然而，我认为三年时间我应该达到的远不止这些。 前人常说，读大学应该提升专业技能和社交能力。就社交能力而言，我确实提升了很多，这和参加了很多活动不无关系，一开始我是一个socially awkward的人，过于在意别人的感受，把自己搞得十分拘谨，现在好很多，这是我最显著的成长之一。当然不一定要在校园里，三年时间，在哪里都能成长很多。 就专业技能方面，我应该是比较欠缺，由于没有参与正儿八经的科研项目，我的从问题出发，逐步改进方案的方法论还处于发育阶段，之前参与的一些比赛倒是帮助了一些，不过总体上还是在一个固定的框架下进行问题求解，遑论创新性的培养。可能我比其他nerd会变通一些，不过也好不到哪里去。这是很大的一个问题，创新思维很重要，这在ai取代低级工人的发展前景下是可预见的。希望未来我可以好好改进。 思想上，我一直有在通过chat&amp;chill进行一些非刻意的同龄人观察，不自觉地划分出：沾沾自喜的网络表层用户，焦虑的做题家，自命不凡的巨婴，沉迷塑造人设的封面人物，乐子人及其拥趸，暴躁的理想主义者等，当然也有淳朴的怀旧主义者，阳光而正常的普通人。后现代解构思潮将我推往人类与社会的本质，没等我看清，又一下子推开。对我来说，有一种把一盘五颜六色的M&amp;m豆翻倒，按碎在玻璃桌上，迸溅出一般底色的踉跄美感。回头看看这种带有先入为主色彩和刻板印象的分类，会感觉自己确实是这些类型的混合体，某一时间段的人格形象只是某一种特质占比升高的产物。只是感慨自己书读的太少，又缺少行万里路的资本和机遇，还不能做到摆脱而洒脱。或许时机未到，或许不需要摆脱，然后“沉浸在这种恶无限的倒错游戏里”。 Γνῶθι σεαυτόν 认识你自己，本科我没有做到，这是遗憾，也是契机。 不过，现在我坐在宿舍里，毕业前只想简单地在这城乡结合部体验一下烂俗文学中享乐主义横行的校园生活，好好在没有走过几遍的苏城小路上来回踱一踱步，在去往下一场折腾前，大口呼吸。","categories":[{"name":"Being","slug":"Being","permalink":"https://miustannis.github.io/categories/Being/"}],"tags":[{"name":"自言自语","slug":"自言自语","permalink":"https://miustannis.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"}]},{"title":"寒山寺闲逛","slug":"231216","date":"2023-12-16T02:38:29.000Z","updated":"2025-04-13T12:46:59.099Z","comments":true,"path":"2023/12/16/231216/","link":"","permalink":"https://miustannis.github.io/2023/12/16/231216/","excerpt":"","text":"有《枫桥夜泊》钟声的加持，也算名气不小的景点实际乏善可陈，没什么特点 张继的雕像侧躺在现代枫桥旁边手脚部位被游客盘得发亮，据说摸一摸家里小孩就能考上好大学","categories":[{"name":"Being","slug":"Being","permalink":"https://miustannis.github.io/categories/Being/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"https://miustannis.github.io/tags/%E6%91%84%E5%BD%B1/"}]},{"title":"procreate社团设计x3","slug":"220317","date":"2022-03-16T12:50:00.000Z","updated":"2025-04-13T12:47:39.216Z","comments":true,"path":"2022/03/16/220317/","link":"","permalink":"https://miustannis.github.io/2022/03/16/220317/","excerpt":"翻了翻之前的文件夹，自己在在本科社团宣传部一年好像也没什么创作成果","text":"翻了翻之前的文件夹，自己在在本科社团宣传部一年好像也没什么创作成果 首先是两个养老院的徽章，记得当时是在画第一个徽章的过程中错删了一个图层，然后碰巧搞出了一个镂空的效果，感觉还不错，就在第二个徽章里故技重施了一下，但没有原来的效果了 下图是大二上学期一次活动的海报设计，for苏州大学独墅湖校区冬至灯会 以上作品均由iPad绘画软件procreate绘制，方便使用，新手友好","categories":[{"name":"Being","slug":"Being","permalink":"https://miustannis.github.io/categories/Being/"}],"tags":[{"name":"绘画","slug":"绘画","permalink":"https://miustannis.github.io/tags/%E7%BB%98%E7%94%BB/"}]},{"title":"procreate绘画x3","slug":"220316","date":"2022-03-16T11:32:26.000Z","updated":"2025-04-13T12:47:27.819Z","comments":true,"path":"2022/03/16/220316/","link":"","permalink":"https://miustannis.github.io/2022/03/16/220316/","excerpt":"或许有点蒸汽波","text":"或许有点蒸汽波","categories":[{"name":"Being","slug":"Being","permalink":"https://miustannis.github.io/categories/Being/"}],"tags":[{"name":"绘画","slug":"绘画","permalink":"https://miustannis.github.io/tags/%E7%BB%98%E7%94%BB/"}]},{"title":"Hexo博客插入图片","slug":"220321","date":"2022-03-15T01:32:46.000Z","updated":"2025-04-28T08:17:36.582Z","comments":true,"path":"2022/03/15/220321/","link":"","permalink":"https://miustannis.github.io/2022/03/15/220321/","excerpt":"插入图片之前打算在文章中插入图片，配置的过程中遇到了一些问题。","text":"插入图片之前打算在文章中插入图片，配置的过程中遇到了一些问题。 想在博客中引用外站图片问题不大，但Hexo默认插入图片只有这一个方法，对有本地化需求的人群来说不够方便，此时可以安装一个满足本地图片引用的插件，在国内某知名（c）专业（s）开发者（d）社区（n）里提供的90%的方案为以下命令：npm install hexo-asset-image –save该论坛上相互借鉴蔚然成风的壮景对我这个刚入门的小白真是非常险恶，此指令安装版本落后，无法有效显示图片，有效的版本安装命令如下：npm install https://github.com/CodeFalling/hexo-asset-image –save 修改_config.yml文件，将post_asset_folder:值改为true。 之后在新建一个博客的同时会生成同名文件夹，将需插入的图片放入该文件夹即可。文章中的具体引用代码为以下格式：(后来发现在source文件夹里新建一个名为images的文件夹存放图片也行)![](1/image.jpg) 更改相对位置但这种方法在PC端有一个默认的问题就是图片插入后会自动左对齐，想要实现居中对齐，可以在markdown引用代码外部添加center元素，或者直接添加html元素，如下所示：&lt;center> ![...](xxx) &lt;/center> &lt;!--or --> &lt;div align=center> ![...](xxx) &lt;/div>(因为我用VScode来打开博客的md文件进行编辑，在上传至本地网页时一开始发现图片无法加载，后来排查得出居中命令代码间的空行是必要的，不知道其他编辑器是否有这样的问题。) 还可以直接修改css文件，因为markdown插入图片的代码在最终渲染的时候变为html中的img元素。因此可以直接去博客主题文件的源代码中，找到控制文章内图片显示样式的css代码，将其修改成水平居中即可。前端编程中修改水平居中的方法非常多，以下是网上资源中提供的其中一种： 一般情况下可以在Hexo博客文件夹进入到主题模板的themes-&gt;(主题名称文件夹)-&gt;source-&gt;css-&gt;_partial中，找到post.styl文件，该post文件中保存的就是文章详情页里面的显示样式。然后找到里面正确的img元素，修改其样式，增加margin 0 auto这行指令。如下:.post-content position relative color c-666 img max-width 100% cursor pointer display block margin 0 auto然后可以实现了。但我在自己当前使用的主题中并没有找到相关语段，由于技术比较拉跨，我决定还是先老实用前两种吧。 [后期补丁：你需要一款名为Typora的markdown编辑软件]","categories":[{"name":"DIY","slug":"DIY","permalink":"https://miustannis.github.io/categories/DIY/"}],"tags":[{"name":"html","slug":"html","permalink":"https://miustannis.github.io/tags/html/"},{"name":"yaml","slug":"yaml","permalink":"https://miustannis.github.io/tags/yaml/"},{"name":"Hexo","slug":"Hexo","permalink":"https://miustannis.github.io/tags/Hexo/"}]},{"title":"Hexo博客启用测试","slug":"220314","date":"2022-03-14T07:08:39.000Z","updated":"2025-05-01T05:27:46.482Z","comments":true,"path":"2022/03/14/220314/","link":"","permalink":"https://miustannis.github.io/2022/03/14/220314/","excerpt":"","text":"test test test","categories":[{"name":"DIY","slug":"DIY","permalink":"https://miustannis.github.io/categories/DIY/"}],"tags":[{"name":"html","slug":"html","permalink":"https://miustannis.github.io/tags/html/"},{"name":"Hexo","slug":"Hexo","permalink":"https://miustannis.github.io/tags/Hexo/"}]}],"categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://miustannis.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"DIY","slug":"DIY","permalink":"https://miustannis.github.io/categories/DIY/"},{"name":"Being","slug":"Being","permalink":"https://miustannis.github.io/categories/Being/"}],"tags":[{"name":"图像处理","slug":"图像处理","permalink":"https://miustannis.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"html","slug":"html","permalink":"https://miustannis.github.io/tags/html/"},{"name":"Hexo","slug":"Hexo","permalink":"https://miustannis.github.io/tags/Hexo/"},{"name":"CS","slug":"CS","permalink":"https://miustannis.github.io/tags/CS/"},{"name":"嵌入式","slug":"嵌入式","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"C","slug":"C","permalink":"https://miustannis.github.io/tags/C/"},{"name":"改装","slug":"改装","permalink":"https://miustannis.github.io/tags/%E6%94%B9%E8%A3%85/"},{"name":"自言自语","slug":"自言自语","permalink":"https://miustannis.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://miustannis.github.io/tags/MATLAB/"},{"name":"摄影","slug":"摄影","permalink":"https://miustannis.github.io/tags/%E6%91%84%E5%BD%B1/"},{"name":"绘画","slug":"绘画","permalink":"https://miustannis.github.io/tags/%E7%BB%98%E7%94%BB/"},{"name":"yaml","slug":"yaml","permalink":"https://miustannis.github.io/tags/yaml/"}]}