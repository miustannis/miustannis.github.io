{"meta":{"title":"Miao's Blog","subtitle":null,"description":"","author":"miao","url":"https://miustannis.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-04-01T03:49:27.000Z","updated":"2024-08-31T13:32:40.374Z","comments":true,"path":"categories/index.html","permalink":"https://miustannis.github.io/categories/index.html","excerpt":"","text":""},{"title":"Profile","date":"2026-02-18T11:30:16.532Z","updated":"2026-02-18T11:30:16.532Z","comments":true,"path":"about/index.html","permalink":"https://miustannis.github.io/about/index.html","excerpt":"","text":"ğŸ“Educationï¼š Soochow University &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Suzhou, China &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sep 2020 - Jun 2024 Bachelor of Engineering in Electrical Engineering &amp; Automation &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GPA: 3.8 / 4.0 ğŸ“ƒPublicationï¼š Fang J, Zhou S, Miao Y, et al. A continuous hemodynamic parameters algorithm based on the wearable tonometric device[C]//2024 IEEE 3rd International Conference on Micro/Nano Sensors for AI, Healthcare, and Robotics (NSENS). IEEE, 2024: 14-17. Yu C, Deng M, Zhou S, Miao Y, et al. Integrated Stretchable and Adhesive Ionic Gel Epidermal Electrode for Cardiovascular Monitoring[C]//2025 IEEE International Conference on Flexible and Printable Sensors and Systems (FLEPS). IEEE, 2025: 1-4. Yuan N, Du C, Yang Z, Miao Y, et al. Chronic Venous Function Monitoring via a highly Flexible Capacitive Strain Sensing Device[C]//2025 IEEE 20th Nanotechnology Materials and Devices Conference (NMDC).IEEE, 2025: 97-102"},{"title":"tags","date":"2024-08-31T13:20:15.000Z","updated":"2024-08-31T13:20:27.842Z","comments":true,"path":"tags/index.html","permalink":"https://miustannis.github.io/tags/index.html","excerpt":"","text":""},{"title":"404","date":"2018-09-30T09:25:30.000Z","updated":"2024-08-31T13:23:24.772Z","comments":true,"path":"404/index.html","permalink":"https://miustannis.github.io/404/index.html","excerpt":"","text":""}],"posts":[{"title":"å›é¡¾ç»å…¸é¡¹ç›®Webserver","slug":"260216","date":"2026-02-16T04:22:29.000Z","updated":"2026-02-21T14:08:41.854Z","comments":true,"path":"2026/02/16/260216/","link":"","permalink":"https://miustannis.github.io/2026/02/16/260216/","excerpt":"","text":"å›é¡¾ä¸€ä¸‹ä¹‹å‰åšçš„è½»é‡çº§é«˜å¹¶å‘ç½‘ç»œæœåŠ¡å™¨é¡¹ç›® é¡¹ç›®éƒ¨ç½²åœ¨VMwareçš„ä¹Œç­å›¾ç³»ç»Ÿä¸Šï¼Œè¿è¡Œæ•ˆæœå¦‚ä¸‹ï¼š ç»ˆç«¯å¯åŠ¨ï¼š æµè§ˆå™¨è®¿é—®ï¼š ç³»ç»Ÿæµç¨‹ä¸»çº¿ç¨‹ç”¨epollè¿™ç§å¤šè·¯å¤ç”¨æœºåˆ¶ç›‘å¬å®¢æˆ·ç«¯è¿æ¥ï¼Œå½“æœ‰readæˆ–è€…writeäº‹ä»¶å‘å‡ºè¯·æ±‚æ—¶ï¼Œå°†è¯·æ±‚åŠ å…¥åˆ°çº¿ç¨‹æ± ï¼Œçº¿ç¨‹æ± ä¸­çš„ä¸€ä¸ªçº¿ç¨‹äº‰æŠ¢åˆ°é”ï¼Œå¼€å§‹æ‰§è¡Œä»»åŠ¡ï¼Œä»»åŠ¡åŒ…æ‹¬è§£æè¯·æ±‚ä¸ç”Ÿæˆå“åº”ï¼ŒåŒ…æ‹¬å¯¹ä¿¡å·çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–ï¼Œæœ€ç»ˆå‘å¸ƒçš„é™æ€èµ„æºä¸ºjsé¡µé¢ï¼Œè¿™é‡Œç®€å•è®©aiå†™äº†ä¸€ä¸ªç”µå­æœ¨é±¼çš„æ•ˆæœå¹¶è¿›è¡Œä¸€äº›æ¶¦è‰²ï¼Œç³»ç»Ÿé€‚é…Linuxã€‚ çº¿ç¨‹æ± ç±» head-only threadpool class #ifndef THREADPOOL_H #define THREADPOOL_H #include &lt;pthread.h> #include &lt;cstdio> #include &lt;list> #include &lt;exception> #include \"locker.h\" using namespace std; // çº¿ç¨‹æ± ç±» template&lt;typename T> class threadpool &#123; private: // çº¿ç¨‹æ•°é‡ int m_thread_number; // çº¿ç¨‹æ± æ•°ç»„ pthread_t * m_threadpool; // è¯·æ±‚é˜Ÿåˆ—ä¸­æœ€å¤šå…è®¸çš„ç­‰å¾…å¤„ç†è¯·æ±‚æ•°é‡ int m_maxrequestnum; // è¯·æ±‚é˜Ÿåˆ— list&lt;T* > m_workqueue; // äº’æ–¥é” locker m_queuelocker; // ä¿¡å·é‡ ç”¨æ¥åˆ¤æ–­æ˜¯å¦æœ‰ä»»åŠ¡éœ€è¦å¤„ç† sem m_queuestat; // æ˜¯å¦ç»“æŸçº¿ç¨‹ bool m_stop; private: static void* worker(void*); void run(); public: threadpool(int thread_number = 8, int max_request = 10000); ~threadpool(); // æ·»åŠ ä»»åŠ¡ bool append(T* request); &#125;; /** * @brief æ„é€ çº¿ç¨‹æ± å¹¶åˆ›å»ºå·¥ä½œçº¿ç¨‹ * @param thread_number çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ•°é‡ï¼ˆé»˜è®¤ 8ï¼‰ * @param max_request è¯·æ±‚é˜Ÿåˆ—æœ€å¤§å®¹é‡ï¼ˆé»˜è®¤ 10000ï¼‰ * @throws exception æ„é€ å‚æ•°ä¸åˆæ³•æˆ–çº¿ç¨‹åˆ›å»º/åˆ†ç¦»å¤±è´¥æ—¶æŠ›å‡º */ template &lt;typename T> threadpool&lt;T> :: threadpool(int thread_number, int max_request): m_thread_number(thread_number), m_maxrequestnum(max_request), m_threadpool(NULL), m_stop(false)&#123; if ((thread_number &lt;= 0) || (max_request &lt;= 0)) throw exception(); m_threadpool = new pthread_t[m_thread_number]; if (!m_threadpool) throw exception(); // åˆ›å»ºthread_num ä¸ªçº¿ç¨‹ï¼Œå¹¶è®¾ç½®ä¸ºdetach for (int i = 0; i &lt; thread_number; i++)&#123; printf(\"create %d thread\\n\", i); // worker å¿…é¡»ä¸ºstatic, this ä¼ å‚ if (pthread_create(m_threadpool + i, NULL, worker, this) != 0)&#123; delete [] m_threadpool; throw exception(); &#125; if (pthread_detach(m_threadpool[i]))&#123; delete [] m_threadpool; throw exception(); &#125; &#125; &#125; /** * @brief ææ„å‡½æ•°ï¼Œæ¸…ç†çº¿ç¨‹æ•°ç»„å¹¶æ ‡è®°åœæ­¢ * @note è¿™é‡Œæ²¡æœ‰ç­‰å¾…çº¿ç¨‹ç»“æŸï¼ˆçº¿ç¨‹åˆ›å»ºæ—¶ä¸º detachedï¼‰ï¼Œéœ€è¦ç¡®ä¿å…¶ä»–èµ„æºå¯å®‰å…¨é‡Šæ”¾ */ template &lt;typename T> threadpool&lt;T> :: ~threadpool()&#123; delete [] m_threadpool; m_stop = true; &#125; /** * @brief å‘çº¿ç¨‹æ± çš„ä»»åŠ¡é˜Ÿåˆ—æ·»åŠ ä¸€ä¸ªä»»åŠ¡æŒ‡é’ˆ * @param request å¾…å¤„ç†ä»»åŠ¡ï¼ˆT*ï¼‰ * @return æ·»åŠ æˆåŠŸè¿”å› trueï¼›é˜Ÿåˆ—å·²æ»¡è¿”å› false */ template &lt;typename T> bool threadpool&lt;T> :: append(T* request)&#123; m_queuelocker.lock(); // è¶…å‡ºæœ€å¤§æ•°é‡èŒƒå›´ if (m_workqueue.size() > m_maxrequestnum)&#123; m_queuelocker.unlock(); return false; &#125; m_workqueue.push_back(request); m_queuelocker.unlock(); m_queuestat.post(); return true; &#125; /** * @brief å·¥ä½œçº¿ç¨‹å…¥å£å‡½æ•°ï¼ˆstaticï¼‰ï¼Œç”¨äº pthread_create çš„å›è°ƒ * @param arg ä¼ å…¥çš„ threadpool å¯¹è±¡æŒ‡é’ˆ * @return è¿”å›ä¼ å…¥æŒ‡é’ˆï¼ˆæˆ–è€… nullptrï¼‰ */ template &lt;typename T> void * threadpool&lt;T> :: worker(void *arg)&#123; threadpool* pool = (threadpool *)arg; pool->run(); return pool; &#125; /** * @brief å·¥ä½œçº¿ç¨‹çš„å®é™…å¾ªç¯ä½“ï¼Œç­‰å¾…ä¿¡å·é‡å¹¶ä»é˜Ÿåˆ—ä¸­å–å‡ºä»»åŠ¡æ‰§è¡Œ * @note æŒç»­è¿è¡Œç›´åˆ° m_stop è¢«è®¾ç½®ä¸º true */ template &lt;typename T> void threadpool&lt;T> :: run()&#123; while(!m_stop)&#123; m_queuestat.wait(); m_queuelocker.lock(); if (m_workqueue.empty())&#123; m_queuelocker.unlock(); continue; &#125; T* request = m_workqueue.front(); m_workqueue.pop_front(); m_queuelocker.unlock(); if (!request) continue; request->process(); &#125; &#125; #endif &nbsp; çº¿ç¨‹åŒæ­¥å°è£…ç±» threadsemaphore class #ifndef LOCKER_H #define LOCKER_H #include &lt;pthread.h> #include &lt;exception> #include &lt;semaphore.h> using namespace std; // çº¿ç¨‹åŒæ­¥å°è£…ï¼Œæ–¹ä¾¿ä½¿ç”¨ // äº’æ–¥é”ç±» class locker&#123; public: locker()&#123; if (pthread_mutex_init(&amp;m_mutex, NULL) != 0)&#123; throw exception(); &#125; &#125; ~locker()&#123; pthread_mutex_destroy(&amp;m_mutex); &#125; //ä¸Šé” bool lock()&#123; return pthread_mutex_lock(&amp;m_mutex) == 0; &#125; //è§£é” bool unlock()&#123; return pthread_mutex_unlock(&amp;m_mutex) == 0; &#125; //è¿”å›äº’æ–¥é‡ pthread_mutex_t * get()&#123; return &amp;m_mutex; &#125; private: pthread_mutex_t m_mutex; &#125;; // æ¡ä»¶å˜é‡ç±» class cond&#123; public: cond()&#123; if (pthread_cond_init(&amp;m_cond, NULL) != 0)&#123; throw exception(); &#125; &#125; ~cond()&#123; pthread_cond_destroy(&amp;m_cond); &#125; bool wait(pthread_mutex_t * mutex)&#123; return pthread_cond_wait(&amp;m_cond, mutex) == 0; &#125; bool timewait(pthread_mutex_t * mutex, struct timespec t)&#123; return pthread_cond_timedwait(&amp;m_cond, mutex, &amp;t) == 0; &#125; bool signal(pthread_mutex_t * mutex)&#123; return pthread_cond_signal(&amp;m_cond) == 0; &#125; bool broadcast()&#123; return pthread_cond_broadcast(&amp;m_cond) == 0; &#125; private: pthread_cond_t m_cond; &#125;; // ä¿¡å·é‡ç±» class sem&#123; public: sem()&#123; if (sem_init(&amp;m_sem, 0, 0) != 0) throw exception(); &#125; sem(int num)&#123; if (sem_init(&amp;m_sem, 0, num) != 0) throw exception(); &#125; ~sem()&#123; sem_destroy(&amp;m_sem); &#125; // ç­‰å¾…ä¿¡å·é‡ bool wait()&#123; return sem_wait(&amp;m_sem) == 0; &#125; // å¢åŠ ä¿¡å·é‡ bool post()&#123; return sem_post(&amp;m_sem) == 0; &#125; private: sem_t m_sem; &#125;; #endif &nbsp; Httpè§£æç±» head-only httpparse cpp #include \"http_conn.h\" // æ¨¡å—èŒè´£ä¸è¿æ¥ç”Ÿå‘½å‘¨æœŸè¯´æ˜ï¼š // - http_conn å¯¹è±¡ä»£è¡¨ä¸€ä¸ªå®¢æˆ·ç«¯è¿æ¥ï¼ŒåŒ…å«è¯»å†™ç¼“å†²ã€è§£æçŠ¶æ€æœºã€ä¸æ–‡ä»¶æ˜ å°„çŠ¶æ€ã€‚ // - ç”Ÿå‘½å‘¨æœŸæ¦‚è¿°ï¼šinit(sockfd) -> ä¸»çº¿ç¨‹è§¦å‘ EPOLLIN -> http_conn::read() è¯»å–æ‰€æœ‰å¯è¯»æ•°æ® -> å°†å¯¹è±¡äº¤ç»™çº¿ç¨‹æ± å¤„ç†(process) -> // çº¿ç¨‹æ± çº¿ç¨‹ä¸­æ‰§è¡Œ process_read()ï¼ˆä¸»çŠ¶æ€æœº + ä»çŠ¶æ€æœºè§£æè¯·æ±‚ï¼‰ï¼Œè‹¥å¾—åˆ°å®Œæ•´è¯·æ±‚åˆ™ process_write() å¡«å……å“åº”å¹¶è®¾ç½® m_ivï¼Œ // æœ€ç»ˆé€šè¿‡ modifyfd å°†è¯¥ fd çš„ epoll äº‹ä»¶æ”¹ä¸º EPOLLOUT è§¦å‘ä¸»çº¿ç¨‹å†™å‡ºï¼›å†™å®Œåæ ¹æ® Connection å†³å®šæ˜¯å¦ keep-alive æˆ–å…³é—­è¿æ¥ã€‚ // - epoll ä¸ EPOLLONESHOTï¼šæ¯æ¬¡å°† fd æ³¨å†Œä¸º EPOLLONESHOTï¼Œå¤„ç†çº¿ç¨‹åœ¨å®Œæˆä¸€æ¬¡è¯»å–/å†™å…¥åå¿…é¡»è°ƒç”¨ modifyfd æ¢å¤äº‹ä»¶ï¼Œ // ä»¥ä¿è¯ä¸ä¼šæœ‰å¤šä¸ªçº¿ç¨‹åŒæ—¶å¤„ç†åŒä¸€ fdï¼ˆé¿å…å¹¶å‘ç«æ€ï¼‰ã€‚ // // è§£æ/å“åº”å…³é”®ç‚¹ï¼š // - ä¸»çŠ¶æ€æœºï¼šCHECK_STATE_REQUESTLINE -> CHECK_STATE_HEADER -> CHECK_STATE_CONTENTï¼›parse_line() ç”¨äºæŒ‰ CRLF åˆ†å‰²è¡Œã€‚ // - å¯¹é™æ€æ–‡ä»¶è¯·æ±‚ï¼šdo_request ä½¿ç”¨ stat æ£€æŸ¥å¹¶ç”¨ mmap æ˜ å°„æ–‡ä»¶åˆ°å†…å­˜ï¼Œresponse é€šè¿‡ writev å‘é€å¤´éƒ¨ä¸æ˜ å°„åŒºä¸¤æ®µå†…å­˜ã€‚ // - éé˜»å¡è¯»å†™ï¼šread() å¾ªç¯ recv ç›´åˆ°è¿”å› EAGAIN/EWOULDBLOCKï¼›write() ä½¿ç”¨ writevï¼Œåœ¨ EAGAIN æ—¶ä¿®æ”¹ä¸º EPOLLOUT ç­‰å¾…ä¸‹ä¸€æ¬¡å¯å†™ã€‚ int http_conn :: m_epollfd = -1; // æ‰€æœ‰socketä¸Šäº‹ä»¶æ³¨å†Œåˆ°åŒä¸€ä¸ªepoll int http_conn :: m_user_count = 0; //ç»Ÿè®¡ç”¨æˆ·æ•°é‡ // å®šä¹‰HTTPå“åº”çš„ä¸€äº›çŠ¶æ€ä¿¡æ¯ const char* ok_200_title = \"OK\"; const char* error_400_title = \"Bad Request\"; const char* error_400_form = \"Your request has bad syntax or is inherently impossible to satisfy.\\n\"; const char* error_403_title = \"Forbidden\"; const char* error_403_form = \"You do not have permission to get file from this server.\\n\"; const char* error_404_title = \"Not Found\"; const char* error_404_form = \"The requested file was not found on this server.\\n\"; const char* error_500_title = \"Internal Error\"; const char* error_500_form = \"There was an unusual problem serving the requested file.\\n\"; const char* doc_root = \"./resources\"; /** * @brief å°†æ–‡ä»¶æè¿°ç¬¦è®¾ç½®ä¸ºéé˜»å¡æ¨¡å¼ * @param fd è¦è®¾ç½®çš„æ–‡ä»¶æè¿°ç¬¦ * @return è¿”å›åŸæœ‰çš„æ–‡ä»¶çŠ¶æ€æ ‡å¿—ï¼ˆold_flagï¼‰ï¼Œè°ƒç”¨è€…å¯ç”¨äºæ¢å¤ */ int setnonblocking(int fd)&#123; int old_flag = fcntl(fd, F_GETFL); int new_flag = old_flag | O_NONBLOCK; fcntl(fd, F_SETFL, new_flag); return old_flag; &#125; /** * @brief å°† fd æ·»åŠ åˆ° epoll å®ä¾‹å¹¶è®¾ç½®è§¦å‘æ¨¡å¼ä¸éé˜»å¡ * @param epollfd epoll å®ä¾‹çš„æ–‡ä»¶æè¿°ç¬¦ * @param fd è¦æ·»åŠ çš„æ–‡ä»¶æè¿°ç¬¦ * @param one_shot æ˜¯å¦ä½¿ç”¨ EPOLLONESHOTï¼ˆé˜²æ­¢å¹¶å‘å¤„ç†åŒä¸€è¿æ¥ï¼‰ */ void addfd(int epollfd, int fd, bool one_shot)&#123; epoll_event event; event.data.fd = fd; // æ­¤å¤„ä¿®æ”¹è§¦å‘æ¨¡å¼ event.events = EPOLLIN | EPOLLET | EPOLLRDHUP; // ET //event.events = EPOLLIN | EPOLLRDHUP; // LT if (one_shot)&#123; event.events |= EPOLLONESHOT; &#125; epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event); // è®¾ç½®æ–‡ä»¶æè¿°ç¬¦éé˜»å¡ setnonblocking(fd); &#125; /** * @brief ä» epoll ä¸­åˆ é™¤ fd å¹¶å…³é—­è¯¥æè¿°ç¬¦ * @param epollfd epoll å®ä¾‹çš„æ–‡ä»¶æè¿°ç¬¦ * @param fd è¦åˆ é™¤å¹¶å…³é—­çš„æ–‡ä»¶æè¿°ç¬¦ */ void removefd(int epollfd, int fd)&#123; epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, 0); close(fd); &#125; /** * @brief ä¿®æ”¹ epoll ä¸­ fd çš„äº‹ä»¶ï¼ˆå¹¶é‡ç½® EPOLLONESHOTï¼‰ * @param epollfd epoll å®ä¾‹çš„æ–‡ä»¶æè¿°ç¬¦ * @param fd ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦ * @param ev è¦è®¾ç½®çš„äº‹ä»¶æ©ç ï¼ˆå¦‚ EPOLLIN/EPOLLOUTï¼‰ */ void modifyfd(int epollfd, int fd ,int ev)&#123; epoll_event event; event.data.fd = fd; event.events = ev | EPOLLONESHOT | EPOLLRDHUP | EPOLLET ; // åŒæ­¥ä¿®æ”¹è§¦å‘æ¨¡å¼ epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event); &#125; /** * @brief åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„å®¢æˆ·ç«¯è¿æ¥ï¼ˆç»‘å®š socket åˆ° http_conn å¯¹è±¡ï¼‰ * @param sockfd å®¢æˆ·ç«¯è¿æ¥çš„ socket æ–‡ä»¶æè¿°ç¬¦ * @param addr å®¢æˆ·ç«¯åœ°å€ä¿¡æ¯ * @note ä¼šå°† socket æ·»åŠ åˆ° epollï¼Œè®¾ç½®ä¸º EPOLLONESHOTï¼Œå¹¶æ›´æ–°è¿æ¥è®¡æ•° */ void http_conn:: init(int sockfd, const sockaddr_in &amp;addr)&#123; m_sockfd = sockfd; m_address = addr; // è®¾ç½®ç«¯å£å¤ç”¨ int reuse = 1; setsockopt(m_sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse)); // æ·»åŠ åˆ°epolläº‹ä»¶ç»„ä¸­ addfd(m_epollfd, m_sockfd, true); m_user_count++; init(); &#125; /** * @brief é‡ç½®è¿æ¥è§£æ/è¯»å†™çŠ¶æ€ï¼Œå‡†å¤‡å¤„ç†æ–°è¯·æ±‚ * @note è¯¥å‡½æ•°ä¸ä¼šå…³é—­ socketï¼Œä»…é‡ç½®çŠ¶æ€æœºä¸ç¼“å†²åŒº */ void http_conn :: init()&#123; m_check_state = CHECK_STATE_REQUESTLINE; // åˆå§‹çŠ¶æ€ä¸ºæ£€æŸ¥è¯·æ±‚è¡Œ m_linger = false; // é»˜è®¤ä¸ä¿æŒé“¾æ¥ Connection : keep-aliveä¿æŒè¿æ¥ m_method = GET; // é»˜è®¤è¯·æ±‚æ–¹å¼ä¸ºGET m_url = 0; m_version = 0; m_content_length = 0; m_host = 0; m_start_line = 0; m_checked_index = 0; m_read_idx = 0; m_write_idx = 0; bzero(m_read_buf, READ_BUFFER_SIZE); bzero(m_write_buf, READ_BUFFER_SIZE); bzero(m_real_file, FILENAME_LEN); &#125; /** * @brief å…³é—­å½“å‰è¿æ¥å¹¶ä» epoll ä¸­ç§»é™¤ * @note ä¼šå°† m_sockfd ç½® -1 å¹¶å‡å°‘å…¨å±€è¿æ¥è®¡æ•° */ void http_conn :: closeconn()&#123; if (m_sockfd != -1)&#123; removefd(m_epollfd, m_sockfd); m_sockfd = -1; m_user_count--; // å…³é—­ä¸€ä¸ªè¿æ¥ï¼Œå®¢æˆ·æ€»æ•°é‡å‡1 &#125; &#125; /** * @brief éé˜»å¡è¯»å–æ•°æ®ï¼Œç›´åˆ°ç¼“å†²åŒºæ»¡æˆ–æ²¡æœ‰æ›´å¤šæ•°æ® * @return è‹¥æˆåŠŸè¯»å–ï¼ˆæˆ–æš‚æ—¶æ— æ›´å¤šæ•°æ®ï¼‰è¿”å› trueï¼›å‘ç”Ÿé”™è¯¯æˆ–å¯¹ç«¯å…³é—­è¿”å› false */ bool http_conn ::read()&#123; if (m_read_idx >= READ_BUFFER_SIZE) return false; // è¯»å–åˆ°çš„å­—èŠ‚ int bytes_read = 0; while (true)&#123; bytes_read = recv(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, 0); if (bytes_read == -1)&#123; if (errno == EAGAIN || errno == EWOULDBLOCK) &#123; // æ²¡æœ‰æ•°æ® break; &#125; return false; &#125;else if (bytes_read == 0) return false; m_read_idx += bytes_read; &#125; //printf(\"read: %s\\n\", m_read_buf); return true; &#125; /** * @brief å‘å®¢æˆ·ç«¯å†™å‡ºå‡†å¤‡å¥½çš„ HTTP å“åº”ï¼Œä½¿ç”¨ writev åˆ†æ•£å†™ * @return å‘é€å®Œæˆå¹¶ä¿æŒè¿æ¥è¿”å› trueï¼›å‘é€å®Œæˆä½†éœ€è¦å…³é—­è¿æ¥è¿”å› falseï¼›å‡ºé”™è¿”å› false * @note åœ¨ EAGAIN æƒ…å†µä¸‹ä¼šå°†äº‹ä»¶ä¿®æ”¹ä¸º EPOLLOUT å¹¶è¿”å› trueï¼ˆç­‰å¾…ä¸‹ä¸€æ¬¡å¯å†™ï¼‰ */ bool http_conn::write() &#123; int temp = 0; int bytes_have_send = 0; // å·²ç»å‘é€çš„å­—èŠ‚ int bytes_to_send = m_write_idx;// å°†è¦å‘é€çš„å­—èŠ‚ ï¼ˆm_write_idxï¼‰å†™ç¼“å†²åŒºä¸­å¾…å‘é€çš„å­—èŠ‚æ•° if ( bytes_to_send == 0 ) &#123; // å°†è¦å‘é€çš„å­—èŠ‚ä¸º0ï¼Œè¿™ä¸€æ¬¡å“åº”ç»“æŸã€‚ modifyfd( m_epollfd, m_sockfd, EPOLLIN ); init(); return true; &#125; while(1) &#123; // åˆ†æ•£å†™ temp = writev(m_sockfd, m_iv, m_iv_count); if ( temp &lt;= -1 ) &#123; // å¦‚æœTCPå†™ç¼“å†²æ²¡æœ‰ç©ºé—´ï¼Œåˆ™ç­‰å¾…ä¸‹ä¸€è½®EPOLLOUTäº‹ä»¶ï¼Œè™½ç„¶åœ¨æ­¤æœŸé—´ï¼Œ // æœåŠ¡å™¨æ— æ³•ç«‹å³æ¥æ”¶åˆ°åŒä¸€å®¢æˆ·çš„ä¸‹ä¸€ä¸ªè¯·æ±‚ï¼Œä½†å¯ä»¥ä¿è¯è¿æ¥çš„å®Œæ•´æ€§ã€‚ if( errno == EAGAIN ) &#123; modifyfd( m_epollfd, m_sockfd, EPOLLOUT ); return true; &#125; unmap(); return false; &#125; bytes_to_send -= temp; bytes_have_send += temp; if ( bytes_to_send &lt;= bytes_have_send ) &#123; // å‘é€HTTPå“åº”æˆåŠŸï¼Œæ ¹æ®HTTPè¯·æ±‚ä¸­çš„Connectionå­—æ®µå†³å®šæ˜¯å¦ç«‹å³å…³é—­è¿æ¥ unmap(); if(m_linger) &#123; init(); modifyfd( m_epollfd, m_sockfd, EPOLLIN ); return true; &#125; else &#123; modifyfd( m_epollfd, m_sockfd, EPOLLIN ); return false; &#125; &#125; &#125; &#125; /** * @brief çº¿ç¨‹æ± ä¸­å·¥ä½œçº¿ç¨‹è°ƒç”¨çš„å…¥å£ï¼Œå¤„ç†è¯¥è¿æ¥çš„è¯·æ±‚ * @note åŒ…å«è§£æè¯·æ±‚ã€ç”Ÿæˆå“åº”å¹¶ä¿®æ”¹ epoll äº‹ä»¶ä»¥è§¦å‘å†™å‡º */ void http_conn :: process()&#123; // è§£æHTTPè¯·æ±‚ HTTP_CODE read_ret = process_read(); if (read_ret == NO_REQUEST)&#123; modifyfd(m_epollfd, m_sockfd, EPOLLIN); return; &#125; // ç”Ÿæˆå“åº” bool write_ret = process_write( read_ret ); if ( !write_ret ) &#123; closeconn(); &#125; modifyfd( m_epollfd, m_sockfd, EPOLLOUT); &#125; /** * @brief ä¸»çŠ¶æ€æœºï¼šè§£æ HTTP è¯·æ±‚ï¼ˆè¯·æ±‚è¡Œã€å¤´éƒ¨ã€å†…å®¹ï¼‰ * @return è§£æç»“æœæšä¸¾ï¼ˆNO_REQUEST, GET_REQUEST, BAD_REQUEST ...ï¼‰ * @note ä½¿ç”¨ parse_line æ‹†åˆ†è¡Œï¼Œå¾ªç¯ç›´åˆ°æ— æ³•ç»§ç»­è§£æ */ http_conn :: HTTP_CODE http_conn :: process_read()&#123; LINE_STATUS line_status = LINE_OK; HTTP_CODE ret = NO_REQUEST; char *text = 0; while (((m_check_state == CHECK_STATE_CONTENT) &amp;&amp; (line_status == LINE_OK)) || (line_status = parse_line()) == LINE_OK)&#123; // è§£æåˆ°äº†ä¸€è¡Œå®Œæ•´çš„æ•°æ® æˆ– è§£æåˆ°è¯·æ±‚ä½“ï¼Œä¹Ÿæ˜¯å®Œæ•´çš„æ•°æ® // è·å–ä¸€è¡Œæ•°æ® text = get_line(); m_start_line = m_checked_index; printf(\"got 1 http line:%s\\n\", text); switch (m_check_state) &#123; case CHECK_STATE_REQUESTLINE: &#123; ret = parse_request_line(text); if(ret == BAD_REQUEST)&#123; return BAD_REQUEST; &#125; break; &#125; case CHECK_STATE_HEADER: /* code */ &#123; ret = parse_headers(text); if(ret == BAD_REQUEST)&#123; return BAD_REQUEST; &#125;else if (ret == GET_REQUEST)&#123; return do_request(); // è§£æå…·ä½“ä¿¡æ¯ &#125; break; &#125; case CHECK_STATE_CONTENT: /* code */ &#123; ret = parse_content(text); if (ret == GET_REQUEST)&#123; return do_request(); &#125; line_status = LINE_OPEN; break; &#125; default: &#123; return INTERNAL_ERROR; &#125; &#125; &#125; return NO_REQUEST; &#125; /** * @brief è§£æè¯·æ±‚è¡Œï¼Œå–å¾—è¯·æ±‚æ–¹æ³•ã€URLã€HTTP ç‰ˆæœ¬ * @param text è¯·æ±‚è¡Œå­—ç¬¦ä¸²ï¼ˆä»¥ '\\0' ç»“å°¾ï¼‰ * @return è§£æç»“æœæšä¸¾ï¼ˆNO_REQUEST è¡¨ç¤ºç»§ç»­è§£æï¼ŒBAD_REQUEST è¡¨ç¤ºæ ¼å¼é”™è¯¯ï¼‰ */ http_conn :: HTTP_CODE http_conn :: parse_request_line(char *text)&#123; // GET /index.html HTTP/1.1 m_url = strpbrk(text , \" \\t\"); if (!m_url)&#123; return BAD_REQUEST; &#125; // GET\\0/index.html HTTP/1.1 *m_url++ = '\\0'; // å…ˆç”¨åŸå€¼èµ‹\\0ï¼Œ å++ï¼Œ // GET\\0 å­—ç¬¦ä¸²ç»“æŸç¬¦æˆªæ–­ char* method = text; if (strcasecmp(method, \"GET\") == 0)&#123; m_method = GET; &#125;else &#123; return BAD_REQUEST; &#125; // /index.html HTTP/1.1 m_version = strpbrk(m_url, \" \\t\"); if (!m_version)&#123; return BAD_REQUEST; &#125; // /index.html\\0HTTP/1.1 *m_version++ = '\\0'; if (strcasecmp(m_version, \"HTTP/1.1\") != 0)&#123; return BAD_REQUEST; &#125; // http://192.168.1.1:10000/index.html if (strncasecmp(m_url, \"http://\", 7) == 0)&#123; m_url += 7; // 192.168.1.1:10000/index.html m_url = strchr(m_url, '/'); // /index.html &#125; if (!m_url || m_url[0] != '/')&#123; return BAD_REQUEST; &#125; m_check_state = CHECK_STATE_HEADER; // æ”¹å˜ä¸»çŠ¶æ€æœºçŠ¶æ€ return NO_REQUEST; &#125; /** * @brief è§£æè¯·æ±‚å¤´éƒ¨å­—æ®µï¼ˆé€è¡Œè°ƒç”¨ï¼‰ * @param text å½“å‰å¤´éƒ¨è¡Œï¼ˆä»¥ '\\0' ç»“å°¾ï¼‰ï¼Œç©ºè¡Œè¡¨ç¤ºå¤´éƒ¨ç»“æŸ * @return GET_REQUEST è¡¨ç¤ºå¤´éƒ¨è§£æå®Œæˆä¸”æ— æ¶ˆæ¯ä½“ï¼›NO_REQUEST è¡¨ç¤ºç»§ç»­è§£æï¼›BAD_REQUEST è¡¨ç¤ºé”™è¯¯ */ http_conn :: HTTP_CODE http_conn :: parse_headers(char *text)&#123; // é‡åˆ°ç©ºè¡Œï¼Œè¡¨ç¤ºå¤´éƒ¨å­—æ®µè§£æå®Œæ¯• if( text[0] == '\\0' ) &#123; // å¦‚æœHTTPè¯·æ±‚æœ‰æ¶ˆæ¯ä½“ï¼Œåˆ™è¿˜éœ€è¦è¯»å–m_content_lengthå­—èŠ‚çš„æ¶ˆæ¯ä½“ï¼Œ // çŠ¶æ€æœºè½¬ç§»åˆ°CHECK_STATE_CONTENTçŠ¶æ€ if ( m_content_length != 0 ) &#123; m_check_state = CHECK_STATE_CONTENT; return NO_REQUEST; &#125; // å¦åˆ™è¯´æ˜å·²ç»å¾—åˆ°äº†ä¸€ä¸ªå®Œæ•´çš„HTTPè¯·æ±‚ return GET_REQUEST; &#125; else if ( strncasecmp( text, \"Connection:\", 11 ) == 0 ) &#123; // å¤„ç†Connection å¤´éƒ¨å­—æ®µ Connection: keep-alive text += 11; text += strspn( text, \" \\t\" ); if ( strcasecmp( text, \"keep-alive\" ) == 0 ) &#123; m_linger = true; &#125; &#125; else if ( strncasecmp( text, \"Content-Length:\", 15 ) == 0 ) &#123; // å¤„ç†Content-Lengthå¤´éƒ¨å­—æ®µ text += 15; text += strspn( text, \" \\t\" ); m_content_length = atol(text); &#125; else if ( strncasecmp( text, \"Host:\", 5 ) == 0 ) &#123; // å¤„ç†Hostå¤´éƒ¨å­—æ®µ text += 5; text += strspn( text, \" \\t\" ); m_host = text; &#125; else &#123; printf( \"oops! unknow header %s\\n\", text ); &#125; return NO_REQUEST; &#125; /** * @brief æ£€æŸ¥è¯·æ±‚ä½“æ˜¯å¦å·²å…¨éƒ¨è¯»å…¥ï¼ˆä¸åšå…·ä½“è§£æï¼‰ * @param text æŒ‡å‘è¯·æ±‚ä½“ï¼ˆèµ·å§‹ä½ç½®ï¼‰ * @return è‹¥è¯»å–å®Œæ¯•è¿”å› GET_REQUESTï¼Œå¦åˆ™è¿”å› NO_REQUEST */ http_conn::HTTP_CODE http_conn::parse_content( char* text ) &#123; if ( m_read_idx >= ( m_content_length + m_checked_index ) ) &#123; text[ m_content_length ] = '\\0'; return GET_REQUEST; &#125; return NO_REQUEST; &#125; /** * @brief æŒ‰è¡Œè§£æè¯»ç¼“å†²åŒºï¼Œåˆ¤æ–­æ˜¯å¦é‡åˆ° CRLF ç»“æŸ * @return LINE_OK / LINE_BAD / LINE_OPEN */ http_conn :: LINE_STATUS http_conn :: parse_line()&#123; char temp; for (; m_checked_index &lt; m_read_idx; ++ m_checked_index)&#123; temp = m_read_buf[m_checked_index]; if(temp == '\\r')&#123; if((m_checked_index + 1) == m_read_idx) return LINE_OPEN; else if (m_read_buf[m_checked_index + 1]== '\\n') &#123; m_read_buf[m_checked_index++] = '\\0'; m_read_buf[m_checked_index++] = '\\0'; return LINE_OK; &#125; return LINE_BAD; &#125;else if (temp == '\\n')&#123; if((m_checked_index > 1) &amp;&amp; (m_read_buf[m_checked_index-1] == '\\r'))&#123; m_read_buf[m_checked_index-1] = '\\0'; m_read_buf[m_checked_index++] = '\\0'; return LINE_OK; &#125; return LINE_BAD; &#125; &#125; return LINE_OPEN; &#125; /** * @brief æ ¹æ®è§£æåçš„ URL åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­æŸ¥æ‰¾ç›®æ ‡æ–‡ä»¶å¹¶ mmap æ˜ å°„ * @return FILE_REQUEST è¡¨ç¤ºæ–‡ä»¶è¯·æ±‚æˆåŠŸï¼Œå¦åˆ™è¿”å›ç›¸åº”é”™è¯¯ç±»å‹ï¼ˆNO_RESOURCE/FORBIDDEN_REQUEST ç­‰ï¼‰ */ http_conn::HTTP_CODE http_conn::do_request() &#123; // \"/home/miao/TinyWebserver/resources\" strcpy( m_real_file, doc_root ); int len = strlen( doc_root ); strncpy( m_real_file + len, m_url, FILENAME_LEN - len - 1 ); // è·å–m_real_fileæ–‡ä»¶çš„ç›¸å…³çš„çŠ¶æ€ä¿¡æ¯ï¼Œ-1å¤±è´¥ï¼Œ0æˆåŠŸ if ( stat( m_real_file, &amp;m_file_stat ) &lt; 0 ) &#123; return NO_RESOURCE; &#125; // åˆ¤æ–­è®¿é—®æƒé™ if ( ! ( m_file_stat.st_mode &amp; S_IROTH ) ) &#123; return FORBIDDEN_REQUEST; &#125; // åˆ¤æ–­æ˜¯å¦æ˜¯ç›®å½• if ( S_ISDIR( m_file_stat.st_mode ) ) &#123; return BAD_REQUEST; &#125; // ä»¥åªè¯»æ–¹å¼æ‰“å¼€æ–‡ä»¶ int fd = open( m_real_file, O_RDONLY ); // åˆ›å»ºå†…å­˜æ˜ å°„ m_file_address = ( char* )mmap( 0, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, 0 ); close( fd ); return FILE_REQUEST; &#125; /** * @brief è§£é™¤å¯¹æ–‡ä»¶æ˜ å°„çš„æ˜ å°„å¹¶æ¸…ç† m_file_address */ void http_conn::unmap() &#123; if( m_file_address ) &#123; munmap( m_file_address, m_file_stat.st_size ); m_file_address = 0; &#125; &#125; /** * @brief å‘å†™ç¼“å†²è¿½åŠ æ ¼å¼åŒ–å“åº”æ–‡æœ¬ï¼ˆå¯å˜å‚æ•°ï¼‰ * @param format printf é£æ ¼çš„æ ¼å¼å­—ç¬¦ä¸² * @return æˆåŠŸè¿”å› trueï¼Œå†™å…¥è¶…é™è¿”å› false */ bool http_conn::add_response( const char* format, ... ) &#123; if( m_write_idx >= WRITE_BUFFER_SIZE ) &#123; return false; &#125; va_list arg_list; va_start( arg_list, format ); int len = vsnprintf( m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - 1 - m_write_idx, format, arg_list ); if( len >= ( WRITE_BUFFER_SIZE - 1 - m_write_idx ) ) &#123; return false; &#125; m_write_idx += len; va_end( arg_list ); return true; &#125; /** * @brief æ·»åŠ çŠ¶æ€è¡Œï¼Œæ¯”å¦‚ \"HTTP/1.1 200 OK\" */ bool http_conn::add_status_line( int status, const char* title ) &#123; return add_response( \"%s %d %s\\r\\n\", \"HTTP/1.1\", status, title ); &#125; /** * @brief æ·»åŠ é€šç”¨å“åº”å¤´ï¼ˆContent-Length/Content-Type/Connection/ç©ºè¡Œï¼‰ * @param content_len æ­£æ–‡é•¿åº¦ï¼ˆå­—èŠ‚ï¼‰ * @return æ— ï¼ˆå†…éƒ¨é€šè¿‡ add_response å¡«å……ï¼‰ */ bool http_conn::add_headers(int content_len) &#123; add_content_length(content_len); add_content_type(); add_linger(); add_blank_line(); &#125; /** * @brief æ·»åŠ  Content-Length å¤´ * @param content_len æ­£æ–‡é•¿åº¦ï¼ˆå­—èŠ‚ï¼‰ */ bool http_conn::add_content_length(int content_len) &#123; return add_response( \"Content-Length: %d\\r\\n\", content_len ); &#125; /** * @brief æ·»åŠ  Connection å¤´ï¼ˆkeep-alive æˆ– closeï¼‰ */ bool http_conn::add_linger() &#123; return add_response( \"Connection: %s\\r\\n\", ( m_linger == true ) ? \"keep-alive\" : \"close\" ); &#125; /** * @brief æ·»åŠ å“åº”ç©ºè¡Œï¼Œç»“æŸ header éƒ¨åˆ† */ bool http_conn::add_blank_line() &#123; return add_response( \"%s\", \"\\r\\n\" ); &#125; /** * @brief æ·»åŠ å“åº”æ­£æ–‡å­—ç¬¦ä¸²åˆ°å†™ç¼“å†² * @param content è¦æ·»åŠ çš„æ­£æ–‡å­—ç¬¦ä¸² */ bool http_conn::add_content( const char* content ) &#123; return add_response( \"%s\", content ); &#125; /** * @brief æ·»åŠ  Content-Type å¤´ï¼ˆç›®å‰å›ºå®šä¸º text/htmlï¼‰ */ bool http_conn::add_content_type() &#123; return add_response(\"Content-Type:%s\\r\\n\", \"text/html\"); &#125; /** * @brief æ ¹æ®è§£æç»“æœæ„å»ºè¦å‘é€çš„å“åº”å†…å®¹åˆ°å†™ç¼“å†² / iov * @param ret HTTP_CODE è§£æç»“æœ * @return æˆåŠŸè¿”å› trueï¼Œå¤±è´¥è¿”å› false */ bool http_conn::process_write(HTTP_CODE ret) &#123; switch (ret) &#123; case INTERNAL_ERROR: add_status_line( 500, error_500_title ); add_headers( strlen( error_500_form ) ); if ( ! add_content( error_500_form ) ) &#123; return false; &#125; break; case BAD_REQUEST: add_status_line( 400, error_400_title ); add_headers( strlen( error_400_form ) ); if ( ! add_content( error_400_form ) ) &#123; return false; &#125; break; case NO_RESOURCE: add_status_line( 404, error_404_title ); add_headers( strlen( error_404_form ) ); if ( ! add_content( error_404_form ) ) &#123; return false; &#125; break; case FORBIDDEN_REQUEST: add_status_line( 403, error_403_title ); add_headers(strlen( error_403_form)); if ( ! add_content( error_403_form ) ) &#123; return false; &#125; break; case FILE_REQUEST: add_status_line(200, ok_200_title ); add_headers(m_file_stat.st_size); m_iv[ 0 ].iov_base = m_write_buf; m_iv[ 0 ].iov_len = m_write_idx; m_iv[ 1 ].iov_base = m_file_address; m_iv[ 1 ].iov_len = m_file_stat.st_size; m_iv_count = 2; return true; default: return false; &#125; m_iv[ 0 ].iov_base = m_write_buf; m_iv[ 0 ].iov_len = m_write_idx; m_iv_count = 1; return true; &#125; headfile #ifndef HTTP_CONNECTION_H #define HTTP_CONNECTION_H #include &lt;sys/epoll.h> #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;arpa/inet.h> #include &lt;errno.h> #include &lt;fcntl.h> #include &lt;unistd.h> #include &lt;signal.h> #include &lt;sys/stat.h> #include &lt;sys/mman.h> #include &lt;stdarg.h> #include &lt;sys/uio.h> class http_conn &#123; public: static int m_epollfd; // æ‰€æœ‰socketä¸Šäº‹ä»¶æ³¨å†Œåˆ°åŒä¸€ä¸ªepoll static int m_user_count; //ç»Ÿè®¡ç”¨æˆ·æ•°é‡ static const int READ_BUFFER_SIZE = 2048; // è¯»ç¼“å†²åŒºå¤§å° static const int WRITE_BUFFER_SIZE = 1024; // å†™ç¼“å†²åŒºå¤§å° static const int FILENAME_LEN = 200; // æ–‡ä»¶åçš„æœ€å¤§é•¿åº¦ // HTTPè¯·æ±‚æ–¹æ³•ï¼Œè¿™é‡Œåªæ”¯æŒGET enum METHOD &#123;GET = 0, POST, HEAD, PUT, DELETE, TRACE, OPTIONS, CONNECT&#125;; /* è§£æå®¢æˆ·ç«¯è¯·æ±‚æ—¶ï¼Œä¸»çŠ¶æ€æœºçš„çŠ¶æ€ CHECK_STATE_REQUESTLINE:å½“å‰æ­£åœ¨åˆ†æè¯·æ±‚è¡Œ CHECK_STATE_HEADER:å½“å‰æ­£åœ¨åˆ†æå¤´éƒ¨å­—æ®µ CHECK_STATE_CONTENT:å½“å‰æ­£åœ¨è§£æè¯·æ±‚ä½“ */ enum CHECK_STATE &#123; CHECK_STATE_REQUESTLINE = 0, CHECK_STATE_HEADER, CHECK_STATE_CONTENT &#125;; /* æœåŠ¡å™¨å¤„ç†HTTPè¯·æ±‚çš„å¯èƒ½ç»“æœï¼ŒæŠ¥æ–‡è§£æçš„ç»“æœ NO_REQUEST : è¯·æ±‚ä¸å®Œæ•´ï¼Œéœ€è¦ç»§ç»­è¯»å–å®¢æˆ·æ•°æ® GET_REQUEST : è¡¨ç¤ºè·å¾—äº†ä¸€ä¸ªå®Œæˆçš„å®¢æˆ·è¯·æ±‚ BAD_REQUEST : è¡¨ç¤ºå®¢æˆ·è¯·æ±‚è¯­æ³•é”™è¯¯ NO_RESOURCE : è¡¨ç¤ºæœåŠ¡å™¨æ²¡æœ‰èµ„æº FORBIDDEN_REQUEST : è¡¨ç¤ºå®¢æˆ·å¯¹èµ„æºæ²¡æœ‰è¶³å¤Ÿçš„è®¿é—®æƒé™ FILE_REQUEST : æ–‡ä»¶è¯·æ±‚,è·å–æ–‡ä»¶æˆåŠŸ INTERNAL_ERROR : è¡¨ç¤ºæœåŠ¡å™¨å†…éƒ¨é”™è¯¯ CLOSED_CONNECTION : è¡¨ç¤ºå®¢æˆ·ç«¯å·²ç»å…³é—­è¿æ¥äº† */ enum HTTP_CODE &#123; NO_REQUEST, GET_REQUEST, BAD_REQUEST, NO_RESOURCE, FORBIDDEN_REQUEST, FILE_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION &#125;; // ä»çŠ¶æ€æœºçš„ä¸‰ç§å¯èƒ½çŠ¶æ€ï¼Œå³è¡Œçš„è¯»å–çŠ¶æ€ï¼Œåˆ†åˆ«è¡¨ç¤º // 1.è¯»å–åˆ°ä¸€ä¸ªå®Œæ•´çš„è¡Œ 2.è¡Œå‡ºé”™ 3.è¡Œæ•°æ®å°šä¸”ä¸å®Œæ•´ enum LINE_STATUS &#123; LINE_OK = 0, LINE_BAD, LINE_OPEN &#125;; public: /// @brief å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚ void process(); /// @brief åˆå§‹åŒ–æ–°æ¥å—çš„è¿æ¥ void init(int sockfd, const sockaddr_in &amp;addr); /// @brief å…³é—­è¿æ¥ void closeconn(); /// @brief éé˜»å¡è¯» bool read(); /// @brief éé˜»å¡å†™ bool write(); public: /// @brief è§£æHTTPè¯·æ±‚ HTTP_CODE process_read(); /// @brief è§£æè¯·æ±‚é¦–è¡Œ HTTP_CODE parse_request_line(char *text); /// @brief è§£æè¯·æ±‚å¤´ HTTP_CODE parse_headers(char *text); /// @brief è§£æè¯·æ±‚ä½“ HTTP_CODE parse_content(char *text); /// @brief è§£æè¯·æ±‚ä¸€è¡Œ LINE_STATUS parse_line(); // å¡«å……HTTPåº”ç­” bool process_write( HTTP_CODE ret ); public: // è¿™ä¸€ç»„å‡½æ•°è¢«process_writeè°ƒç”¨ä»¥å¡«å……HTTPåº”ç­” bool add_response( const char* format, ... ); bool add_content( const char* content ); bool add_content_type(); bool add_status_line( int status, const char* title ); bool add_headers( int content_length ); bool add_content_length( int content_length ); bool add_linger(); bool add_blank_line(); private: /* data */ int m_sockfd; // è¯¥ç”¨æˆ·ç«¯è¿æ¥çš„socket sockaddr_in m_address; // é€šä¿¡çš„socketåœ°å€ char m_read_buf[READ_BUFFER_SIZE];// è¯»ç¼“å†²åŒº int m_read_idx; // æ ‡è¯†è¯»ç¼“å†²åŒºä¸­å·²ç»è¯»å…¥çš„å®¢æˆ·ç«¯æ•°æ®çš„æœ€åä¸€ä¸ªå­—èŠ‚çš„ä¸‹ä¸€ä¸ªä½ç½® int m_checked_index; // å½“å‰æ­£åœ¨åˆ†æçš„å­—ç¬¦åœ¨ç¼“å†²åŒºçš„ä½ç½® int m_start_line; // å½“å‰æ­£åœ¨è§£æçš„è¡Œçš„èµ·å§‹ä½ç½® CHECK_STATE m_check_state; // ä¸»çŠ¶æ€æœºå½“å‰æ‰€å¤„çš„çŠ¶æ€ char* m_url; // è¯·æ±‚åœ°å€ char* m_version; // è¯·æ±‚åè®® METHOD m_method; //è¯·æ±‚æ–¹æ³• char* m_host; // ä¸»æœºå bool m_linger; //åˆ¤æ–­HTTPè¯·æ±‚æ˜¯å¦ä¿æŒè¿æ¥ int m_content_length; // HTTPè¯·æ±‚çš„æ¶ˆæ¯æ€»é•¿åº¦ char m_real_file[ FILENAME_LEN ]; // å®¢æˆ·è¯·æ±‚çš„ç›®æ ‡æ–‡ä»¶çš„å®Œæ•´è·¯å¾„ï¼Œå…¶å†…å®¹ç­‰äº doc_root + m_url, doc_rootæ˜¯ç½‘ç«™æ ¹ç›®å½• char m_write_buf[ WRITE_BUFFER_SIZE ]; // å†™ç¼“å†²åŒº int m_write_idx; // å†™ç¼“å†²åŒºä¸­å¾…å‘é€çš„å­—èŠ‚æ•° char* m_file_address; // å®¢æˆ·è¯·æ±‚çš„ç›®æ ‡æ–‡ä»¶è¢«mmapåˆ°å†…å­˜ä¸­çš„èµ·å§‹ä½ç½® struct stat m_file_stat; // ç›®æ ‡æ–‡ä»¶çš„çŠ¶æ€ã€‚é€šè¿‡å®ƒæˆ‘ä»¬å¯ä»¥åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨ã€æ˜¯å¦ä¸ºç›®å½•ã€æ˜¯å¦å¯è¯»ï¼Œå¹¶è·å–æ–‡ä»¶å¤§å°ç­‰ä¿¡æ¯ struct iovec m_iv[2]; // é‡‡ç”¨writevæ¥æ‰§è¡Œå†™æ“ä½œï¼Œæ‰€ä»¥å®šä¹‰ä¸‹é¢ä¸¤ä¸ªæˆå‘˜ï¼Œå…¶ä¸­m_iv_countè¡¨ç¤ºè¢«å†™å†…å­˜å—çš„æ•°é‡ã€‚ int m_iv_count; void init(); // è¿æ¥è§£æçŠ¶æ€åˆå§‹åŒ– void unmap(); // å¯¹å†…å­˜æ˜ å°„åŒºæ‰§è¡Œmunmapæ“ä½œ char* get_line()&#123; return m_read_buf + m_start_line;&#125; HTTP_CODE do_request(); &#125;; #endif &nbsp; å¯åŠ¨ main.cpp #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;arpa/inet.h> #include &lt;errno.h> #include &lt;fcntl.h> #include &lt;sys/epoll.h> #include &lt;unistd.h> #include &lt;signal.h> #include \"threadpool.h\" #include \"locker.h\" #include \"http_conn.h\" // æœåŠ¡å™¨æ€»ä½“å·¥ä½œé€»è¾‘è¯´æ˜ï¼š // 1. ä¸»çº¿ç¨‹å®Œæˆåˆå§‹åŒ–ï¼šå¿½ç•¥ SIGPIPEã€åˆ›å»ºçº¿ç¨‹æ± ã€åˆ†é… clients æ•°ç»„ã€åˆ›å»ºç›‘å¬ socket å¹¶åŠ å…¥ epollã€‚ // 2. ä½¿ç”¨ epoll_wait å¾ªç¯ç­‰å¾…äº‹ä»¶ï¼š // - å¦‚æœå‘ç”Ÿç›‘å¬ socket çš„å¯è¯»äº‹ä»¶ï¼Œaccept æ–°è¿æ¥ï¼Œè®¾ç½® socket éé˜»å¡ï¼Œæ³¨å†Œåˆ° epollï¼ˆä½¿ç”¨ EPOLLONESHOT + ETï¼‰å¹¶æŠŠè¿æ¥å¯¹è±¡åˆå§‹åŒ–åˆ° users[]ã€‚ // - å¯¹å®¢æˆ·ç«¯ fd çš„ EPOLLIN äº‹ä»¶ï¼šä¸»çº¿ç¨‹è°ƒç”¨ http_conn::read() éé˜»å¡è¯»å…¥å…¨éƒ¨æ•°æ®ï¼Œè‹¥è¯»å®Œåˆ™å°†è¯¥ http_conn å¯¹è±¡æ”¾å…¥çº¿ç¨‹æ± é˜Ÿåˆ—å¤„ç†ï¼ˆpool->appendï¼‰ã€‚ // - çº¿ç¨‹æ± ä¸­å·¥ä½œçº¿ç¨‹å–å‡ºä»»åŠ¡åè°ƒç”¨ http_conn::process()ï¼šè§£æè¯·æ±‚ï¼ˆçŠ¶æ€æœº parseï¼‰ï¼Œç”Ÿæˆå“åº”ï¼ˆprocess_writeï¼‰ï¼Œå¹¶é€šè¿‡ä¿®æ”¹ epoll äº‹ä»¶è§¦å‘å†™äº‹ä»¶ã€‚ // - å¯¹å®¢æˆ·ç«¯ fd çš„ EPOLLOUT äº‹ä»¶ï¼šä¸»çº¿ç¨‹è°ƒç”¨ http_conn::write()ï¼Œä½¿ç”¨ writev å‘é€å“åº”ï¼ˆåŒ…å«å¤´éƒ¨ç¼“å†²åŒºå’Œ mmap çš„æ–‡ä»¶ï¼‰ï¼Œå®Œæˆåæ ¹æ® Connection å†³å®šæ˜¯å¦ç»§ç»­ä¿æŒè¿æ¥æˆ–å…³é—­ã€‚ // 3. å…³é”®ç‚¹è¯´æ˜ï¼š // - ä½¿ç”¨ EPOLLONESHOT ä¿è¯åŒä¸€è¿æ¥ä¸ä¼šè¢«å¤šä¸ªçº¿ç¨‹å¹¶å‘å¤„ç†ï¼Œå¤„ç†å®Œæˆåéœ€æ‰‹åŠ¨é€šè¿‡ modifyfd æ¢å¤ EPOLLONESHOT ä»¥å†æ¬¡æ¥æ”¶äº‹ä»¶ã€‚ // - ä½¿ç”¨éé˜»å¡ I/O + è¾¹æ²¿è§¦å‘ï¼ˆEPOLLETï¼‰ï¼Œread() éœ€è¦å¾ªç¯è¯»å–ç›´åˆ° EAGAIN/EWOULDBLOCKã€‚ // - ä½¿ç”¨ mmap å°†æ–‡ä»¶æ˜ å°„åˆ°å†…å­˜å¹¶é€šè¿‡ writev å‘é€ï¼Œå‘é€å®Œæˆéœ€ munmapã€‚ // - çº¿ç¨‹æ± è´Ÿè´£è€—æ—¶çš„è¯·æ±‚è§£æä¸å“åº”å‡†å¤‡ï¼Œä¸»çº¿ç¨‹è´Ÿè´£ I/O äº‹ä»¶åˆ†å‘ä¸çŸ­å°çš„éé˜»å¡è¯»å†™è§¦å‘è°ƒåº¦ã€‚ #define MAX_FD 65535 //æœ€å¤§æ–‡ä»¶æè¿°ç¬¦ä¸ªæ•° #define MAX_EVENT_NUM 10000 //ä¸€æ¬¡æœ€å¤§ç›‘å¬äº‹ä»¶ä¸ªæ•° // æ·»åŠ ä¿¡å·æ•æ‰ void addsig(int sig, void(handler)(int))&#123; struct sigaction sa; memset(&amp;sa, '\\0', sizeof(sa)); sa.sa_handler = handler; sigfillset(&amp;sa.sa_mask); sigaction(sig, &amp;sa, NULL); &#125; // æ·»åŠ æ–‡ä»¶æè¿°ç¬¦åˆ°epollä¸­ extern void addfd(int epollfd, int fd, bool one_shot); // ä»epollä¸­åˆ é™¤æ–‡ä»¶æè¿°ç¬¦ extern void removefd(int epollfd, int fd); // ä¿®æ”¹æ–‡ä»¶æè¿°ç¬¦ extern void modifyfd(int epollfd, int fd ,int ev); int main(int argc, char* argv[])&#123; if (argc &lt;= 1)&#123; printf(\"æŒ‰ç…§å¦‚ä¸‹æ ¼å¼è¿è¡Œï¼š %s port num needed\\n\", basename(argv[0])); exit(-1); &#125; int port = atoi(argv[1]); // å¯¹SIGPIEå¤„ç† addsig(SIGPIPE, SIG_IGN); // åˆå§‹åŒ–çº¿ç¨‹æ±  threadpool&lt;http_conn>* pool = NULL; try &#123; pool = new threadpool&lt;http_conn>; &#125; catch(const std::exception &amp; e) &#123; std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; exit(-1); &#125; // åˆ›å»ºæ•°ç»„ç”¨äºä¿å­˜æ‰€æœ‰å®¢æˆ·ç«¯ä¿¡æ¯ http_conn *users = new http_conn[MAX_FD]; // åˆ›å»ºå¥—æ¥å­— // IPv4 TCP int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1)&#123; perror(\"socket create\"); exit(-1); &#125; // è®¾ç½®ç«¯å£å¤ç”¨ int reuse = 1; setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse)); struct sockaddr_in address; address.sin_port = htons(port); address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; // bind int ret = bind(lfd, (struct sockaddr*) &amp;address, sizeof(address)); if (ret == -1)&#123; perror(\"bind\"); exit(-1); &#125; // ç›‘å¬ ret = listen(lfd, 5); if (ret == -1)&#123; perror(\"listen\"); exit(-1); &#125; // åˆ›å»ºepollå¯¹è±¡ï¼Œäº‹ä»¶æ•°ç»„ï¼Œæ·»åŠ ç›‘å¬äº‹ä»¶ epoll_event events[MAX_EVENT_NUM]; int epollfd = epoll_create(5); addfd(epollfd, lfd, false); http_conn::m_epollfd = epollfd; // ä¸»çº¿ç¨‹æ£€æµ‹ while(true)&#123; int num = epoll_wait(epollfd, events, MAX_EVENT_NUM, -1); if( (num &lt; 0) &amp;&amp; (errno != EINTR))&#123; printf(\"epoll failed\\n\"); break; &#125; // å¾ªç¯éå†äº‹ä»¶æ•°ç»„ for (int i = 0; i &lt; num; i++)&#123; int sockfd = events[i].data.fd; // æœ‰å®¢æˆ·ç«¯è¿æ¥æƒ…å†µ if (sockfd == lfd)&#123; struct sockaddr_in clientaddr; socklen_t len = sizeof(clientaddr); int connfd = accept(lfd, (struct sockaddr*)&amp;clientaddr, &amp;len); if (http_conn::m_user_count >= MAX_FD)&#123; // ç›®å‰è¿æ¥æ•°å·²æ»¡ // ç»™å®¢æˆ·ç«¯å†™ä¸€ä¸ªä¿¡æ¯ï¼šæœåŠ¡å™¨æ­£å¿™ close(connfd); continue; &#125; // å°†connfdå®¢æˆ·æ•°æ®åˆå§‹åŒ–åæ”¾å…¥ç”¨æˆ·ä¿¡æ¯æ•°ç»„ users[connfd].init(connfd, clientaddr); &#125; // æœ‰å®¢æˆ·ç«¯é”™è¯¯äº‹ä»¶æƒ…å†µ else if (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP| EPOLLERR)) &#123; users[sockfd].closeconn(); &#125; // æœ‰å®¢æˆ·ç«¯è¯»äº‹ä»¶æƒ…å†µ else if (events[i].events &amp; EPOLLIN)&#123; if (users[sockfd].read())&#123; // ä¸€æ¬¡æ€§æŠŠæ‰€æœ‰æ•°æ®è¯»å®Œ pool->append(users + sockfd); &#125;else &#123; users[sockfd].closeconn(); &#125; &#125; else if (events[i].events &amp; EPOLLOUT)&#123; if (users[sockfd].write())&#123; // ä¸€æ¬¡æ€§æŠŠæ‰€æœ‰æ•°æ®å†™å®Œ &#125;else &#123; users[sockfd].closeconn(); &#125; &#125; &#125; &#125; close(epollfd); close(lfd); delete[] users; delete pool; return 0; &#125; å‹æµ‹å‹æµ‹å·¥å…·ï¼šwebbench 1.5 æŒ‡ä»¤ï¼š./webbench -c 5000 -t 10 http://localh ost:8080/index.html ç»“æœï¼š Webbench - Simple Web Benchmark 1.5 Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software. Benchmarking: GET http://localhost:8080/index.html 5000 clients, running 10 sec. Speed=2732598 pages/min, 7240987 bytes/sec. Requests: 455431 susceed, 2 failed. QPS 45,543ï¼Œç«Ÿç„¶è¿˜ä¸é”™å‘¢ ä¸è¿‡å¹¶å‘æ•°é‡å†é«˜ç‚¹å°±ä¸è¡Œäº† ç»å…¸æ°¸æµä¼ ","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://miustannis.github.io/tags/C/"}]},{"title":"å¼‚æ­¥æ—¥å¿—ç³»ç»Ÿ","slug":"260130","date":"2026-01-30T03:38:44.000Z","updated":"2026-02-20T07:55:36.467Z","comments":true,"path":"2026/01/30/260130/","link":"","permalink":"https://miustannis.github.io/2026/01/30/260130/","excerpt":"","text":"è¿™æ˜¯ä¸€ä¸ªè½»é‡çº§å¼‚æ­¥æ—¥å¿—å™¨ï¼ˆasync loggerï¼‰ã€‚ç›®æ ‡æ˜¯ç”¨ç°ä»£ C++ï¼ˆçº¿ç¨‹ã€äº’æ–¥ã€æ¡ä»¶å˜é‡ï¼‰å®ç°ä¸€ä¸ªçº¿ç¨‹å®‰å…¨ã€ä½é˜»å¡çš„æ—¥å¿—å†™å…¥æ–¹æ¡ˆï¼šç”Ÿäº§è€…å°†æ ¼å¼åŒ–åçš„æ—¥å¿—æ¶ˆæ¯æ¨å…¥é˜Ÿåˆ—ï¼Œåå°æ¶ˆè´¹è€…çº¿ç¨‹å¼‚æ­¥å†™å…¥æ–‡ä»¶å¹¶å¯é€‰åœ°è¾“å‡ºåˆ°ç»ˆç«¯ã€‚æ•´ä½“å®ç°åŒ…å«ä¸€ä¸ªç®€å•çš„å ä½ç¬¦æ ¼å¼åŒ–ï¼ˆæš‚ç”¨{}ï¼Œå¯è‡ªè¡Œä¿®æ”¹ï¼‰ã€ç±»å‹åˆ°å­—ç¬¦ä¸²çš„é€šç”¨è½¬æ¢å’Œä¼˜é›…çš„åå°çº¿ç¨‹å…³é—­æœºåˆ¶ã€‚ hpp #ifndef MY_LOG #define MY_LOG #include &lt;iostream> #include &lt;queue> #include &lt;mutex> #include &lt;string> #include &lt;condition_variable> #include &lt;thread> #include &lt;fstream> #include &lt;atomic> #include &lt;sstream> #include &lt;vector> #include &lt;stdexcept> /** * @brief å°†å•ä¸ªå‚æ•°è½¬æ¢ä¸ºå­—ç¬¦ä¸²çš„è¾…åŠ©å‡½æ•°ã€‚ * * ä½¿ç”¨ std::ostringstream å°†ä»»æ„æ”¯æŒ operator&lt;&lt; çš„ç±»å‹è½¬æ¢ä¸º std::stringã€‚ * * @tparam T å‚æ•°ç±»å‹ï¼ˆå¯ä»¥æ˜¯å³å€¼å¼•ç”¨æˆ–å·¦å€¼å¼•ç”¨ç±»å‹ï¼‰ã€‚ * @param arg è¦è½¬æ¢çš„å‚æ•°ï¼Œå¿…é¡»å¯é€šè¿‡ operator&lt;&lt; è¾“å‡ºåˆ°æµã€‚ * @return std::string å‚æ•°çš„å­—ç¬¦ä¸²è¡¨ç¤ºã€‚ */ template &lt;typename T> std::string my_to_string(T &amp;&amp;arg) &#123; std::ostringstream oss; // å¦‚æœTä¸ºè‡ªå®šä¹‰ç±»å‹ï¼Œéœ€è¦å®ç°&lt;&lt;çš„é‡è½½ oss &lt;&lt; std::forward&lt;T>(arg); return oss.str(); &#125; /** * @brief çº¿ç¨‹å®‰å…¨çš„æ—¥å¿—æ¶ˆæ¯é˜Ÿåˆ—ã€‚ * * è¯¥ç±»æä¾›ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼çš„ç®€æ˜“å®ç°ï¼šå¤šä¸ªç”Ÿäº§è€…å¯ä»¥è°ƒç”¨ push() * å°†æ—¥å¿—æ¶ˆæ¯æ”¾å…¥é˜Ÿåˆ—ï¼Œå•ä¸ªæˆ–å¤šä¸ªæ¶ˆè´¹è€…é€šè¿‡ pop() è·å–æ¶ˆæ¯ã€‚é€šè¿‡ shutdown() * å¯ä»¥é€šçŸ¥æ‰€æœ‰ç­‰å¾…çš„çº¿ç¨‹é€€å‡ºï¼Œç”¨äºä¼˜é›…å…³é—­åå°çº¿ç¨‹ã€‚ */ class LogQueue &#123; private: std::queue&lt;std::string> _queue; std::condition_variable _cv; std::mutex _mtx; bool _isshut = false; public: /** * @brief å°†ä¸€æ¡æ—¥å¿—æ¶ˆæ¯åŠ å…¥é˜Ÿåˆ—ã€‚ * * çº¿ç¨‹å®‰å…¨ï¼Œå†…éƒ¨ä¼šåœ¨é˜Ÿåˆ—ä»ç©ºå˜ä¸ºéç©ºæ—¶é€šçŸ¥ä¸€ä¸ªç­‰å¾…çº¿ç¨‹ã€‚ * * @param msg è¦åŠ å…¥çš„æ—¥å¿—æ¶ˆæ¯ï¼ˆæŒ‰å€¼æˆ–æŒ‰å¼•ç”¨ä¼ å…¥ä¼šè¢«æ‹·è´åˆ°é˜Ÿåˆ—ä¸­ï¼‰ã€‚ */ void push(const std::string &amp;msg) &#123; std::lock_guard&lt;std::mutex> lock(_mtx); _queue.push(msg); if (_queue.size() == 1) &#123; _cv.notify_one(); &#125; &#125; /** * @brief ä»é˜Ÿåˆ—ä¸­å¼¹å‡ºä¸€æ¡æ¶ˆæ¯ï¼ˆé˜»å¡ç›´åˆ°æœ‰æ¶ˆæ¯æˆ–é˜Ÿåˆ—è¢«å…³é—­ï¼‰ã€‚ * * @param msg è¾“å‡ºå‚æ•°ï¼šæˆåŠŸå¼¹å‡ºæ—¶å­˜æ”¾æ¶ˆæ¯ã€‚ * @return true æˆåŠŸå¼¹å‡ºå¹¶è¿”å›æ¶ˆæ¯ã€‚ * @return false é˜Ÿåˆ—å·²å…³é—­ä¸”ä¸ºç©ºï¼Œç”¨äºé€šçŸ¥æ¶ˆè´¹è€…é€€å‡ºå¾ªç¯ã€‚ */ bool pop(std::string &amp;msg) &#123; std::unique_lock&lt;std::mutex> lock(_mtx); // é˜²æ­¢è™šå‡å”¤é†’ï¼Œéœ€è¦åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºå†ç»§ç»­ // çº¿ç¨‹æŒ‚èµ·ä¼šè§£é” _cv.wait(lock, [this]() -> bool &#123; return !_queue.empty() || _isshut; &#125;); // æ¶ˆè´¹é€»è¾‘ if (_queue.empty() &amp;&amp; _isshut) return false; msg = _queue.front(); _queue.pop(); return true; &#125; /** * @brief å…³é—­é˜Ÿåˆ—å¹¶é€šçŸ¥æ‰€æœ‰é˜»å¡çš„ç­‰å¾…è€…ã€‚ * * è¯¥æ“ä½œä¼šå°†å†…éƒ¨çŠ¶æ€æ ‡è®°ä¸ºå…³é—­ï¼Œå¹¶å”¤é†’æ‰€æœ‰åœ¨ pop() ä¸Šç­‰å¾…çš„çº¿ç¨‹ã€‚ */ void shutdown() &#123; std::lock_guard&lt;std::mutex> lock(_mtx); _isshut = true; _cv.notify_all(); &#125; public: /** * @brief æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–é˜Ÿåˆ—ã€‚ */ LogQueue() = default; /** * @brief ææ„å‡½æ•°ã€‚ */ ~LogQueue() = default; &#125;; /** * @brief å¼‚æ­¥æ—¥å¿—å™¨ç±»ã€‚ * * Logger åœ¨æ„é€ æ—¶æ‰“å¼€æŒ‡å®šçš„æ—¥å¿—æ–‡ä»¶å¹¶å¯åŠ¨ä¸€ä¸ªåå°çº¿ç¨‹ï¼Œä»å†…éƒ¨çš„ LogQueue ä¸­ * å¼‚æ­¥æ¶ˆè´¹æ—¥å¿—æ¶ˆæ¯å¹¶å†™å…¥æ–‡ä»¶ï¼›å¯é€‰åœ°åŒæ—¶è¾“å‡ºåˆ°æ§åˆ¶å°ã€‚ææ„æ—¶ä¼šä¼˜é›…å…³é—­åå°çº¿ç¨‹å¹¶å…³é—­æ–‡ä»¶ã€‚ */ class Logger &#123; public: /** * @brief æ„é€ å¹¶å¯åŠ¨ Loggerã€‚ * * æ‰“å¼€æ—¥å¿—æ–‡ä»¶å¹¶å¯åŠ¨ä¸€ä¸ªåå°çº¿ç¨‹ç”¨äºå¼‚æ­¥å†™å…¥ã€‚ * * @param filename æ—¥å¿—æ–‡ä»¶è·¯å¾„ï¼ˆå¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ä¼šåˆ›å»ºï¼‰ã€‚ * @param coutopen å¦‚æœä¸º trueï¼Œåˆ™åœ¨å†™å…¥æ–‡ä»¶çš„åŒæ—¶å°†æ—¥å¿—è¾“å‡ºåˆ° std::coutï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰ã€‚ * @throws std::runtime_error æ— æ³•æ‰“å¼€æ—¥å¿—æ–‡ä»¶æ—¶æŠ›å‡ºå¼‚å¸¸ã€‚ */ Logger(const std::string &amp;filename, bool coutopen) : _logfile(filename, std::ios::out | std::ios::app), _exitflag(false), _console(coutopen) &#123; if (!_logfile.is_open()) &#123; throw std::runtime_error(\"failed to open log file.\"); &#125; _workerthread = std::thread([this]() &#123; std::string msg; while (this->_logqueue.pop(msg))&#123; if (this->_logfile.is_open())&#123; _logfile &lt;&lt; msg &lt;&lt; std::endl; &#125; if (_console)&#123; std::lock_guard&lt;std::mutex> lock(_cout_mtx); std::cout &lt;&lt; msg &lt;&lt; std::endl; &#125; &#125; &#125;); &#125; /** * @brief æ„é€ å‡½æ•°ï¼ˆä¸è¾“å‡ºåˆ°æ§åˆ¶å°ï¼‰ã€‚ * * ç­‰åŒäº Logger(filename, false)ã€‚ * * @param filename æ—¥å¿—æ–‡ä»¶è·¯å¾„ã€‚ * @throws std::runtime_error æ— æ³•æ‰“å¼€æ—¥å¿—æ–‡ä»¶æ—¶æŠ›å‡ºå¼‚å¸¸ã€‚ */ Logger(const std::string &amp;filename) : _logfile(filename, std::ios::out | std::ios::app), _exitflag(false), _console(false) &#123; if (!_logfile.is_open()) &#123; throw std::runtime_error(\"failed to open log file.\"); &#125; _workerthread = std::thread([this]() &#123; std::string msg; while (this->_logqueue.pop(msg))&#123; if (this->_logfile.is_open())&#123; _logfile &lt;&lt; msg &lt;&lt; std::endl; &#125; if (_console)&#123; std::lock_guard&lt;std::mutex> lock(_cout_mtx); std::cout &lt;&lt; msg &lt;&lt; std::endl; &#125; &#125; &#125;); &#125; /** * @brief ææ„å‡½æ•°ï¼Œåœæ­¢åå°çº¿ç¨‹å¹¶å…³é—­æ–‡ä»¶ã€‚ * * å°†æ ‡å¿—è®¾ç½®ä¸ºé€€å‡ºçŠ¶æ€ã€è°ƒç”¨ LogQueue::shutdown() é€šçŸ¥åå°çº¿ç¨‹ï¼Œå¹¶ join çº¿ç¨‹ã€‚ */ ~Logger() &#123; _exitflag = true; _logqueue.shutdown(); if (_workerthread.joinable()) &#123; _workerthread.join(); &#125; if (_logfile.is_open()) &#123; _logfile.close(); &#125; &#125;; public: /** * @brief å°†æ ¼å¼åŒ–æ¶ˆæ¯å¼‚æ­¥å†™å…¥æ—¥å¿—ã€‚ * * ä½¿ç”¨ formatMessage() å°† format ä¸­çš„ &#123;&#125; å ä½ç¬¦æ›¿æ¢ä¸ºåç»­å‚æ•°çš„å­—ç¬¦ä¸²è¡¨ç¤ºï¼Œ * ç„¶åå°†ç”Ÿæˆçš„æ¶ˆæ¯æ¨å…¥é˜Ÿåˆ—ï¼Œç”±åå°çº¿ç¨‹å¼‚æ­¥å†™å…¥æ–‡ä»¶ï¼ˆä»¥åŠå¯é€‰çš„æ§åˆ¶å°ï¼‰ã€‚ * * @tparam Args å‚æ•°ç±»å‹åˆ—è¡¨ã€‚ * @param format å¸¦æœ‰ &#123;&#125; å ä½ç¬¦çš„æ ¼å¼å­—ç¬¦ä¸²ã€‚ * @param args ä¸å ä½ç¬¦å¯¹åº”çš„å‚æ•°åˆ—è¡¨ã€‚ */ template &lt;typename... Args> void log(const std::string &amp;format, Args &amp;&amp;...args) &#123; _logqueue.push(formatMessage(format, std::forward&lt;Args>(args)...)); &#125; private: /** * @brief å°†æ ¼å¼å­—ç¬¦ä¸²ä¸­çš„ &#123;&#125; ä¾æ¬¡æ›¿æ¢ä¸ºä¼ å…¥å‚æ•°çš„å­—ç¬¦ä¸²è¡¨ç¤ºã€‚ * * ç®€å•å®ç°ï¼Œä¸æ”¯æŒç´¢å¼•ã€å®½åº¦æˆ–å…¶ä»–æ ¼å¼åŒ–é€‰é¡¹ï¼›å½“å‚æ•°å°‘äºå ä½ç¬¦æ—¶ä¿ç•™ \"&#123;&#125;\" åŸæ ·ï¼Œ * å½“å‚æ•°å¤šäºå ä½ç¬¦æ—¶å¤šä½™å‚æ•°è¢«å¿½ç•¥ã€‚ * * @tparam Args å‚æ•°ç±»å‹åˆ—è¡¨ã€‚ * @param format åŒ…å« &#123;&#125; å ä½ç¬¦çš„æ ¼å¼å­—ç¬¦ä¸²ã€‚ * @param args å‚æ•°åˆ—è¡¨ã€‚ * @return std::string æ›¿æ¢åçš„æœ€ç»ˆå­—ç¬¦ä¸²ã€‚ */ template &lt;typename... Args> std::string formatMessage(const std::string &amp;format, Args &amp;&amp;...args) &#123; std::vector&lt;std::string> arg_string = &#123;my_to_string(std::forward&lt;Args>(args))...&#125;; std::ostringstream oss; size_t arg_index = 0; // éå†æ ¼å¼å­—ç¬¦ä¸²ï¼Œæ›¿æ¢&#123;&#125;ä¸ºå‚æ•°å­—ç¬¦ä¸² for (size_t i = 0; i &lt; format.size(); ++i) &#123; if (format[i] == '&#123;' &amp;&amp; i + 1 &lt; format.size() &amp;&amp; format[i + 1] == '&#125;') &#123; // å¦‚æœè¿˜æœ‰å‚æ•°ï¼Œæ›¿æ¢ä¸ºå‚æ•°å­—ç¬¦ä¸²ï¼Œå¦åˆ™ä¿ç•™åŸæ · if (arg_index &lt; arg_string.size()) &#123; oss &lt;&lt; arg_string[arg_index]; ++arg_index; &#125; else &#123; oss &lt;&lt; \"&#123;&#125;\"; &#125; ++i; // è·³è¿‡ä¸‹ä¸€ä¸ªå­—ç¬¦ &#125; else &#123; oss &lt;&lt; format[i]; &#125; &#125; return oss.str(); &#125; private: LogQueue _logqueue; std::thread _workerthread; std::ofstream _logfile; std::atomic&lt;bool> _exitflag; std::mutex _cout_mtx; // ä¿æŠ¤ std::cout çš„äº’æ–¥é” bool _console = false; // æ˜¯å¦åŒæ—¶è¾“å‡ºåˆ°æ§åˆ¶å° &#125;; #endif &nbsp; ä½¿ç”¨æ–¹æ³• è¿™æ˜¯ä¸€ä¸ªhead-onlyçš„åº“ï¼Œåªéœ€è¦ç®€å•åœ°åŒ…å«å¤´æ–‡ä»¶å³å¯ä»¥è°ƒç”¨ï¼Œä¸‹é¢æ˜¯ä½¿ç”¨ç¤ºä¾‹ main.cpp #include \"log.hpp\" #include &lt;chrono> #include &lt;thread> int main() &#123; try &#123; Logger logger(\"example.log\", true); logger.log(\"hello &#123;&#125;, &#123;&#125;\", \"world\", 2026); logger.log(\"another line: &#123;&#125; - &#123;&#125;\", \"test\", 3.14); logger.log(\"this is a log message without parameters\"); logger.log(\"logging with more parameters: &#123;&#125;, &#123;&#125;, &#123;&#125;\", \"param1\", 42, 3.14); logger.log(\"logging with fewer parameters: &#123;&#125;, &#123;&#125;\", \"only one\"); &#125; catch (const std::exception &amp;e) &#123; std::cerr &lt;&lt; \"logger init failed: \" &lt;&lt; e.what() &lt;&lt; std::endl; return 1; &#125; return 0; &#125; &nbsp; ä½¿ç”¨æ•ˆæœï¼ˆåŒæ—¶å¼€å¯ç»ˆç«¯è¾“å‡ºä¸æ–‡ä»¶è¾“å‡ºæ—¶ï¼‰æ–‡ä»¶è¾“å‡ºï¼š ç»ˆç«¯è¾“å‡ºï¼š åç»­å¯ä»¥è€ƒè™‘å¢åŠ ä¸åŒè¾“å‡ºç­‰çº§é™åˆ¶ï¼Œæ¯”å¦‚ã€Infoã€‘ ã€Warnã€‘ ã€Errorã€‘è¿™äº›","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://miustannis.github.io/tags/CS/"},{"name":"C++","slug":"C","permalink":"https://miustannis.github.io/tags/C/"}]},{"title":"C++å°ç¢—èœ","slug":"260125","date":"2026-01-25T03:38:44.000Z","updated":"2026-02-18T11:25:36.795Z","comments":true,"path":"2026/01/25/260125/","link":"","permalink":"https://miustannis.github.io/2026/01/25/260125/","excerpt":"","text":"ä¸€äº›C++ä¸­ç»å¸¸ä¼šæ¥è§¦çš„æ¦‚å¿µï¼ŒåŒ…æ‹¬ä¸­é—´ä»¶ï¼Œæ•°æ®ç»“æ„å°è£…ç­‰æ¨¡å— äº†è§£åŸç†ï¼Œå®ç°åŸºæœ¬åŠŸèƒ½ï¼Œå®é™…è¿ç”¨çš„æ—¶å€™è¿˜éœ€è¦æ ¹æ®å…·ä½“éœ€æ±‚è¿›è¡Œæ‰©å±•å’Œä¼˜åŒ– ä¸€èˆ¬è‚¯å®šç›´æ¥ç”¨STLå°è£…å¥½çš„ å†…å­˜æ±  Memory Pool å…±äº«æŒ‡é’ˆ Shared Pointer å‡½æ•°å°è£… Function Encapsulation åŒå‘é“¾è¡¨å®¹å™¨ List åŒç«¯é˜Ÿåˆ—å®¹å™¨ Deque BSTå’ŒAVLå®ç°map 1. åŸºäºäºŒå‰æœç´¢æ ‘ (BST) çš„å®ç° 2. åŸºäº AVL æ ‘çš„å®ç° æ— åºæ˜ å°„è¡¨ unordered_map å•ä¾‹æ¨¡å¼ Singleton å†…å­˜æ±  Memory Poolå†…å­˜æ± æ˜¯ä¸€ç§é¢„å…ˆåˆ†é…ä¸€å¤§å—å†…å­˜ï¼Œç„¶åæŒ‰éœ€åˆ†é…å°å—å†…å­˜çš„æŠ€æœ¯ å†…å­˜æ± å¯ä»¥å‡å°‘é¢‘ç¹çš„å†…å­˜åˆ†é…å’Œé‡Šæ”¾æ“ä½œä»è€Œæé«˜æ€§èƒ½ ç”¨ä¸€ä¸ªæ ˆå®ç°ï¼š classDiagram class MemoryPool { char* _pool size_t _objectsize size_t _totalsize stack~void*~ _freelist void* allocate() void deallocate(void* ptr) } MemoryPool --* \"1\" char : ç®¡ç† MemoryPool --* \"1\" stack : åŒ…å« class FreeListStack { void*ç±»å‹ push(void* ptr) pop() void* top() void* empty() bool } MemoryPool --> FreeListStack : ä½¿ç”¨ hpp class MemoryPool&#123; public: MemoryPool(size_t objectsize, size_t totalsize); ~MemoryPool(); // ç”¨æˆ·å±‚api void* allocate(); void deallocate(void* ptr); private: size_t _objectsize; // å•ä¸ªå…ƒç´ å¤§å° size_t _totalsize; // é¢„ç•™çš„ä¸ªæ•° char* _pool; std::stack&lt;void*> _freelist; &#125;; cpp #include \"MemoryPool.h\" MemoryPool::MemoryPool(size_t objectsize, size_t totalsize) : _objectsize(objectsize), _totalsize(totalsize) &#123; _pool = (char*)malloc(totalsize * objectsize); if (_pool == nullptr)&#123; throw std::bad_alloc(); &#125; // åˆå§‹åŒ–freelist for (size_t i = 0; i &lt; totalsize; ++i)&#123; _freelist.push(_pool+ i * objectsize); &#125; &#125; MemoryPool::~MemoryPool() &#123; free(_pool); &#125; void * MemoryPool::allocate() &#123; if (_freelist.empty())&#123; throw std::bad_alloc(); // return nullptr; &#125; void* p = _freelist.top(); _freelist.pop(); return p; &#125; void MemoryPool::deallocate(void * ptr) &#123; _freelist.push(ptr); return; &#125; flowchart TD A[å¼€å§‹] --> B{æ ¹æ®ç±»å‹åˆ›å»ºå†…å­˜æ± } B -->|åˆ†é…| C[è°ƒç”¨ allocate] B -->|é‡Šæ”¾| D[è°ƒç”¨ deallocate] C --> E{_freelistä¸ºç©º?} E -->|æ˜¯| F[æŠ›å‡º bad_alloc] E -->|å¦| G[ä»æ ˆé¡¶å–æŒ‡é’ˆ] G --> H[è¿”å›æŒ‡é’ˆ] D --> I[æŒ‡é’ˆå‹å…¥æ ˆ] I --> J[è¿”å›] F --> K[ç»“æŸ] H --> K J --> K ä½¿ç”¨æ¡ˆä¾‹ #include \"../inc/test.h\" #include \"../inc/MemoryPool.h\" #include &lt;cstring> class Student &#123; public: char *_name; int _age; public: Student(const char *name, int age) : _age(age) &#123; _name = new char[strlen(name) + 1]; strcpy(_name, name); &#125; ~Student() &#123; delete[] _name; &#125; &#125;; int main() &#123; try &#123; MemoryPool pool(sizeof(Student), 3); void *mem1 = pool.allocate(); void *mem2 = pool.allocate(); void *mem3 = pool.allocate(); // å®šä½newè¡¨è¾¾å¼ï¼Œä¸åˆ†é…æ–°çš„å†…å­˜ï¼Œç›´æ¥åœ¨æä¾›çš„å†…å­˜åœ°å€ä¸Šæ„é€ å¯¹è±¡ Student *stu1 = new (mem1) Student(\"Tom\", 20); Student *stu2 = new (mem2) Student(\"Sam\", 22); Student *stu3 = new (mem3) Student(\"Tim\", 24); std::cout &lt;&lt; \"stu1:\" &lt;&lt; stu1->_name &lt;&lt; \" \" &lt;&lt; stu1->_age &lt;&lt; std::endl; std::cout &lt;&lt; \"stu2:\" &lt;&lt; stu2->_name &lt;&lt; \" \" &lt;&lt; stu2->_age &lt;&lt; std::endl; std::cout &lt;&lt; \"stu2:\" &lt;&lt; stu3->_name &lt;&lt; \" \" &lt;&lt; stu3->_age &lt;&lt; std::endl; // æ˜¾å¼è°ƒç”¨ææ„ stu1->~Student(); stu2->~Student(); stu3->~Student(); // æ± å­å›æ”¶ pool.deallocate(mem1); pool.deallocate(mem2); pool.deallocate(mem3); &#125; catch (const std::bad_alloc &amp;e) &#123; std::cerr &lt;&lt; \"Memory allocation error: \" &lt;&lt; e.what() &lt;&lt; std::endl; return 1; &#125; return 0; &#125; å¦‚æœæ˜¯å¤šçº¿ç¨‹çš„æƒ…å†µï¼Œéœ€è¦åœ¨ç”¨æˆ·åº”ç”¨å±‚è¿›è¡Œçº¿ç¨‹å®‰å…¨çš„ä¸€ç³»åˆ—æ“ä½œ å…±äº«æŒ‡é’ˆ Shared Pointershared_ptrï¼ˆå…±äº«æ™ºèƒ½æŒ‡é’ˆï¼‰æ˜¯C++æ ‡å‡†åº“æä¾›çš„ä¸€ç§æ™ºèƒ½æŒ‡é’ˆï¼Œç”¨äºè‡ªåŠ¨ç®¡ç†åŠ¨æ€åˆ†é…çš„å†…å­˜èµ„æºã€‚å®ƒé‡‡ç”¨å¼•ç”¨è®¡æ•°æœºåˆ¶ï¼Œè®°å½•æœ‰å¤šå°‘ä¸ªshared_ptræŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡ã€‚å½“æœ€åä¸€ä¸ªshared_ptrè¢«é”€æ¯æˆ–é‡ç½®æ—¶ï¼Œå…¶æ‰€ç®¡ç†çš„å¯¹è±¡ä¼šè¢«è‡ªåŠ¨åˆ é™¤ï¼Œä»è€Œæœ‰æ•ˆé˜²æ­¢å†…å­˜æ³„æ¼ã€‚shared_ptræ”¯æŒæ‹·è´å’Œèµ‹å€¼æ“ä½œï¼Œå…è®¸å¤šä¸ªæŒ‡é’ˆå…±äº«åŒä¸€èµ„æºã€‚ä½¿ç”¨shared_ptrèƒ½ç®€åŒ–èµ„æºç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œæ˜¯ç°ä»£C++ä¸­é¿å…åŸå§‹æŒ‡é’ˆé£é™©çš„é‡è¦å·¥å…·ã€‚ è¿™é‡Œç”¨ä¸€ä¸ªstructå—æ¥æ¨¡æ‹Ÿå¼•ç”¨è®¡æ•°ï¼Œå®é™…ä¸Šä¹Ÿå¯ä»¥ç›´æ¥ç”¨ä¸€ä¸ªint*æ¥æ›¿ä»£ã€‚ classDiagram class MySharedPtr~T~ { T* ptr controlblock* ctrl_blk void Release() int use_count() const T* get() const void reset(T* p) } class controlblock { int count_ref controlblock() } MySharedPtr --o controlblock : æ‹¥æœ‰ MySharedPtr --> T : ç®¡ç† æ¨¡æ¿ç±»hpp #ifndef SHARED_PTR_H #define SHARED_PTR_H #include &lt;atomic> struct controlblock &#123; std::atomic&lt;int> count_ref; controlblock() : count_ref(1) &#123;&#125; &#125;; template &lt;typename T> class MySharedPtr &#123; private: T *ptr; controlblock *ctrl_blk; /** * @brief å†…éƒ¨ç®¡ç†è®¡æ•°ï¼Œå½“è®¡æ•°é™åˆ°0æ—¶é‡Šæ”¾å†…å­˜ */ void Release() &#123; if (ctrl_blk) &#123; --ctrl_blk->count_ref; if (ctrl_blk->count_ref == 0) &#123; delete ptr; delete ctrl_blk; ptr = nullptr; ctrl_blk = nullptr; &#125; &#125; &#125; public: /** * @brief å¸¦å‚æ•°æ„é€  * @param p æŒ‡å‘éœ€è¦ç®¡ç†çš„å¯¹è±¡çš„æŒ‡é’ˆ * @return MySharedPtr&lt;T> * @note ç”¨explicité˜²æ­¢éšå¼è½¬æ¢ */ explicit MySharedPtr(T *p = nullptr) &#123; &#123; if (p != nullptr) &#123; ptr = p; ctrl_blk = new controlblock(); &#125; else &#123; ptr = nullptr; ctrl_blk = nullptr; &#125; &#125; &#125; /** * @brief é»˜è®¤æ„é€  * @param p æŒ‡å‘éœ€è¦ç®¡ç†çš„å¯¹è±¡çš„æŒ‡é’ˆ * @return MySharedPtr&lt;T> */ MySharedPtr() : ptr(nullptr), ctrl_blk(nullptr) &#123;&#125; /** * @brief ææ„ */ ~MySharedPtr() &#123; if (ptr) &#123; Release(); &#125; &#125; /** * @brief æ‹·è´æ„é€  * @param s æ‹·è´å¯¹è±¡ * @return MySharedPtr&lt;T> */ MySharedPtr(const MySharedPtr &amp;s) : ptr(s.ptr), ctrl_blk(s.ctrl_blk) &#123; if (ctrl_blk) ctrl_blk->count_ref++; &#125; /** * @brief æ‹·è´èµ‹å€¼ * @param s æ‹·è´å¯¹è±¡ * @return MySharedPtr&lt;T> */ MySharedPtr &amp;operator=(const MySharedPtr &amp;s) &#123; if (&amp;s == this) return *this; // è‡ªå·±å¼•ç”¨è®¡æ•°å‡å°‘ Release(); ptr = s.ptr; ctrl_blk = s.ctrl_blk; // æ‹·è´çš„å¼•ç”¨è®¡æ•°å¢åŠ  if (ctrl_blk) ctrl_blk->count_ref++; &#125; /** * @brief ç§»åŠ¨æ„é€  * @param s ç§»åŠ¨å¯¹è±¡ * @return MySharedPtr&lt;T> */ MySharedPtr(MySharedPtr &amp;&amp;s) : ptr(s.ptr), ctrl_blk(s.ctrl_blk) &#123; s.ptr = nullptr; s.ctrl_blk = nullptr; &#125; /** * @brief ç§»åŠ¨èµ‹å€¼ * @param s ç§»åŠ¨å¯¹è±¡ * @return MySharedPtr&lt;T> */ MySharedPtr &amp;operator=(MySharedPtr &amp;&amp;s) &#123; if (&amp;s == this) return *this; ptr = s.ptr; ctrl_blk = s.ctrl_blk; s.ptr = nullptr; s.ctrl_blk = nullptr; &#125; public: /** * @brief ->é‡è½½ï¼ŒæŠŠç±»å½“æŒ‡é’ˆç”¨ï¼Œæ–¹ä¾¿é“¾å¼è°ƒç”¨ * @return T* */ T *operator->() const &#123; return ptr; &#125; /** * @brief *é‡è½½ï¼Œå–å‡ºå¼•ç”¨å¯¹è±¡ * @return T&amp; */ T &amp;operator*() const &#123; return *ptr; &#125; /** * @brief è¿”å›å¼•ç”¨è®¡æ•° * @return å¼•ç”¨è®¡æ•° */ int use_count() const &#123; return ctrl_blk->count_ref; &#125; /** * @brief è¿”å›è£¸æŒ‡é’ˆ * @return å¼•ç”¨è®¡æ•° */ T *get() const &#123; return ptr; &#125; /** * @brief é‡å®šå‘ */ void reset(T * p)&#123; Release(); ptr = p; if (p)&#123; ctrl_blk = new controlblock(); &#125;else&#123; ctrl_blk = nullptr; &#125; &#125; &#125;; #endif å‡½æ•°å°è£… Function Encapsulationå››ç§å‡½æ•°å°è£…æ–¹å¼ å‡½æ•°æŒ‡é’ˆ ä»¿å‡½æ•°ï¼ˆå‡½æ•°å¯¹è±¡ï¼‰ std::function lambdaè¡¨è¾¾å¼ æ€§èƒ½æ•æ„Ÿåœºæ™¯ï¼šä¼˜å…ˆè€ƒè™‘å‡½æ•°æŒ‡é’ˆæˆ–æ¨¡æ¿ä»¿å‡½æ•° å›è°ƒç³»ç»Ÿï¼šä½¿ç”¨std::functionç»Ÿä¸€æ¥å£ å±€éƒ¨ç®—æ³•ï¼šlambdaè¡¨è¾¾å¼æœ€åˆé€‚ å…¼å®¹Cä»£ç ï¼šå¿…é¡»ä½¿ç”¨å‡½æ•°æŒ‡é’ˆ ç¤ºä¾‹ #ifndef FUNCTION_BIND_H #define FUNCTION_BIND_H #include &lt;iostream> #include &lt;functional> // 1. å‡½æ•°æŒ‡é’ˆ - æœ€åŸºç¡€çš„å‡½æ•°å°è£…æ–¹å¼ // ä¼˜ç‚¹ï¼šç®€å•ã€é«˜æ•ˆã€é›¶å¼€é”€ // ç¼ºç‚¹ï¼šæ— æ³•æ•è·ä¸Šä¸‹æ–‡ã€æ— æ³•å¤„ç†å¸¦çŠ¶æ€çš„å‡½æ•°å¯¹è±¡ int (*funcptr)(int, int); // å£°æ˜å‡½æ•°æŒ‡é’ˆç±»å‹ int add(int a, int b) &#123; return a + b; &#125; /* ä½¿ç”¨ç¤ºä¾‹ï¼š int main() &#123; funcptr = add; // æŒ‡å‘addå‡½æ•° int result = funcptr(1, 2); // è°ƒç”¨å‡½æ•° std::cout &lt;&lt; result &lt;&lt; std::endl; // è¾“å‡º: 3 &#125; */ // 2. ä»¿å‡½æ•°ï¼ˆå‡½æ•°å¯¹è±¡ï¼‰ - ç±»/ç»“æ„ä½“é‡è½½operator() // ä¼˜ç‚¹ï¼šå¯ä»¥æºå¸¦çŠ¶æ€ã€æ”¯æŒæ¨¡æ¿ç¼–ç¨‹ // ç¼ºç‚¹ï¼šéœ€è¦å®šä¹‰å®Œæ•´çš„ç±»ã€ä»£ç ç›¸å¯¹å†—é•¿ struct adder &#123; int to_add; adder(int value) : to_add(value) &#123;&#125; // æ„é€ å‡½æ•°åˆå§‹åŒ–çŠ¶æ€ int operator()(int value) // é‡è½½å‡½æ•°è°ƒç”¨è¿ç®—ç¬¦ &#123; return to_add + value; &#125; &#125;; /* ä½¿ç”¨ç¤ºä¾‹ï¼š int main() &#123; adder add_five(5); // åˆ›å»ºå¸¦çŠ¶æ€çš„å‡½æ•°å¯¹è±¡ int result = add_five(10); // è°ƒç”¨operator() std::cout &lt;&lt; result &lt;&lt; std::endl; // è¾“å‡º: 15 &#125; */ // 3. std::function - C++11å¼•å…¥çš„é€šç”¨å‡½æ•°åŒ…è£…å™¨ // ä¼˜ç‚¹ï¼šç±»å‹å®‰å…¨ã€ç»Ÿä¸€æ¥å£ã€å¯åŒ…è£…ä»»ä½•å¯è°ƒç”¨å¯¹è±¡ // ç¼ºç‚¹ï¼šæœ‰ä¸€å®šçš„è¿è¡Œæ—¶å¼€é”€ï¼ˆç±»å‹æ“¦é™¤ï¼‰ std::function&lt;int(int, int)> func1 = add; // åŒ…è£…å‡½æ•°æŒ‡é’ˆ std::function&lt;int(int)> func2 = adder(5); // åŒ…è£…å‡½æ•°å¯¹è±¡ std::function&lt;int(int, int)> func3 = // åŒ…è£…lambdaè¡¨è¾¾å¼ [](int a, int b) &#123; return a * b; &#125;; // 4. Lambdaè¡¨è¾¾å¼ - C++11å¼•å…¥çš„åŒ¿åå‡½æ•° // ä¼˜ç‚¹ï¼šè¯­æ³•ç®€æ´ã€å¯æ•è·ä¸Šä¸‹æ–‡ã€æ”¯æŒå¤šç§æ•è·æ¨¡å¼ // ç¼ºç‚¹ï¼šæ•è·å¤æ‚æ—¶å¯èƒ½é™ä½å¯è¯»æ€§ auto lambda1 = [](int a, int b) &#123; return a + b; &#125;; // æ— æ•è· int x = 10; auto lambda2 = [x](int y) &#123; return x + y; &#125;; // å€¼æ•è· auto lambda3 = [&amp;x](int y) &#123; x += y; return x; &#125;; // å¼•ç”¨æ•è· auto lambda4 = [=](int y) &#123; return x + y; &#125;; // éšå¼å€¼æ•è·å…¨éƒ¨ auto lambda5 = [&amp;](int y) &#123; x += y; return x; &#125;; // éšå¼å¼•ç”¨æ•è·å…¨éƒ¨ #endif åŒå‘é“¾è¡¨å®¹å™¨ Listæœ‰èŠ‚ç‚¹å®šä¹‰ï¼Œè¿­ä»£å™¨ç±»å’Œå®¹å™¨ç±» hpp #ifndef MYLIST_H #define MYLIST_H #include &lt;iostream> #include &lt;cassert> template &lt;typename T> struct ListNode &#123; T data; ListNode *pre; ListNode *next; ListNode(const T &amp;value) : data(value), pre(nullptr), next(nullptr) &#123;&#125; &#125;; template &lt;typename T> class Myiterator &#123; public: using self_type = Myiterator&lt;T>; using value_type = T; using reference = T &amp;; using pointer = T *; Myiterator(ListNode&lt;T> *ptr = nullptr) : node_ptr(ptr) &#123;&#125; reference operator*() const &#123; return node_ptr->data; &#125; pointer operator->() const &#123; return &amp;(node_ptr->data); &#125; // ++it self_type &amp;operator++() &#123; if (node_ptr != nullptr) &#123; node_ptr = node_ptr->next; &#125; return *this; &#125; // it++ self_type operator++(int) &#123; self_type tmp = *this; if (node_ptr != nullptr) &#123; node_ptr = node_ptr->next; &#125; return tmp; &#125; self_type &amp;operator--() &#123; if (node_ptr != nullptr) &#123; node_ptr = node_ptr->pre; &#125; return *this; &#125; self_type operator--(int) &#123; self_type tmp = *this; --(*this); return tmp; &#125; bool operator==(const self_type &amp;other) const &#123; return (other.node_ptr == node_ptr); &#125; bool operator!=(const self_type &amp;other) const &#123; return (other.node_ptr != node_ptr); &#125; private: /* data */ ListNode&lt;T> *node_ptr; friend class MyList&lt;T>; &#125;; template &lt;typename T> class MyList &#123; public: using iterator = Myiterator&lt;T>; private: ListNode&lt;T> *head; ListNode&lt;T> *tail; public: MyList() &#123; head = new ListNode&lt;T>(); tail = new ListNode&lt;T>(); head->next = tail; tail->pre = head; &#125; ~MyList() &#123; clear(); delete head; delete tail; &#125; MyList(const MyList &amp;other) = delete; MyList &amp;operator=(const MyList &amp;other) = delete; public: iterator insert(iterator pos, const T &amp;value) &#123; ListNode&lt;T> *node = pos.node_ptr; ListNode&lt;T> *newnode = new ListNode&lt;T>(value); ListNode&lt;T> *temp_pre = node->pre; newnode->next = node; newnode->pre = temp_pre; temp_pre->next = newnode; node->pre = newnode; return iterator(newnode); &#125; iterator erase(iterator pos) &#123; ListNode&lt;T> *node = pos.node_ptr; // ä¸èƒ½åˆ é™¤å¤´å°¾èŠ‚ç‚¹ if (node == head || node == tail) &#123; return iterator(tail); &#125; node->pre->next = node->next; node->next->pre = node->pre; ListNode&lt;T> *nextnode = node->next; delete node; return iterator(nextnode); &#125; void remove(const T&amp; target)&#123; for (iterator it = begin(); it != end();)&#123; if (*it == target) it = erase(it); else it++; &#125; &#125; void clear() &#123; ListNode&lt;T> *cur = head->next; while (cur != tail) &#123; ListNode&lt;T> *next = cur->next; delete cur; cur = next; &#125; head->next = tail; tail->pre = head; &#125; bool isempty() const &#123; return (head->next == tail); &#125; public: iterator begin() &#123; return iterator(head->next); &#125; iterator end() &#123; return iterator(tail); &#125; public: void push_back(const T &amp;value) &#123; insert(end(), value); &#125; void push_front(const T &amp;value) &#123; insert(begin(), value); &#125; void pop_front() &#123; if (!isempty()) erase(begin()); &#125; void pop_back() &#123; if (!isempty()) &#123; iterator tmp = end(); --tmp; erase(tmp); &#125; &#125; public: T &amp;front() &#123; assert(!isempty() &amp;&amp; \"Cannot access front of an empty list\"); return head->next->data; &#125; T &amp;back() &#123; assert(!isempty() &amp;&amp; \"Cannot access back of an empty list\"); return tail->pre->data; &#125; public: size_t size() const &#123; size_t count = 0; for (iterator it = begin(); it != end(); it++)&#123; count++; &#125; return count; &#125; &#125;; #endif åŒç«¯é˜Ÿåˆ—å®¹å™¨ Dequedeque é€šå¸¸ç”±ä¸€ç³»åˆ—å›ºå®šå¤§å°çš„æ•°ç»„å—ç»„æˆï¼Œè¿™äº›å—é€šè¿‡ä¸€ä¸ªä¸­å¤®æ•°ç»„è¿›è¡Œç®¡ç†æ•´ä¸ªç»“æ„ä½¿å¾—åœ¨ä¸¤ç«¯æ‰©å±•çš„æ—¶å€™ä¸éœ€è¦å†é‡æ–°åˆ†é…æ•´ä¸ªå®¹å™¨çš„å†…å­˜ ç®€åŒ–ç‰ˆï¼šç¯å½¢ç¼“å†²åŒºdeque æ”¯æŒéšæœºè®¿é—®å…ƒç´ æ”¯æŒåœ¨ä¸¤ç«¯é¢‘ç¹æ’å…¥å’Œåˆ é™¤å…ƒç´  å®ç° #ifndef MYDEQUE_H #define MYDEQUE_H #include &lt;iostream> template &lt;typename T> class MyDeque &#123; private: T *buffer; // ç¯å½¢ç¼“å†²åŒº size_t capacity; // ç¼“å†²åŒºå®¹é‡ size_t count; // å½“å‰å…ƒç´ æ•°é‡ size_t front_idx; // å‰ç«¯ç´¢å¼• size_t back_idx; // ä¸‹ä¸€ä¸ªæ’å…¥çš„ä½ç½®ï¼ˆå³æœ€åä¸€ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªä½ç½®ï¼‰ public: MyDeque(size_t initial_capacity = 10) : capacity(initial_capacity), count(0), front_idx(0), back_idx(0) &#123; // è°ƒç”¨Tçš„æ— å‚æ„é€  buffer = new T[capacity](); &#125; ~MyDeque() &#123; delete[] buffer; &#125; bool isempty() const &#123; return count == 0; &#125; size_t size() const &#123; return count; &#125; public: void resize(size_t new_capacity) &#123; T *new_buffer = new T[new_capacity](); for (size_t i = 0; i &lt; count; i++) &#123; new_buffer[i] = buffer[(front_idx + i) % capacity]; &#125; delete[] buffer; buffer = new_buffer; front_idx = 0; back_idx = count; capacity = new_capacity; &#125; void push_front(const T &amp;value) &#123; if (count == capacity) &#123; resize(capacity * 2); &#125; // æ›´æ–°front_idxä¸æ’å…¥å€¼, ç¯å½¢é€»è¾‘ front_idx = (front_idx - 1 + capacity) % capacity; buffer[front_idx] = value; count++; &#125; void push_back(const T &amp;value) &#123; if (count == capacity) &#123; resize(capacity * 2); &#125; // å…ˆèµ‹å€¼ç»™å½“å‰ä½ç½® buffer[back_idx] = value; // å†ç§»åŠ¨ back_idx åˆ°ä¸‹ä¸€ä¸ªä½ç½® back_idx = (back_idx + 1) % capacity; count++; &#125; void pop_front() &#123; if (isempty()) &#123; throw std::out_of_range(\"Deque is empty. \"); &#125; front_idx = (front_idx + 1) % capacity; count--; &#125; void pop_back() &#123; if (isempty()) &#123; throw std::out_of_range(\"Deque is empty. \"); &#125; back_idx = back_idx == 0 ? capacity - 1 : back_idx - 1; count--; &#125; const T &amp;front() const &#123; if (isempty()) &#123; throw std::out_of_range(\"Deque is empty. \"); &#125; return buffer[front_idx]; &#125; const T &amp;back() const &#123; if (isempty()) &#123; throw std::out_of_range(\"Deque is empty. \"); &#125; int last_idx = back_idx == 0 ? capacity - 1 : back_idx - 1; return buffer[last_idx]; &#125; // è¿­ä»£å™¨ class Myiterator &#123; public: using self_type = MyDeque&lt;T>; using value_type = T; using reference = T &amp;; using pointer = T *; private: MyDeque&lt;T> *_deque; size_t pos; public: Myiterator(self_type *ptr = nullptr, size_t position) : _deque(ptr), pos(position) &#123;&#125; reference operator*() const &#123; return _deque->buffer[(_deque->front_idx + pos) % _deque->capacity]; &#125; pointer operator->() const &#123; return &amp;(_deque->buffer[(_deque->front_idx + pos) % _deque->capacity]); &#125; // å‰ç½®++ Myiterator &amp;operator++() &#123; pos++; return *this; &#125; // åç½®++ Myiterator operator++(int) &#123; Myiterator tmp = *this; pos++; return tmp; &#125; bool operator==(const Myiterator &amp;other) const &#123; return _deque == other._deque &amp;&amp; pos == other.pos; &#125; bool operator!=(const Myiterator &amp;other) const &#123; return !(*this == other); &#125; &#125;; MyDeque begin()&#123; return Myiterator(this, 0); &#125; &#125;; #endif BSTå’ŒAVLå®ç°mapstlä¸­çš„mapåº•å±‚æ˜¯ç”¨çº¢é»‘æ ‘å®ç°çš„ï¼Œçº¢é»‘æ ‘çš„æ’å…¥åˆ é™¤æ“ä½œç›¸å¯¹å¤æ‚ï¼Œè¿™é‡Œç”¨æ™®é€šçš„äºŒå‰æœç´¢æ ‘å’Œè‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘å®ç°ä¸€ä¸ªmapã€‚map æ˜¯ä¸€ç§é”®å€¼å¯¹æ•°æ®ç»“æ„ï¼Œåœ¨è®¸å¤šç®—æ³•å’Œç³»ç»Ÿè®¾è®¡ä¸­éƒ½æœ‰å¹¿æ³›çš„åº”ç”¨ã€‚é€šè¿‡å°è£…ä¸åŒçš„æ ‘ç»“æ„ï¼Œmap æä¾›äº†é«˜æ•ˆçš„å…ƒç´ æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œã€‚ 1. åŸºäºäºŒå‰æœç´¢æ ‘ (BST) çš„å®ç°äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰æ˜¯ä¸€ç§ç‰¹æ®Šçš„äºŒå‰æ ‘ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å¤§äºå·¦å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå¹¶ä¸”å°äºå³å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚è¿™æ ·çš„æ€§è´¨ä½¿å¾—äºŒå‰æœç´¢æ ‘èƒ½å¤Ÿæ”¯æŒé«˜æ•ˆçš„æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œã€‚åœ¨æœ€ç†æƒ³çš„æƒ…å†µä¸‹ï¼ŒBST èƒ½å¤Ÿä»¥å¯¹æ•°æ—¶é—´å¤æ‚åº¦ O(log n) è¿›è¡Œè¿™äº›æ“ä½œã€‚ç„¶è€Œï¼Œè‹¥æ ‘ä¸å¹³è¡¡ï¼Œæœ€åçš„æƒ…å†µä¼šé€€åŒ–ä¸ºé“¾è¡¨ï¼Œå¯¼è‡´æ“ä½œæ—¶é—´å¤æ‚åº¦ä¸º O(n)ã€‚ BST-map #ifndef MYMAP_H #define MYMAP_H /* BST å®ç°map ï¼ˆä¸åŒäºstd::mapï¼Œstd::mapæ˜¯åŸºäºå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œ æ¯”å¦‚çº¢é»‘æ ‘å®ç°çš„ï¼‰ è¿™é‡Œä½¿ç”¨æ™®é€šçš„äºŒå‰æœç´¢æ ‘ï¼Œéè‡ªåŠ¨å¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ */ #include &lt;iostream> #include &lt;utility> #include &lt;exception> #include &lt;stack> template &lt;typename Key, typename T> struct TreeNode &#123; std::pair&lt;Key, T> data; TreeNode *left; TreeNode *right; TreeNode *parent; TreeNode(const Key &amp;key, const T &amp;value, TreeNode *parentnode = nullptr) : data(std::make_pair(key, value)), left(nullptr), right(nullptr), parent(parentnode) &#123;&#125; &#125;; template &lt;typename Key, typename T> class Mymap &#123; private: // åªä¿å­˜æ ¹èŠ‚ç‚¹ TreeNode&lt;Key, T> *root; public: /** * @brief é»˜è®¤æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–ç©ºçš„æ˜ å°„ */ Mymap() : root(nullptr) &#123;&#125; // ææ„æ—¶æŒ‰ç…§é€’å½’çš„æ–¹å¼å›æ”¶èµ„æº // helper function void release(TreeNode&lt;Key, T> *node) &#123; if (node == nullptr) return; if (node->right) release(node->right); if (node->left) release(node->left); delete node; &#125; /** * @brief ææ„å‡½æ•°ï¼Œé‡Šæ”¾æ‰€æœ‰èŠ‚ç‚¹å†…å­˜ */ ~Mymap() &#123; release(root); &#125; Mymap(const Mymap &amp;other) = delete; Mymap &amp;operator=(const Mymap &amp;other) = delete; public: /** * @brief æ’å…¥é”®å€¼å¯¹åˆ°æ˜ å°„ä¸­ * @param key è¦æ’å…¥çš„é”® * @param value è¦æ’å…¥çš„å€¼ * @note å¦‚æœé”®å·²å­˜åœ¨ï¼Œåˆ™æ›´æ–°å¯¹åº”çš„å€¼ */ void insert(const Key &amp;key, const T &amp;value) &#123; if (root == nullptr) &#123; root = new TreeNode&lt;Key, T>(key, value); return; &#125; TreeNode&lt;Key, T> *current = root; TreeNode&lt;Key, T> *parent = nullptr; while (current != nullptr) &#123; parent = current; if (key &lt; current->data.first) &#123; current = current->left; &#125; else if (key > current->data.first) &#123; current = current->right; &#125; else &#123; current->data.second = value; return; &#125; &#125; if (key &lt; parent->data.first) parent->left = new TreeNode&lt;Key, T>(key, value, parent); else parent->right = new TreeNode&lt;Key, T>(key, value, parent); &#125; public: /** * @brief æ‰¾åˆ°æŸä¸€èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹ * @param node èµ·å§‹èŠ‚ç‚¹ï¼ˆå‡è®¾ä¸ä¸ºç©ºï¼‰ * @return å·¦å­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹ */ TreeNode&lt;Key, T> *mininumNode(TreeNode&lt;Key, T> *node) const &#123; while (node->left != nullptr) &#123; node = node->left; &#125; return node; &#125; /** * @brief æ‰¾åˆ°èŠ‚ç‚¹çš„åç»­èŠ‚ç‚¹ï¼ˆä¸­åºéå†ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ * @param node èµ·å§‹èŠ‚ç‚¹ï¼ˆå‡è®¾ä¸ä¸ºç©ºï¼‰ * @return åç»­èŠ‚ç‚¹ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›nullptr */ TreeNode&lt;Key, T> *successorNode(TreeNode&lt;Key, T> *node) const &#123; // å³å­æ ‘ä¸ä¸ºç©º if (node->right != nullptr) &#123; return mininumNode(node->right); &#125; // å³å­æ ‘ä¸ºç©º TreeNode&lt;Key, T> *p = node->parent; while (p != nullptr &amp;&amp; node == p->right) &#123; node = p; p = p->parent; &#125; return p; &#125; /** * @brief åˆ é™¤æŒ‡å®šé”®çš„èŠ‚ç‚¹ * @param key è¦åˆ é™¤çš„é”® * @note å¦‚æœé”®ä¸å­˜åœ¨ï¼Œåˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œ */ void erase(const Key &amp;key) &#123; TreeNode&lt;Key, T> *node = find(key); if (node == nullptr) return; // æƒ…å†µ1ï¼šåˆ é™¤çš„èŠ‚ç‚¹æ²¡æœ‰å­èŠ‚ç‚¹ if (node->left == nullptr &amp;&amp; node->right == nullptr) &#123; if (node->parent == nullptr) &#123; // åˆ é™¤çš„æ˜¯æ ¹èŠ‚ç‚¹ delete node; root = nullptr; &#125; else &#123; if (node == node->parent->left) node->parent->left = nullptr; else node->parent->right = nullptr; delete node; &#125; &#125; // æƒ…å†µ2ï¼šåˆ é™¤çš„èŠ‚ç‚¹æœ‰ä¸€ä¸ªå­èŠ‚ç‚¹ else if (node->left == nullptr || node->right == nullptr) &#123; TreeNode&lt;Key, T> *child = (node->left != nullptr) ? node->left : node->right; if (node->parent == nullptr) &#123; // åˆ é™¤çš„æ˜¯æ ¹èŠ‚ç‚¹ root = child; child->parent = nullptr; delete node; &#125; else &#123; if (node == node->parent->left) node->parent->left = child; else node->parent->right = child; child->parent = node->parent; delete node; &#125; &#125; // æƒ…å†µ3ï¼šåˆ é™¤çš„èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ else &#123; TreeNode&lt;Key, T> *successor = successorNode(node); // ç”¨åç»§èŠ‚ç‚¹çš„å€¼æ›¿æ¢å½“å‰èŠ‚ç‚¹ node->data = successor->data; // ç°åœ¨é—®é¢˜è½¬åŒ–ä¸ºåˆ é™¤successorèŠ‚ç‚¹ // successoræœ€å¤šåªæœ‰ä¸€ä¸ªå³å­èŠ‚ç‚¹ï¼ˆå› ä¸ºå®ƒæ˜¯å³å­æ ‘çš„æœ€å°å€¼ï¼Œæ²¡æœ‰å·¦å­èŠ‚ç‚¹ï¼‰ // é‡æ–°è®¾ç½®nodeæŒ‡å‘successorï¼Œç„¶åæŒ‰ç…§æƒ…å†µ1æˆ–2åˆ é™¤ TreeNode&lt;Key, T> *child = successor->right; TreeNode&lt;Key, T> *parent = successor->parent; // æ›´æ–°çˆ¶èŠ‚ç‚¹æŒ‡å‘ if (successor == parent->left) parent->left = child; else parent->right = child; // æ›´æ–°å­èŠ‚ç‚¹çš„çˆ¶æŒ‡é’ˆ if (child != nullptr) child->parent = parent; // åˆ é™¤successor delete successor; &#125; &#125; public: /** * @brief æŸ¥æ‰¾æŒ‡å®šé”®çš„èŠ‚ç‚¹ * @param key è¦æŸ¥æ‰¾çš„é”® * @return æ‰¾åˆ°çš„èŠ‚ç‚¹æŒ‡é’ˆï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›nullptr */ TreeNode&lt;Key, T> *find(const Key &amp;key) const &#123; TreeNode&lt;Key, T> *currentnode = root; while (currentnode != nullptr) &#123; if (key &lt; currentnode->data.first) currentnode = currentnode->left; else if (key > currentnode->data.first) currentnode = currentnode->right; else return currentnode; &#125; return nullptr; &#125; &#125;; #endif 2. åŸºäº AVL æ ‘çš„å®ç°ä¸ºäº†å…‹æœæ™®é€šäºŒå‰æœç´¢æ ‘åœ¨æœ€åæƒ…å†µä¸‹çš„é€€åŒ–é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ AVL æ ‘ï¼Œå®ƒæ˜¯ä¸€ç§è‡ªå¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ã€‚AVL æ ‘é€šè¿‡ä¿æŒæ¯ä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­ï¼ˆå·¦å³å­æ ‘çš„é«˜åº¦å·®ä¸è¶…è¿‡ 1ï¼‰æ¥ç¡®ä¿æ ‘çš„å¹³è¡¡æ€§ã€‚è¿™ç§å¹³è¡¡ç­–ç•¥ä½¿å¾— AVL æ ‘åœ¨ä»»ä½•æ—¶å€™éƒ½ä¿æŒè¾ƒä¸ºç†æƒ³çš„æ ‘å½¢ç»“æ„ï¼Œä»è€Œä¿è¯æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œéƒ½èƒ½åœ¨ O(log n) çš„æ—¶é—´å¤æ‚åº¦å†…å®Œæˆã€‚ AVL-map #ifndef MYAVLTREE_H #define MYAVLTREE_H #include &lt;iostream> #include &lt;string> #include &lt;exception> #include &lt;algorithm> #include &lt;functional> #include &lt;vector> #include &lt;utility> /** * @brief AVL æ ‘èŠ‚ç‚¹ç»“æ„ä½“ * @tparam Key é”®ç±»å‹ * @tparam Value å€¼ç±»å‹ */ template &lt;typename Key, typename Value> struct TreeNode &#123; std::pair&lt;Key, Value> data; ///&lt; å­˜å‚¨é”®å€¼å¯¹æ•°æ® TreeNode *left; ///&lt; å·¦å­èŠ‚ç‚¹æŒ‡é’ˆ TreeNode *right; ///&lt; å³å­èŠ‚ç‚¹æŒ‡é’ˆ int height; ///&lt; èŠ‚ç‚¹é«˜åº¦ /** * @brief æ„é€ å‡½æ•° * @param k é”® * @param v å€¼ */ TreeNode(const Key &amp;k, const Value &amp;v) : data(std::make_pair(k, v)), height(1), left(nullptr), right(nullptr) &#123;&#125; &#125;; /** * @brief è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼ˆAVLæ ‘ï¼‰å®ç° * @tparam Key é”®ç±»å‹ï¼Œå¿…é¡»æ”¯æŒæ¯”è¾ƒæ“ä½œ * @tparam Value å€¼ç±»å‹ */ template &lt;typename Key, typename Value> class MyAVLTree &#123; public: using node = TreeNode&lt;Key, Value>; ///&lt; èŠ‚ç‚¹ç±»å‹åˆ«å private: node *root; ///&lt; æ ‘çš„æ ¹èŠ‚ç‚¹ /** * @brief è·å–èŠ‚ç‚¹é«˜åº¦ * @param n èŠ‚ç‚¹æŒ‡é’ˆ * @return èŠ‚ç‚¹é«˜åº¦ï¼Œç©ºèŠ‚ç‚¹è¿”å›0 */ int getHeight(node *n) &#123; if (n == nullptr) return 0; return n->height; &#125; /** * @brief è®¡ç®—èŠ‚ç‚¹çš„å¹³è¡¡å› å­ * @param n èŠ‚ç‚¹æŒ‡é’ˆ * @return å¹³è¡¡å› å­ = å·¦å­æ ‘é«˜åº¦ - å³å­æ ‘é«˜åº¦ */ int getbalance(node *n) &#123; if (n == nullptr) return 0; else return getHeight(n->left) - getHeight(n->right); &#125; /** * @brief å¯¹èŠ‚ç‚¹è¿›è¡Œå³æ—‹æ“ä½œï¼ˆLLå‹ä¸å¹³è¡¡ï¼‰ * @param objectnode éœ€è¦æ—‹è½¬çš„èŠ‚ç‚¹ * @return æ—‹è½¬åæ–°çš„å­æ ‘æ ¹èŠ‚ç‚¹ */ node *rightrotate(node *objectnode) &#123; node *x = objectnode->left; node *origin = x->right; x->right = objectnode; objectnode->left = origin; objectnode->height = std::max(getHeight(objectnode->left), getHeight(objectnode->right)) + 1; x->height = std::max(getHeight(x->left), getHeight(x->right)) + 1; return x; &#125; /** * @brief å¯¹èŠ‚ç‚¹è¿›è¡Œå·¦æ—‹æ“ä½œï¼ˆRRå‹ä¸å¹³è¡¡ï¼‰ * @param objectnode éœ€è¦æ—‹è½¬çš„èŠ‚ç‚¹ * @return æ—‹è½¬åæ–°çš„å­æ ‘æ ¹èŠ‚ç‚¹ */ node *leftrotate(node *objectnode) &#123; node *x = objectnode->right; node *origin = x->left; x->left = objectnode; objectnode->right = origin; x->height = std::max(getHeight(x->right), getHeight(x->left)) + 1; objectnode->height = std::max(getHeight(objectnode->right), getHeight(objectnode->left)) + 1; return x; &#125; /** * @brief æŸ¥æ‰¾å­æ ‘ä¸­çš„æœ€å°é”®å€¼èŠ‚ç‚¹ * @param cur å­æ ‘æ ¹èŠ‚ç‚¹ * @return æœ€å°é”®å€¼èŠ‚ç‚¹æŒ‡é’ˆ */ node *getminvaluenode(node *cur) &#123; node *current = cur; while (current->left != nullptr) &#123; current = current->left; &#125; return current; &#125; /** * @brief é€’å½’åˆ é™¤æ‰€æœ‰èŠ‚ç‚¹ï¼ˆç”¨äºææ„å‡½æ•°ï¼‰ * @param n è¦åˆ é™¤çš„å­æ ‘æ ¹èŠ‚ç‚¹ */ void destroy(node *n) &#123; if (n == nullptr) return; destroy(n->left); destroy(n->right); delete n; &#125; public: /** * @brief é»˜è®¤æ„é€ å‡½æ•° * @post åˆ›å»ºç©ºçš„AVLæ ‘ */ MyAVLTree() : root(nullptr) &#123;&#125; /** * @brief ææ„å‡½æ•° * @post é‡Šæ”¾æ‰€æœ‰èŠ‚ç‚¹å†…å­˜ */ ~MyAVLTree() &#123; destroy(root); root = nullptr; &#125; /** * @brief åœ¨æ ‘ä¸­æ’å…¥é”®å€¼å¯¹ï¼ˆå…¬å¼€æ¥å£ï¼‰ * @param key è¦æ’å…¥çš„é”® * @param value è¦æ’å…¥çš„å€¼ * @note å¦‚æœé”®å·²å­˜åœ¨ï¼Œåˆ™æ›´æ–°å¯¹åº”çš„å€¼ */ void insert(const Key &amp;key, const Value &amp;value) &#123; root = insert(root, key, value); &#125; /** * @brief ä»æ ‘ä¸­åˆ é™¤æŒ‡å®šé”®çš„èŠ‚ç‚¹ï¼ˆå…¬å¼€æ¥å£ï¼‰ * @param key è¦åˆ é™¤çš„é”® * @note å¦‚æœé”®ä¸å­˜åœ¨ï¼Œåˆ™ä¸è¿›è¡Œä»»ä½•æ“ä½œ */ void remove(const Key &amp;key) &#123; root = deletenode(root, key); &#125; private: /** * @brief é€’å½’æ’å…¥é”®å€¼å¯¹åˆ°å­æ ‘ä¸­ï¼ˆå†…éƒ¨å®ç°ï¼‰ * @param node å­æ ‘æ ¹èŠ‚ç‚¹ * @param key è¦æ’å…¥çš„é”® * @param value è¦æ’å…¥çš„å€¼ * @return æ’å…¥åæ–°çš„å­æ ‘æ ¹èŠ‚ç‚¹ */ node *insert(node *node, const Key &amp;key, const Value &amp;value) &#123; if (node == nullptr) &#123; return new TreeNode&lt;Key, Value>(key, value); &#125; // é€’å½’æŸ¥æ‰¾æ’å…¥ä½ç½® if (key &lt; node->data.first) &#123; node->left = insert(node->left, key, value); &#125; else if (key > node->data.first) &#123; node->right = insert(node->right, key, value); &#125; else &#123; // é”®å·²å­˜åœ¨ï¼Œæ›´æ–°å€¼ node->data.second = value; return node; &#125; // æ›´æ–°èŠ‚ç‚¹é«˜åº¦ node->height = 1 + std::max(getHeight(node->left), getHeight(node->right)); // æ£€æŸ¥å¹³è¡¡å¹¶æ—‹è½¬ int balance = getbalance(node); // å·¦å·¦æƒ…å†µï¼ˆLLï¼‰ if (balance > 1 &amp;&amp; key &lt; node->left->data.first) &#123; return rightrotate(node); &#125; // å³å³æƒ…å†µï¼ˆRRï¼‰ if (balance &lt; -1 &amp;&amp; key > node->right->data.first) &#123; return leftrotate(node); &#125; // å·¦å³æƒ…å†µï¼ˆLRï¼‰ if (balance > 1 &amp;&amp; key > node->left->data.first) &#123; node->left = leftrotate(node->left); return rightrotate(node); &#125; // å³å·¦æƒ…å†µï¼ˆRLï¼‰ if (balance &lt; -1 &amp;&amp; key &lt; node->right->data.first) &#123; node->right = rightrotate(node->right); return leftrotate(node); &#125; return node; &#125; /** * @brief é€’å½’åˆ é™¤å­æ ‘ä¸­çš„èŠ‚ç‚¹ï¼ˆå†…éƒ¨å®ç°ï¼‰ * @param root å­æ ‘æ ¹èŠ‚ç‚¹ * @param key è¦åˆ é™¤çš„é”® * @return åˆ é™¤åæ–°çš„å­æ ‘æ ¹èŠ‚ç‚¹ */ node *deletenode(node *root, const Key &amp;key) &#123; if (root == nullptr) return root; // é€’å½’æŸ¥æ‰¾è¦åˆ é™¤çš„èŠ‚ç‚¹ if (key &lt; root->data.first) &#123; root->left = deletenode(root->left, key); &#125; else if (key > root->data.first) &#123; root->right = deletenode(root->right, key); &#125; else &#123; // æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹ // æƒ…å†µ1ï¼šæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹æˆ–æ²¡æœ‰å­èŠ‚ç‚¹ if ((root->left == nullptr) || (root->right == nullptr)) &#123; auto *temp = root->left ? root->left : root->right; if (temp == nullptr) // æ— å­èŠ‚ç‚¹ &#123; temp = root; root = nullptr; &#125; else // æœ‰ä¸€ä¸ªå­èŠ‚ç‚¹ &#123; *root = *temp; // å€¼ä¼ é€’ &#125; delete temp; &#125; // æƒ…å†µ2ï¼šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ else &#123; auto *temp = getminvaluenode(root->right); root->data.first = temp->data.first; root->data.second = temp->data.second; root->right = deletenode(root->right, temp->data.first); &#125; &#125; if (root == nullptr) return root; // æ›´æ–°é«˜åº¦ root->height = 1 + std::max(getHeight(root->left), getHeight(root->right)); // æ£€æŸ¥å¹³è¡¡å¹¶æ—‹è½¬ int balance = getbalance(root); // å·¦å·¦æƒ…å†µï¼ˆLLï¼‰ if (balance > 1 &amp;&amp; getbalance(root->left) >= 0) return rightrotate(root); // å³å³æƒ…å†µï¼ˆRRï¼‰ if (balance &lt; -1 &amp;&amp; getbalance(root->right) &lt;= 0) return leftrotate(root); // å·¦å³æƒ…å†µï¼ˆLRï¼‰ if (balance > 1 &amp;&amp; getbalance(root->left) &lt; 0) &#123; root->left = leftrotate(root->left); return rightrotate(root); &#125; // å³å·¦æƒ…å†µï¼ˆRLï¼‰ if (balance &lt; -1 &amp;&amp; getbalance(root->right) > 0) &#123; root->right = rightrotate(root->right); return leftrotate(root); &#125; return root; &#125; &#125;; #endif æ— åºæ˜ å°„è¡¨ unordered_mapå“ˆå¸Œè¡¨æ˜¯ç°ä»£ç¼–ç¨‹ä¸­æœ€é«˜æ•ˆçš„æ•°æ®ç»“æ„ä¹‹ä¸€ï¼Œå…¶æ ¸å¿ƒåœ¨äºé€šè¿‡å“ˆå¸Œå‡½æ•°å®ç°é”®åˆ°å­˜å‚¨ä½ç½®çš„ç›´æ¥æ˜ å°„ã€‚è¿™é‡Œå®ç°çš„å¼€é“¾æ³•å“ˆå¸Œè¡¨é‡‡ç”¨ä¸­å¿ƒæ•°ç»„åŠ é“¾è¡¨çš„ç»“æ„ï¼šå“ˆå¸Œå‡½æ•°å°†é”®è½¬æ¢ä¸ºæ•°ç»„ç´¢å¼•ï¼Œå†²çªå…ƒç´ é€šè¿‡é“¾è¡¨è¿æ¥ï¼Œåœ¨ä¿è¯ç©ºé—´æ•ˆç‡çš„åŒæ—¶ç»´æŒäº†å¹³å‡O(1)çš„æŸ¥è¯¢æ€§èƒ½ã€‚ è´Ÿè½½å› å­ç›‘æ§ä¸è‡ªåŠ¨æ‰©å®¹æœºåˆ¶æ˜¯ä¿æŒé«˜æ€§èƒ½çš„å…³é”®ã€‚å½“å…ƒç´ å¯†åº¦è¶…è¿‡é˜ˆå€¼æ—¶ï¼Œç³»ç»Ÿæ‰§è¡Œrehashæ“ä½œâ€”â€”åˆ›å»ºæ›´å¤§çš„æ¡¶æ•°ç»„å¹¶é‡æ–°åˆ†é…æ‰€æœ‰å…ƒç´ ï¼Œè¿™ä¸€è¿‡ç¨‹è™½ç„¶ä»£ä»·é«˜æ˜‚ï¼Œä½†ç¡®ä¿äº†å“ˆå¸Œè¡¨é•¿æœŸè¿è¡Œçš„é«˜æ•ˆæ€§ã€‚ è¿­ä»£å™¨çš„å®ç°å±•ç¤ºäº†å“ˆå¸Œè¡¨éå†çš„å¤æ‚æ€§ï¼šå®ƒä¸ä»…è¦éå†é“¾è¡¨ï¼Œè¿˜è¦åœ¨æ¡¶é—´æ™ºèƒ½è·³è½¬ã€‚ hashmap #ifndef MYHASH_H #define MYHASH_H #include &lt;iostream> #include &lt;utility> #include &lt;vector> #include &lt;functional> #include &lt;list> #include &lt;iterator> #include &lt;stdexcept> /** * @brief å“ˆå¸Œé“¾è¡¨èŠ‚ç‚¹ * @tparam Key é”®ç±»å‹ * @tparam Value å€¼ç±»å‹ */ template &lt;typename Key, typename Value> struct HashNode &#123; std::pair&lt;Key, Value> data; HashNode *next; /** * @brief æ„é€ ä¸€ä¸ªå“ˆå¸ŒèŠ‚ç‚¹ * @param key èŠ‚ç‚¹é”® * @param value èŠ‚ç‚¹å€¼ */ HashNode(const Key &amp;key, const Value &amp;value) : data(std::make_pair(key, value)), next(nullptr) &#123;&#125; &#125;; /** * @brief ç®€å•å“ˆå¸Œè¡¨ï¼ˆå¼€é“¾è§£å†³å†²çªï¼‰ * @tparam Key é”®ç±»å‹ * @tparam Value å€¼ç±»å‹ * @tparam Hash å“ˆå¸Œå‡½æ•°ç±»å‹ï¼ˆé»˜è®¤ä¸º std::hash&lt;Key>ï¼‰ * * åŠŸèƒ½ï¼šæ’å…¥ã€æŸ¥æ‰¾ã€åˆ é™¤ã€æ¸…ç©ºã€è¿­ä»£ç­‰ã€‚è‡ªåŠ¨æŒ‰ç…§è´Ÿè½½å› å­è¿›è¡Œ rehashï¼ˆæ‰©å®¹ï¼‰ã€‚ */ template &lt;typename Key, typename Value, typename Hash = std::hash&lt;Key>> class MyHashMap &#123; public: class Iterator; using key_type = Key; using mapped_type = Value; using value_type = std::pair&lt;const Key, Value>; using size_type = std::size_t; /** * @brief æ„é€ å‡½æ•° * @param initial_capacity åˆå§‹æ¡¶æ•°é‡ * @param max_load_factor æœ€å¤§è´Ÿè½½å› å­ï¼ˆè¶…è¿‡åˆ™è§¦å‘ rehashï¼‰ */ MyHashMap(size_type initial_capacity = 16, double max_load_factor = 0.75) : bucket_count_(initial_capacity), element_count_(0), max_load_factor_(max_load_factor), hash_func_(Hash()) &#123; // ç”¨vectorçš„resizeæ¥é‡æ–°æ‰©å®¹ buckets_.resize(bucket_count_); &#125; /** * @brief ææ„å‡½æ•°ï¼Œé‡Šæ”¾æ‰€æœ‰èŠ‚ç‚¹ */ ~MyHashMap() &#123; clear(); &#125; /** * @brief æ¸…ç©ºå“ˆå¸Œè¡¨ï¼Œé‡Šæ”¾æ‰€æœ‰èŠ‚ç‚¹ */ void clear() &#123; for (size_type i = 0; i &lt; bucket_count_; ++i) &#123; HashNode&lt;Key, Value> *current_node = buckets_[i]; while (current_node != nullptr) &#123; HashNode&lt;Key, Value> *temp = current_node; current_node = current_node->next; delete temp; &#125; buckets_[i] = nullptr; &#125; element_count_ = 0; &#125; MyHashMap(const MyHashMap &amp;other) = delete; MyHashMap &amp;operator=(const MyHashMap &amp;other) = delete; /** * @brief æ’å…¥æˆ–æ›´æ–°é”®å€¼å¯¹ * @param key é”® * @param value å€¼ * * è‹¥é”®å·²å­˜åœ¨åˆ™æ›´æ–°å…¶å€¼ï¼Œå¦åˆ™æ’å…¥æ–°èŠ‚ç‚¹ï¼›æ’å…¥åè‹¥è´Ÿè½½å› å­è¶…è¿‡é˜ˆå€¼åˆ™ rehashã€‚ */ void insert(const Key &amp;key, const Value &amp;value) &#123; // è¿›è¡Œå“ˆå¸Œæ˜ å°„ size_type hash_value = hash_func_(key); size_type index = hash_value % bucket_count_; HashNode&lt;Key, Value> *node = buckets_[index]; while (node != nullptr) &#123; if (node->data.first == key) &#123; node->data.second = value; return; &#125; node = node->next; &#125; HashNode&lt;Key, Value> *newnode = new HashNode&lt;Key, Value>(key, value); newnode->next = buckets_[index]; buckets_[index] = newnode; ++element_count_; // æ£€æŸ¥è´Ÿè½½å› å­ // è´Ÿè½½å› å­è®¡ç®—æ–¹å¼ï¼š element_count_ / bucket_count_ // å¯ä»¥ç†è§£ä¸º æ¯ä¸ªæ¡¶å¹³å‡æœ‰å¤šå°‘å…ƒç´  auto load_factor = static_cast&lt;double>(element_count_) / bucket_count_; if (load_factor > max_load_factor_) &#123; rehash(); &#125; &#125; /** * @brief æ ¹æ®é”®æŸ¥æ‰¾å€¼çš„æŒ‡é’ˆ * @param key ç›®æ ‡é”® * @return æŒ‡å‘å€¼çš„æŒ‡é’ˆï¼›æ‰¾ä¸åˆ°è¿”å› nullptr */ Value *find(const Key &amp;key) &#123; auto hash_value = hash_func_(key); auto index = hash_value % bucket_count_; HashNode&lt;Key, Value> *node = buckets_[index]; while (node != nullptr) &#123; if (node->data.first == key) &#123; return &amp;(node->data.second); &#125; node = node->next; &#125; return nullptr; &#125; /** * @brief åˆ é™¤æŒ‡å®šé”®ï¼ˆè‹¥å­˜åœ¨ï¼‰ * @param key è¦åˆ é™¤çš„é”® * @return åˆ é™¤æˆåŠŸè¿”å› trueï¼Œå¦åˆ™ false */ bool erase(const Key &amp;key) &#123; auto hash_value = hash_func_(key); auto index = hash_value % bucket_count_; auto node = buckets_[index]; HashNode&lt;Key, Value> *prev = nullptr; while (node != nullptr) &#123; if (node->data.first == key) &#123; if (prev == nullptr) &#123; buckets_[index] = node->next; &#125; else &#123; prev->next = node->next; &#125; delete node; --element_count_; return true; &#125; prev = node; node = node->next; &#125; return false; &#125; size_type size() const &#123; return element_count_; &#125; bool empty() const &#123; return element_count_ == 0; &#125; Iterator begin() &#123; for (size_type i = 0; i &lt; bucket_count_; ++i) &#123; if (buckets_[i] != nullptr) &#123; return Iterator(this, i, buckets_[i]); &#125; &#125; return end(); &#125; Iterator end() &#123; return Iterator(this, bucket_count_, nullptr); &#125; class Iterator &#123; public: using iterator_category = std::forward_iterator_tag; using value_type = std::pair&lt;Key, Value>; using difference_type = std::ptrdiff_t; using pointer = value_type *; using reference = value_type &amp;; /** * @brief æ„é€ ä¸€ä¸ªè¿­ä»£å™¨ * @param map æŒ‡å‘æ‰€å±å“ˆå¸Œè¡¨ * @param bucket_index_ å½“å‰æ¡¶ç´¢å¼• * @param node å½“å‰èŠ‚ç‚¹æŒ‡é’ˆï¼ˆå¯ä¸º nullptr è¡¨ç¤º endï¼‰ */ Iterator(MyHashMap *map, size_t bucket_index_, HashNode&lt;Key, Value> *node) : map_(map), bucket_index_(bucket_index_), current_node_(node) &#123;&#125; /** * @brief è§£é™¤å¼•ç”¨ï¼Œè¿”å›å½“å‰é”®å€¼å¯¹ï¼ˆå¼•ç”¨ï¼‰ * @throws std::out_of_range è‹¥è¿­ä»£å™¨å·²è¶Šç•Œï¼ˆnullptrï¼‰ */ reference operator*() const &#123; if (current_node_ == nullptr) &#123; throw std::out_of_range(\"Iterator out of range\"); &#125; return current_node_->data; &#125; /** * @brief æŒ‡é’ˆè®¿é—®å½“å‰å…ƒç´  * @throws std::out_of_range è‹¥è¿­ä»£å™¨å·²è¶Šç•Œï¼ˆnullptrï¼‰ */ pointer operator->() const &#123; if (current_node_ == nullptr) &#123; throw std::out_of_range(\"Iterator out of range\"); &#125; return &amp;(current_node_->data); &#125; Iterator &amp;operator++() &#123; advance(); return *this; &#125; Iterator operator++(int) &#123; Iterator temp = *this; advance(); return temp; &#125; /** * @brief ç›¸ç­‰æ¯”è¾ƒ */ bool operator==(const Iterator &amp;other) const &#123; return map_ == other.map_ &amp;&amp; bucket_index_ == other.bucket_index_ &amp;&amp; current_node_ == other.current_node_; &#125; /** * @brief ä¸ç­‰æ¯”è¾ƒ */ bool operator!=(const Iterator &amp;other) const &#123; return !(*this == other); &#125; private: MyHashMap *map_; size_type bucket_index_; HashNode&lt;Key, Value> *current_node_; // è¿­ä»£å™¨å‰è¿›çš„å‡½æ•° void advance() &#123; // å…ˆå°è¯•åœ¨å½“å‰æ¡¶çš„é“¾è¡¨ä¸­å‰è¿› if (current_node_ != nullptr) &#123; current_node_ = current_node_->next; &#125; // åˆ°è¾¾å½“å‰æ¡¶çš„æœ«å°¾ï¼Œç»§ç»­å¯»æ‰¾ä¸‹ä¸€ä¸ªéç©ºæ¡¶ while (current_node_ == nullptr) &#123; ++bucket_index_; if (bucket_index_ >= map_->bucket_count_) &#123; // å·²ç»è¶…è¿‡æœ€åä¸€ä¸ªæ¡¶ï¼Œè®¾ç½®ç»“æŸçŠ¶æ€ current_node_ = nullptr; break; &#125; current_node_ = map_->buckets_[bucket_index_]; &#125; &#125; &#125;; // Iterator ç±»ç»“æŸï¼ˆæ³¨æ„åˆ†å·ï¼‰ private: // ä¸­å¤®æ•°ç»„ std::vector&lt;HashNode&lt;Key, Value> *> buckets_; // æ¡¶çš„æ•°é‡ size_type bucket_count_; // æ€»å…ƒç´ æ•°é‡ size_type element_count_; // è´Ÿè½½å› å­ double max_load_factor_; // å“ˆå¸Œå‡½æ•° Hash hash_func_; // é‡æ–°å“ˆå¸Œï¼Œæ‰©å®¹å¹¶é‡æ–°åˆ†é…å…ƒç´  void rehash() &#123; size_type new_bucket_count = bucket_count_ * 2; std::vector&lt;HashNode&lt;Key, Value> *> new_buckets(new_bucket_count, nullptr); for (size_type i = 0; i &lt; bucket_count_; ++i) &#123; HashNode&lt;Key, Value> *node = buckets_[i]; while (node != nullptr) &#123; HashNode&lt;Key, Value> *next_node = node->next; size_type new_index = hash_func_(node->data.first) % new_bucket_count; node->next = new_buckets[new_index]; // æ’å…¥åˆ°æ–°æ¡¶çš„å¤´éƒ¨ å¤´æ’æ³• new_buckets[new_index] = node; node = next_node; &#125; buckets_[i] = nullptr; &#125; buckets_ = std::move(new_buckets); bucket_count_ = new_bucket_count; &#125; &#125;; #endif å•ä¾‹æ¨¡å¼ Singletonå•ä¾‹æ¨¡å¼æ˜¯ä¸€ç§åˆ›å»ºå‹è®¾è®¡æ¨¡å¼ï¼Œç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›ä¸€ä¸ªå…¨å±€è®¿é—®ç‚¹ã€‚è¯¥æ¨¡å¼åœ¨éœ€è¦æ§åˆ¶èµ„æºè®¿é—®ï¼ˆå¦‚æ•°æ®åº“è¿æ¥ã€æ—¥å¿—å¯¹è±¡ã€é…ç½®ç®¡ç†å™¨ç­‰ï¼‰çš„åœºæ™¯ä¸­å°¤ä¸ºå¸¸ç”¨ã€‚åœ¨ C++ ä¸­å®ç°çº¿ç¨‹å®‰å…¨çš„å•ä¾‹éœ€è¦è€ƒè™‘æ„é€ æ—¶æœºã€å¤šçº¿ç¨‹ç«äº‰ä»¥åŠèµ„æºé‡Šæ”¾ç­‰é—®é¢˜ï¼Œä¸åŒçš„å®ç°æ–¹å¼å„æœ‰ç‰¹ç‚¹ã€‚ ä»¥ä¸‹ä»£ç å±•ç¤ºäº†ä¸‰ç§å…¸å‹çš„å•ä¾‹æ¨¡å¼å®ç°ï¼šåŸºäºåŒé‡æ£€æŸ¥é”å®šçš„æ‡’æ±‰å¼ã€é¥¿æ±‰å¼é™æ€åˆå§‹åŒ–ï¼Œä»¥åŠä½¿ç”¨ std::call_once çš„çº¿ç¨‹å®‰å…¨æ‡’æ±‰å¼ã€‚ä»£ç ä¸­åŒ…å«äº†è¯¦ç»†çš„æ³¨é‡Šï¼Œå¯ä¾›å‚è€ƒã€‚ ä¸‰ç§å®ç°æ–¹å¼ #ifndef MYSINGLETON_H #define MYSINGLETON_H #include &lt;iostream> #include &lt;mutex> #include &lt;memory> /** * @file Mysingleton.hpp * @brief æä¾›å‡ ç§å•ä¾‹æ¨¡å¼çš„ç¤ºä¾‹å®ç°ï¼ˆæ‡’æ±‰ã€é¥¿æ±‰ã€ä»¥åŠåŸºäº call_once çš„å®‰å…¨æ‡’æ±‰ï¼‰ã€‚ * * è¯¥å¤´æ–‡ä»¶æ¼”ç¤ºäº†ä¸‰ç§ä¸åŒçš„å•ä¾‹å®ç°æ–¹å¼ï¼Œå¹¶åœ¨æ³¨é‡Šä¸­è¯´æ˜äº†çº¿ç¨‹å®‰å…¨æ€§å’Œé”€æ¯è¯­ä¹‰ï¼š * - MysingletonLazy: ä½¿ç”¨åŒé‡æ£€æŸ¥é”å®š (DCL) + std::mutex ä¿æŠ¤çš„æ‡’æ±‰å¼ï¼ˆä½¿ç”¨ shared_ptr ç®¡ç†å®ä¾‹ï¼‰ã€‚ * - MysingletonHun: é¥¿æ±‰å¼ï¼Œå‡è®¾åœ¨ç¿»è¯‘å•å…ƒä¸­åˆå§‹åŒ–é™æ€å®ä¾‹ï¼ˆé¡»åœ¨ .cpp ä¸­å®šä¹‰å¹¶åˆå§‹åŒ– instanceï¼‰ã€‚ * - MysingletonSafe: æ¨èçš„çº¿ç¨‹å®‰å…¨æ‡’æ±‰å¼ï¼Œä½¿ç”¨ std::call_once + std::once_flagï¼Œé…åˆè‡ªå®šä¹‰åˆ é™¤å™¨ã€‚ * * @note å¤´æ–‡ä»¶ä»…åŒ…å«ç±»å®šä¹‰å’Œé™æ€æˆå‘˜å£°æ˜ï¼›è‹¥éœ€è¦å…¨å±€åˆå§‹åŒ–ï¼ˆé¥¿æ±‰å¼ï¼‰ï¼Œè¯·åœ¨å¯¹åº”çš„ .cpp æ–‡ä»¶ä¸­æä¾›é™æ€æˆå‘˜çš„å®šä¹‰ã€‚ */ /** * @class MysingletonLazy * @brief æ‡’æ±‰å¼å•ä¾‹ç¤ºä¾‹ï¼ˆé‡‡ç”¨ shared_ptr + åŒé‡æ£€æŸ¥é”å®šï¼‰ã€‚ * * ç‰¹æ€§ï¼š * - ä½¿ç”¨ std::shared_ptr ç®¡ç†å®ä¾‹æ‰€æœ‰æƒï¼Œæ–¹ä¾¿åœ¨å¤šå¤„æŒæœ‰å¼•ç”¨æ—¶è‡ªåŠ¨é‡Šæ”¾ã€‚ * - ä½¿ç”¨ std::mutex ä¸åŒé‡æ£€æŸ¥é”å®šä»¥å‡å°‘é”å¼€é”€ï¼ˆéœ€æ³¨æ„åœ¨æŸäº›æ—§å¹³å°çš„å†…å­˜æ¨¡å‹é—®é¢˜ï¼‰ã€‚ * - æ„é€ å‡½æ•°ç§æœ‰ï¼Œæ‹·è´ä¸èµ‹å€¼è¢«åˆ é™¤ä»¥é˜²æ­¢å¤åˆ¶ã€‚ * * @thread_safety GetInstance() åœ¨å¤šæ•°ç°ä»£å®ç°ä¸­æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼ˆæ­¤å¤„ä½¿ç”¨ mutex ä¿æŠ¤ï¼‰ã€‚ */ class MysingletonLazy &#123; private: /// å•ä¾‹çš„å…±äº«æŒ‡é’ˆå®ä¾‹ï¼ˆåªåœ¨ç±»å†…å£°æ˜ï¼Œéœ€åœ¨å®ç°æ–‡ä»¶æˆ–é™æ€åˆå§‹åŒ–å¤„å®šä¹‰ï¼‰ã€‚ static std::shared_ptr&lt;MysingletonLazy> instance; /// ä¿æŠ¤å®ä¾‹åˆ›å»ºçš„äº’æ–¥é‡ã€‚ static std::mutex mtx; // äº’æ–¥é”ç”¨äºä¿æŠ¤å®ä¾‹çš„åˆ›å»ºè¿‡ç¨‹ï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨ private: /// ç§æœ‰é»˜è®¤æ„é€ å‡½æ•°ï¼Œé˜²æ­¢å¤–éƒ¨ç›´æ¥åˆ›å»ºã€‚ MysingletonLazy() &#123;&#125;; MysingletonLazy(const MysingletonLazy &amp;) = delete; ///&lt; ç¦æ­¢æ‹·è´ MysingletonLazy &amp;operator=(const MysingletonLazy &amp;) = delete; ///&lt; ç¦æ­¢èµ‹å€¼ public: /** * @brief ææ„å‡½æ•° * * ä»…ç”¨äºç¤ºä¾‹æ‰“å°ï¼Œå®é™…é‡Šæ”¾ç”± shared_ptr ç®¡ç†ã€‚ */ ~MysingletonLazy() &#123; std::cout &lt;&lt; \"MysingletonLazy destructed \" &lt;&lt; std::endl; &#125;; /** * @brief è·å–å•ä¾‹å®ä¾‹çš„å…±äº«æŒ‡é’ˆã€‚ * * ä½¿ç”¨åŒé‡æ£€æŸ¥é”å®šï¼ˆDouble-Checked Lockingï¼‰ä»¥åœ¨å¤šçº¿ç¨‹ä¸‹å®‰å…¨åˆ›å»ºå®ä¾‹å¹¶å‡å°‘é”å¼€é”€ã€‚ * * @return std::shared_ptr&lt;MysingletonLazy> æŒ‡å‘å•ä¾‹å¯¹è±¡çš„å…±äº«æŒ‡é’ˆã€‚ * @note å¦‚æœä½ ä½¿ç”¨ C++11 åŠä»¥ä¸Šï¼Œæ¨èä½¿ç”¨å±€éƒ¨é™æ€å˜é‡æˆ– std::call_once çš„å®ç°ã€‚ */ static std::shared_ptr&lt;MysingletonLazy> GetInstance() &#123; // åŒé‡æ£€æŸ¥é”å®šï¼ˆDouble-Checked Lockingï¼‰æ¨¡å¼ï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨çš„åŒæ—¶é¿å…ä¸å¿…è¦çš„é”å¼€é”€ if (instance == nullptr) &#123; std::lock_guard&lt;std::mutex> lock(mtx); // ä½¿ç”¨é”ä¿æŠ¤å®ä¾‹çš„åˆ›å»ºè¿‡ç¨‹ï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨ if (instance == nullptr) &#123; instance = std::shared_ptr&lt;MysingletonLazy>(new MysingletonLazy()); &#125; &#125; return instance; &#125; &#125;; /** * @class MysingletonHun * @brief é¥¿æ±‰å¼å•ä¾‹ç¤ºä¾‹ï¼ˆå¯åŠ¨æ—¶åˆ›å»ºå®ä¾‹ï¼‰ã€‚ * * ç‰¹æ€§ï¼š * - é€šè¿‡åœ¨ç¨‹åºå¯åŠ¨æ—¶åˆå§‹åŒ–é™æ€å®ä¾‹æ¥ä¿è¯çº¿ç¨‹å®‰å…¨ï¼ˆä¾èµ–äºé™æ€åˆå§‹åŒ–é¡ºåºï¼‰ã€‚ * - éœ€è¦åœ¨æŸä¸ª .cpp æ–‡ä»¶ä¸­å®šä¹‰å¹¶åˆå§‹åŒ–é™æ€æˆå‘˜ instanceï¼Œä¾‹å¦‚ï¼š * @code * std::shared_ptr&lt;MysingletonHun> MysingletonHun::instance = std::shared_ptr&lt;MysingletonHun>(new MysingletonHun()); * @endcode * * @note é¥¿æ±‰å¼åœ¨å•ä¾‹æ„é€ å¼€é”€å°ä¸”å¿…é¡»åœ¨ç¨‹åºå¯åŠ¨æ—¶å°±å‡†å¤‡å¥½çš„åœºæ™¯è¾ƒä¸ºåˆé€‚ï¼›å¦åˆ™ä¼šæµªè´¹èµ„æºã€‚ */ class MysingletonHun &#123; private: /// ç”± shared_ptr ç®¡ç†çš„é™æ€å•ä¾‹å®ä¾‹ï¼ˆéœ€åœ¨ç¿»è¯‘å•å…ƒä¸­å®šä¹‰ï¼‰ã€‚ static std::shared_ptr&lt;MysingletonHun> instance; private: MysingletonHun() &#123;&#125;; ///&lt; ç§æœ‰æ„é€  MysingletonHun(const MysingletonHun &amp;) = delete; ///&lt; ç¦æ­¢æ‹·è´ MysingletonHun &amp;operator=(const MysingletonHun &amp;) = delete; ///&lt; ç¦æ­¢èµ‹å€¼ public: /** * @brief ææ„å‡½æ•°ï¼ˆç¤ºä¾‹æ‰“å°ï¼‰ * * å®é™…é”€æ¯æ—¶æœºç”± shared_ptr çš„å¼•ç”¨è®¡æ•°å†³å®šï¼Œè‹¥åœ¨ç¿»è¯‘å•å…ƒä¸­ä¸ºå…¨å±€ shared_ptr åˆå§‹åŒ–ï¼Œåˆ™ç¨‹åºé€€å‡ºæ—¶ä¼šæ‰§è¡Œé”€æ¯ã€‚ */ ~MysingletonHun() &#123; std::cout &lt;&lt; \"mysingletonHun destructed \" &lt;&lt; std::endl; &#125;; /** * @brief è·å–å•ä¾‹å®ä¾‹ã€‚ * @return std::shared_ptr&lt;MysingletonHun> å•ä¾‹å…±äº«æŒ‡é’ˆï¼ˆè‹¥æœªåˆå§‹åŒ–åˆ™å¯èƒ½ä¸º nullptrï¼‰ã€‚ * @warning ç¡®ä¿åœ¨æŸå¤„ä¸º MysingletonHun::instance æä¾›å®šä¹‰å’Œåˆå§‹åŒ–ï¼Œå¦åˆ™è¿”å› nullptrã€‚ */ static std::shared_ptr&lt;MysingletonHun> GetInstance() &#123; return instance; &#125; &#125;; /** * @brief è‡ªå®šä¹‰åˆ é™¤å™¨ç¤ºä¾‹ç±»ï¼Œç”¨äºæ¼”ç¤ºå¦‚ä½•åœ¨ shared_ptr ä¸­ä½¿ç”¨è‡ªå®šä¹‰åˆ é™¤è¡Œä¸ºã€‚ * * operator() ä¼šåœ¨åˆ é™¤ MysingletonSafe å®ä¾‹æ—¶è¢«è°ƒç”¨ã€‚ */ class safedeleter &#123; public: /** * @brief åˆ é™¤æ“ä½œç¬¦ï¼Œå½“ shared_ptr é‡Šæ”¾æœ€åä¸€ä¸ªå¼•ç”¨æ—¶è°ƒç”¨ã€‚ * @param sf è¦åˆ é™¤çš„ MysingletonSafe æŒ‡é’ˆã€‚ */ void operator()(MysingletonSafe *sf) &#123; std::cout &lt;&lt; \"safe deleter called \" &lt;&lt; std::endl; delete sf; &#125; &#125;; /** * @class MysingletonSafe * @brief æ¨èçš„çº¿ç¨‹å®‰å…¨æ‡’æ±‰å¼å•ä¾‹ï¼ˆä½¿ç”¨ std::call_onceï¼‰ã€‚ * * ç‰¹æ€§ï¼š * - ä½¿ç”¨ std::call_once ä¸ std::once_flag ä¿è¯ä»…åˆå§‹åŒ–ä¸€æ¬¡ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰ã€‚ * - ä½¿ç”¨è‡ªå®šä¹‰åˆ é™¤å™¨ safedeleter ä¸ shared_ptr é…åˆï¼Œå±•ç¤ºå¦‚ä½•æ§åˆ¶é”€æ¯è¡Œä¸ºã€‚ * - æ„é€ ä¸æ‹·è´è¯­ä¹‰è¢«é™åˆ¶ï¼ŒGetInstance è¿”å› shared_ptr ç®¡ç†çš„å®ä¾‹ã€‚ * * @note è¿™æ˜¯ä¸€ä¸ªæ‡’åŠ è½½ï¼ˆé¦–æ¬¡è°ƒç”¨æ—¶åˆ›å»ºï¼‰ä¸”çº¿ç¨‹å®‰å…¨çš„å•ä¾‹å®ç°ã€‚ */ class MysingletonSafe &#123; public: /** * @brief è·å–å•ä¾‹å®ä¾‹ï¼ˆçº¿ç¨‹å®‰å…¨ï¼Œä½¿ç”¨ std::call_once å®ç°ï¼‰ã€‚ * @return std::shared_ptr&lt;MysingletonSafe> æŒ‡å‘å•ä¾‹çš„å…±äº«æŒ‡é’ˆã€‚ */ static std::shared_ptr&lt;MysingletonSafe> GetInstance()&#123; static std::once_flag flag; std::call_once(flag,[]&#123;instance = std::shared_ptr&lt;MysingletonSafe>(new MysingletonSafe(), safedeleter());&#125;); return instance; &#125; private: /// å•ä¾‹å®ä¾‹ï¼ˆç”± GetInstance ä½¿ç”¨ std::call_once åˆå§‹åŒ–ï¼‰ã€‚ static std::shared_ptr&lt;MysingletonSafe> instance; // è¿™é‡ŒåŠ ä¸åŠ classéƒ½è¡Œ friend safedeleter; ///&lt; å…è®¸ safedeleter è®¿é—®ç§æœ‰ææ„å‡½æ•° private: MysingletonSafe(); ///&lt; ç§æœ‰æ„é€ ï¼ˆéœ€è¦åœ¨å®ç°æ–‡ä»¶ä¸­å®šä¹‰ï¼‰ /** * @brief ç§æœ‰ææ„å‡½æ•°ï¼ˆè¢« safedeleter è°ƒç”¨ä»¥æ§åˆ¶é”€æ¯è¿‡ç¨‹ï¼‰ã€‚ * * é€šè¿‡å°†ææ„å‡½æ•°è®¾ä¸ºç§æœ‰å¹¶å°† safedeleter è®¾ä¸ºå‹å…ƒï¼Œå¯ä»¥ç¡®ä¿åªæœ‰è‡ªå®šä¹‰åˆ é™¤å™¨èƒ½åˆ é™¤è¯¥å®ä¾‹ã€‚ */ ~MysingletonSafe() &#123; std::cout &lt;&lt; \"safe delete called by friend class \" &lt;&lt; std::endl; &#125; MysingletonSafe(const MysingletonSafe &amp;other) = delete; ///&lt; ç¦æ­¢æ‹·è´ MysingletonSafe &amp;operator=(const MysingletonSafe &amp;other) = delete; ///&lt; ç¦æ­¢èµ‹å€¼ &#125;; #endif è¿™é‡Œæä¾›æ¨¡æ¿å•ä¾‹ï¼Œå¯å¿«é€Ÿå¤ç”¨ï¼Œæé«˜æ•ˆç‡ã€‚ æ¨¡æ¿å•ä¾‹ç±» #include &lt;memory> #include &lt;mutex> #include &lt;iostream> using namespace std; template &lt;typename T> class Singleton &#123; protected: Singleton() = default; Singleton(const Singleton&lt;T>&amp;) = delete; Singleton&amp; operator=(const Singleton&lt;T>&amp; st) = delete; static std::shared_ptr&lt;T> _instance; public: static std::shared_ptr&lt;T> GetInstance() &#123; static std::once_flag s_flag; std::call_once(s_flag, [&amp;]() &#123; _instance = shared_ptr&lt;T>(new T); &#125;); return _instance; &#125; void PrintAddress() &#123; std::cout &lt;&lt; _instance.get() &lt;&lt; endl; &#125; ~Singleton() &#123; std::cout &lt;&lt; \"this is singleton destruct\" &lt;&lt; std::endl; &#125; &#125;; template &lt;typename T> std::shared_ptr&lt;T> Singleton&lt;T>::_instance = nullptr; ä½¿ç”¨æ—¶ï¼Œpublicç»§æ‰¿å¹¶åœ¨å­ç±»æ„é€ å’Œææ„é‡Œå®ç°è‡ªå·±çš„é€»è¾‘ æ³¨æ„ï¼Œå…³äºé™æ€æˆå‘˜å˜é‡çš„å®šä¹‰ä½ç½®ï¼Œéœ€è¦æ ¹æ®ç±»çš„ç±»å‹æ¥åŒºåˆ†ï¼šå¯¹äºéæ¨¡æ¿ç±»ï¼Œé™æ€æˆå‘˜å˜é‡å¿…é¡»åœ¨ä¸€ä¸ªå•ç‹¬çš„cppæ–‡ä»¶ä¸­å®šä¹‰å’Œåˆå§‹åŒ–ï¼Œè¿™æ˜¯ä¸ºäº†é¿å…å¤šé‡å®šä¹‰é“¾æ¥é”™è¯¯ï¼Œéµå¾ªå•ä¸€å®šä¹‰è§„åˆ™ï¼› è€Œå¯¹äºæ¨¡æ¿ç±»ï¼Œé™æ€æˆå‘˜å˜é‡åˆ™åº”è¯¥åœ¨å¤´æ–‡ä»¶ä¸­å®šä¹‰ï¼Œå› ä¸ºæ¨¡æ¿éœ€è¦åœ¨ä½¿ç”¨æ—¶å®ä¾‹åŒ–ï¼Œç¼–è¯‘å™¨å¿…é¡»çœ‹åˆ°å®Œæ•´çš„å®šä¹‰æ‰èƒ½ä¸ºä¸åŒçš„æ¨¡æ¿å‚æ•°ç”Ÿæˆç›¸åº”çš„ä»£ç ï¼Œå¦‚æœæ”¾åœ¨cppæ–‡ä»¶ä¸­ï¼Œå…¶ä»–åŒ…å«å¤´æ–‡ä»¶çš„ç¼–è¯‘å•å…ƒå°†æ— æ³•æ‰¾åˆ°è¯¥é™æ€æˆå‘˜çš„å®šä¹‰è€Œå¯¼è‡´é“¾æ¥é”™è¯¯ã€‚è¿™ç§åŒºåˆ«æ˜¯C++æ¨¡æ¿ç¼–ç¨‹ä¸éæ¨¡æ¿ç¼–ç¨‹çš„é‡è¦ä¸åŒä¹‹å¤„ã€‚ ä¸è¿‡ï¼ŒC++17å¼•å…¥äº†inlineå˜é‡ï¼Œå¯ä»¥è®©éæ¨¡æ¿ç±»çš„é™æ€æˆå‘˜ä¹Ÿåœ¨å¤´æ–‡ä»¶ä¸­å®šä¹‰","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://miustannis.github.io/tags/C/"}]},{"title":"KMPç®—æ³• Study Log","slug":"250810","date":"2025-08-10T03:38:44.000Z","updated":"2025-08-18T14:29:23.141Z","comments":true,"path":"2025/08/10/250810/","link":"","permalink":"https://miustannis.github.io/2025/08/10/250810/","excerpt":"","text":"ä»€ä¹ˆæ˜¯å­—ç¬¦ä¸²åŒ¹é… æš´åŠ›è§£æ³• KMPç®—æ³• å…·ä½“å®ç° è¡¥å……ï¼š &nbsp; KMPï¼ˆKnuth-Morris-Prattï¼‰ç®—æ³•æ˜¯ä¸€ç§é«˜æ•ˆçš„å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•ï¼Œç”¨äºåœ¨ä¸€ä¸ªä¸»ä¸²ä¸­æŸ¥æ‰¾ä¸€ä¸ªæ¨¡å¼ä¸²çš„ä½ç½®ã€‚å®ƒé€šè¿‡é¢„å¤„ç†æ¨¡å¼ä¸²ï¼Œé¿å…äº†åœ¨åŒ¹é…å¤±è´¥æ—¶é‡å¤æ¯”è¾ƒå·²ç»åŒ¹é…çš„éƒ¨åˆ†ï¼Œä»è€Œæé«˜äº†åŒ¹é…æ•ˆç‡ã€‚ è¯¥ç®—æ³•åœ¨1977å¹´è¢«æå‡ºï¼Œå–ä¸‰ä½è´¡çŒ®è€…çš„å§“åé¦–å­—æ¯ç»„æˆç®—æ³•åç§°ã€‚ ä»€ä¹ˆæ˜¯å­—ç¬¦ä¸²åŒ¹é…å­—ç¬¦ä¸²åŒ¹é…é—®é¢˜æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­çš„ä¸€ä¸ªç»å…¸é—®é¢˜ï¼Œå…¶æ ¸å¿ƒç›®æ ‡æ˜¯åœ¨ä¸€ä¸ªè¾ƒé•¿çš„æ–‡æœ¬ä¸²ï¼ˆTextï¼‰ä¸­æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨ä¸€ä¸ªæˆ–å¤šä¸ªä¸ç»™å®šæ¨¡å¼ä¸²ï¼ˆPatternï¼‰å®Œå…¨ç›¸åŒçš„å­ä¸²ã€‚ ä¾‹å¦‚ï¼š æ–‡æœ¬ä¸²ï¼ˆTï¼‰ï¼š&quot;ABABDABACDABABCABAB&quot; æ¨¡å¼ä¸²ï¼ˆPï¼‰ï¼š&quot;ABABCABAB&quot; é‚£ä¹ˆæ¨¡å¼ä¸²å¯ä»¥åœ¨æ–‡æœ¬ä¸²çš„ç´¢å¼•11å¤„åŒ¹é… &nbsp; æš´åŠ›è§£æ³•çŸ¥é“æ§åˆ¶è¯­å¥ç”¨æ³•çš„äººéƒ½çŸ¥é“ï¼Œè¿™ä¸ªé—®é¢˜å¯ä»¥å¥—ä¸¤å±‚å¾ªç¯æ¥è§£å†³ï¼Œä»æ–‡æœ¬ä¸²çš„ç¬¬1ä¸ªå­—ç¬¦å¼€å§‹ï¼Œä¸æ¨¡å¼ä¸²é€å­—ç¬¦æ¯”å¯¹ï¼Œå¦‚æœå‘ç°ä¸åŒ¹é…ï¼Œåˆ™ä»æ–‡æœ¬ä¸²çš„ç¬¬2ä¸ªå­—ç¬¦å¼€å§‹é‡æ–°æ¯”å¯¹ï¼Œä»¥æ­¤ç±»æ¨ï¼Œè¯¥è§£æ³•æ—¶é—´å¤æ‚åº¦ä¸º$O(m*n)$ï¼Œæ•ˆç‡è¾ƒä½ã€‚ &nbsp; KMPç®—æ³•KMPç®—æ³•é€šè¿‡é¢„å¤„ç†æ¨¡å¼ä¸²ï¼Œåˆ©ç”¨å·²ç»åŒ¹é…çš„ä¿¡æ¯ï¼Œå‡å°‘é‡å¤æ¯”è¾ƒï¼Œå°†æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–è‡³$O(m+n)$ å…¶æ ¸å¿ƒæ€æƒ³æœ‰ä¸¤ç‚¹ï¼š æ„é€ æ¨¡å¼ä¸²çš„éƒ¨åˆ†åŒ¹é…è¡¨ï¼Œä¹Ÿå«åšå‰ç¼€è¡¨ï¼Œè¿™ä¸ªè¡¨è®°å½•äº†æ¨¡å¼ä¸²çš„æœ€é•¿å…¬å…±å‰åç¼€çš„é•¿åº¦ åˆ©ç”¨å¤±è´¥ä¿¡æ¯ï¼Œå½“å­—ç¬¦ä¸åŒ¹é…æ—¶ï¼Œæ ¹æ®éƒ¨åˆ†åŒ¹é…è¡¨ç§»åŠ¨æ¨¡å¼ä¸²æŒ‡é’ˆçš„ä½ç½®ï¼Œè€Œä¸éœ€è¦å›æº¯æ–‡æœ¬ä¸²çš„ä½ç½® ä¸‹å›¾å¯ä»¥æ¸…æ™°åœ°çœ‹å‡ºå‰ç¼€è¡¨çš„å«ä¹‰ï¼š &nbsp; å…·ä½“å®ç°æ„é€ æ¨¡å¼ä¸²çš„éƒ¨åˆ†åŒ¹é…è¡¨ï¼Œå³å‰ç¼€è¡¨ï¼š void getprefix(const string &amp;s, int *prefix)&#123; int fend = 0; prefix[0] = 0; for (int bend = 1; bend &lt; s.size(); bend++)&#123; while (fend > 0 &amp;&amp; s[fend] != s[bend])&#123; fend = prefix[fend - 1]; &#125; if (s[bend] == s[fend]) fend++; prefix[bend] = fend; &#125; &#125; è¿™å…¶ä¸­æœ‰ä¸€äº›ç±»ä¼¼é€’å½’çš„æ€æƒ³ï¼Œå½“æˆ‘ä»¬æ‰‹åŠ¨å®ç°å‰ç¼€è¡¨æ—¶ï¼Œå½“é‡åˆ°å‰ç¼€æœ€åä¸€ä¸ªå­—ç¬¦ä¸åç¼€å­—ç¬¦ä¸åŒ¹é…çš„æƒ…å†µæ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦å»æ‰¾ä»–å‰ä¸€ä½çš„å‰ç¼€è¡¨çš„å€¼æ‰€æŒ‡å¼•çš„ä½ç½®ï¼Œä»é‚£ä¸ªä½ç½®å†æ¬¡å¼€å§‹å¯¹æ¯”ã€‚ é“ç†å’Œå­—ç¬¦ä¸²åŒ¹é…ä¸­çš„åº”ç”¨æ˜¯ä¸€æ ·çš„ï¼Œå› ä¸ºå‰ä¸€ä½å­˜æ”¾çš„æ˜¯åœ¨å½“å‰å­—ç¬¦ä¹‹å‰çš„å­ä¸²æœ€å¤§ç›¸ç­‰å‰åç¼€çš„é•¿åº¦ï¼Œç´¢å¼•ä¹‹åä»£è¡¨ä½ å¯ä»¥è·³è¿‡å¯¹æ¯”å‡ ä¸ªå‰åç¼€éƒ½æœ‰çš„å­—ç¬¦ï¼Œæé«˜æ•ˆç‡ã€‚ åœ¨å…·ä½“å­—ç¬¦ä¸²åŒ¹é…é—®é¢˜ä¸­ï¼Œè¿ç”¨ä¹Ÿæ˜¯ä¸€ä¸ªé“ç†ï¼š int strStr(string haystack, string needle) &#123; if (needle.size() == 0) return 0; if (needle.size() > haystack.size()) return -1; vector&lt;int> prefix(needle.size()); getprefix(needle, &amp;prefix[0]); int index = 0; for (int i = 0; i &lt; haystack.size() ; i++)&#123; while (index > 0 &amp;&amp; haystack[i] != needle[index]) &#123; index = prefix[index - 1]; &#125; if (haystack[i] == needle[index]) index++; if (index == needle.size()) return (i - index + 1); &#125; return -1; &#125; &nbsp; è¡¥å……ï¼šç”±è¿™ä¸ªç»å…¸é—®é¢˜å¯æ¨å‡ºï¼šä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç”±æŸä¸ªå­ä¸²é‡å¤æ„æˆé—®é¢˜çš„è§£æ³•ã€‚ ç»“è®ºæ˜¯ï¼Œå¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²åœ¨å»æ‰å…¶æœ€é•¿ç›¸ç­‰å‰åç¼€çš„é•¿åº¦åï¼Œå‰©ä½™çš„å­ä¸²é•¿åº¦èƒ½è¢«åŸå§‹é•¿åº¦æ•´é™¤ï¼Œé‚£ä¹ˆåŸå§‹å­—ç¬¦ä¸²å°±èƒ½è¢«è¿™ä¸ªå‰©ä½™çš„å­ä¸²é‡å¤è¡¨ç¤ºã€‚ å……åˆ†æ€§è¯æ˜ï¼Œå³å¦‚æœæŸå­—ç¬¦ä¸²å»æ‰æœ€é•¿ç›¸ç­‰å‰åç¼€åçš„å‰©ä½™å­ä¸²é•¿åº¦èƒ½æ•´é™¤åŸå§‹é•¿åº¦ï¼Œåˆ™åŸå§‹å­—ç¬¦ä¸²å¯ç”±è¯¥å‰©ä½™å­ä¸²é‡å¤è¡¨ç¤ºã€‚ å¿…è¦æ€§è¯æ˜ï¼Œå³å¦‚æœå­—ç¬¦ä¸²èƒ½è¢«æŸä¸ªå­ä¸²é‡å¤è¡¨ç¤ºï¼Œåˆ™å»æ‰å­—ç¬¦ä¸²çš„æœ€é•¿ç›¸ç­‰å‰åç¼€åçš„å‰©ä½™å­ä¸²é•¿åº¦å¿…èƒ½æ•´é™¤åŸå§‹é•¿åº¦ã€‚ å¿…è¦æ€§æ˜¾ç„¶ï¼Œå› æ­¤å……åˆ†å¿…è¦æ€§å‡æ»¡è¶³ï¼Œè¯æ¯•ã€‚","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://miustannis.github.io/tags/Algorithm/"}]},{"title":"ç”¨APP Inventorå¿«é€Ÿå¼€å‘ä¸€æ¬¾BLEå®‰å“åº”ç”¨","slug":"250718","date":"2025-07-18T03:38:44.000Z","updated":"2026-02-20T13:02:29.299Z","comments":true,"path":"2025/07/18/250718/","link":"","permalink":"https://miustannis.github.io/2025/07/18/250718/","excerpt":"","text":"å‡ºäºç§‘ç ”é¡¹ç›®çš„éœ€æ±‚ï¼Œæˆ‘éœ€è¦å¼€å‘ä¸€ä¸ªèƒ½ä¸ªæ€§åŒ–å®šåˆ¶ç•Œé¢ä¸åŠŸèƒ½çš„BLEæ‰‹æœºä¸Šä½æœºè½¯ä»¶ï¼Œåœ¨ç»è¿‡ç®€å•çš„è°ƒç ”åï¼Œä¸»è¦æœ‰ä»¥ä¸‹ä¸¤ç§å¼€å‘è·¯å¾„ï¼š Android Studio MIT APP Inventor å…¶ä¸­ASéœ€è¦JavaåŸºç¡€ï¼Œä¸”å¼€å‘å‘¨æœŸé•¿ï¼›MIT APP Inventorå›¾å½¢åŒ–ç¼–ç¨‹ï¼Œ20minå¯ä¸Šæ‰‹ï¼Œäºæ˜¯æˆ‘é€‰æ‹©åè€…ï¼Œæœ€ç»ˆä¹Ÿèƒ½è¾¾åˆ°æˆ‘æƒ³è¦çš„æ•ˆæœã€‚ é€‰æ‹©å»ºè®®å¦‚ä¸‹ï¼š é€‰ Android Studioï¼šå¦‚æœä½ æƒ³æˆä¸ºä¸“ä¸šå¼€å‘è€…ï¼Œæˆ–å¼€å‘åŠŸèƒ½å¤æ‚ã€å¯å‘å¸ƒçš„å•†ä¸šåº”ç”¨ã€‚ é€‰ MIT App Inventorï¼šå¦‚æœä½ æ˜¯å­¦ç”Ÿï¼Œæˆ–åªæƒ³å¿«é€Ÿåšä¸€ä¸ªç®€å•åº”ç”¨ äºæ˜¯åœ¨Bç«™çœ‹äº†å‡ ä¸ªåŒ…æµ†çš„æ•™å­¦è§†é¢‘åï¼Œæˆ‘å¼€å§‹ä¸Šæ‰‹åˆ¶ä½œï¼Œè¿‡ç¨‹æ„å¤–åœ°é¡ºåˆ© é¦–å…ˆï¼Œä½ éœ€è¦æ˜ç¡®ä½ çš„APPè¦åŒ…å«å“ªäº›æ¨¡å— å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œåœ¨ç™»é™†å®˜ç½‘åï¼Œä½ å¯ä»¥æŠŠä½ éœ€è¦çš„æ¨¡å—åœ¨ä¾§è¾¹æ æ‹–å…¥ä¸»é¡µé¢ ä¾æ¬¡æè¿°æˆ‘çš„æ€è·¯ ä¸Šå›¾ä¸­ç»„ä»¶1æ˜¯BLEè®¾å¤‡æœç´¢ä¸æ–­è”æŒ‰é’® 2æ˜¯BLEè¿æ¥çŠ¶æ€ï¼Œ3æ˜¯æ³¢å½¢å›¾ï¼Œ4æ˜¯å®æ—¶æ•°å€¼ï¼Œ5æ˜¯æ¸…ç©ºæŒ‰é’®ï¼› å½“ç„¶ä¹Ÿæœ‰åç«¯ç»„ä»¶â… ï¼Œæ˜¯BLEæ¨¡å—ï¼Œè¿™ä¸ªåœ¨å®˜ç½‘æ²¡æœ‰ï¼Œéœ€è¦ä¸‹è½½æ‹“å±•åŒ…ï¼Œhttps://iot.appinventor.mit.edu/ è¿™ä¸ªç½‘ç«™é‡Œå¯ä»¥æ‰¾åˆ°ï¼Œç»„ä»¶â…¡ç›¸å½“äºç”»å›¾æ‰€ç”¨åˆ°çš„æ•°æ®åˆ—è¡¨ã€‚ &nbsp; åœ¨å®Œæˆç»„ä»¶é€‰æ‹©ä¸è§†å›¾æ„é€ åï¼Œè¿›å…¥ä¸‹ä¸€æ­¥é€»è¾‘ç¼–ç¨‹ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ï¼Œå’Œä¸€äº›å°‘å„¿ç¼–ç¨‹åŸ¹è®­ç”¨çš„ScratchåŸºæœ¬æ˜¯ä¸€ä¸ªå¥—è·¯ï¼Œç‰¹åˆ«æ³¨æ„BLEè®¾å¤‡çš„gattåè®®uuidéœ€è¦æ ¹æ®äº§å“å‚å•†æä¾›çš„æ•°å€¼ä¿®æ”¹ æœ€ç»ˆæ•ˆæœå¦‚ä¸‹ï¼Œå…¶å®æ•´ä½“è€—æ—¶åº”è¯¥ä¸åˆ°åŠå¤©ï¼Œå‘äº’è”ç½‘å¼€æºç²¾ç¥è‡´æ•¬ã€‚","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://miustannis.github.io/tags/Android/"}]},{"title":"MFCCéŸ³é¢‘ç‰¹å¾æå–æµç¨‹demo","slug":"250710","date":"2025-07-10T03:38:44.000Z","updated":"2025-08-20T04:14:33.829Z","comments":true,"path":"2025/07/10/250710/","link":"","permalink":"https://miustannis.github.io/2025/07/10/250710/","excerpt":"","text":"MFCCçš„æ ¸å¿ƒæ€æƒ³æ˜¯æ¨¡ä»¿äººè€³å¯¹å£°éŸ³çš„éçº¿æ€§æ„ŸçŸ¥ç‰¹æ€§ï¼ˆäººè€³å¯¹ä½é¢‘å£°éŸ³æ¯”é«˜é¢‘å£°éŸ³æ›´æ•æ„Ÿï¼‰ï¼Œä»è€Œæ›´å¥½åœ°è¡¨ç¤ºè¯­éŸ³ç‰¹å¾ã€‚å…¶æµç¨‹å¯ä»¥æ¦‚æ‹¬ä¸ºä»¥ä¸‹æ­¥éª¤ï¼š åˆ†å¸§ ç›®çš„ï¼šè¯­éŸ³ä¿¡å·æ˜¯éå¹³ç¨³ä¿¡å·ï¼Œå…¶ç‰¹æ€§æ˜¯éšæ—¶é—´å˜åŒ–çš„ã€‚ä½†åœ¨ä¸€ä¸ªéå¸¸çŸ­çš„æ—¶é—´æ®µå†…ï¼Œå¯ä»¥è¿‘ä¼¼è®¤ä¸ºæ˜¯å¹³ç¨³çš„ã€‚åˆ†å¸§å°±æ˜¯å°†é•¿ä¿¡å·åˆ‡åˆ†æˆè®¸å¤šçŸ­ç‰‡æ®µæ¥åˆ†æã€‚ æ“ä½œï¼šä½¿ç”¨ä¸€ä¸ªå›ºå®šé•¿åº¦çš„çª—å£ä»¥ä¸€å®šçš„å¸§ç§»æ²¿ç€ä¿¡å·æ»‘åŠ¨å¹¶æˆªå–æ•°æ®ã€‚ åŠ çª— ç›®çš„ï¼šå‡å°‘æ¯ä¸€å¸§ä¿¡å·åœ¨å…¶ä¸¤ç«¯å¤„çš„é¢‘è°±æ³„æ¼ï¼Œä½¿å¸§ä¸¤ç«¯å¹³æ»‘åœ°è¡°å‡åˆ°é›¶ï¼Œä»è€Œé™ä½åç»­å‚…é‡Œå¶å˜æ¢åæ—ç“£çš„å¼ºåº¦ã€‚ æ“ä½œï¼šå°†æ¯ä¸€å¸§ä¿¡å·ä¹˜ä¸Šä¸€ä¸ªçª—å‡½æ•°ã€‚ å‚…é‡Œå¶å˜æ¢å’ŒåŠŸç‡è°±è®¡ç®— ç›®çš„ï¼šå°†ä¿¡å·ä»æ—¶åŸŸè½¬æ¢åˆ°é¢‘åŸŸã€‚ æ“ä½œï¼š å¯¹æ¯ä¸€å¸§åŠ çª—åçš„ä¿¡å·è¿›è¡ŒFFTï¼Œå¾—åˆ°å¤æ•°é¢‘è°±ã€‚ ç„¶åè®¡ç®—å…¶åŠŸç‡è°±ï¼ˆå–æ¨¡çš„å¹³æ–¹ï¼‰ã€‚P = |FFT(frame)|Â² / N ï¼ˆNæ˜¯FFTç‚¹æ•°ï¼‰ æ¢…å°”æ»¤æ³¢å™¨ç»„æ»¤æ³¢ ç›®çš„ï¼šæ¨¡æ‹Ÿäººè€³çš„å¬è§‰ç‰¹æ€§ã€‚äººè€³å¯¹äºä¸åŒé¢‘ç‡çš„æ„ŸçŸ¥èƒ½åŠ›æ˜¯ä¸åŒçš„ï¼Œåœ¨ä½é¢‘åŒºåŸŸåŒºåˆ†åº¦é«˜ï¼Œåœ¨é«˜é¢‘åŒºåŸŸåŒºåˆ†åº¦ä½ã€‚æ¢…å°”åˆ»åº¦æ˜¯ä¸€ç§å°†å®é™…é¢‘ç‡è½¬æ¢ä¸ºæ›´ç¬¦åˆäººè€³æ„ŸçŸ¥çš„é¢‘ç‡åˆ»åº¦ã€‚ æ“ä½œï¼š å®šä¹‰ä¸€ç»„ä¸‰è§’å¸¦é€šæ»¤æ³¢å™¨ï¼ˆæ¢…å°”æ»¤æ³¢å™¨ç»„ï¼‰ï¼Œè¿™äº›æ»¤æ³¢å™¨åœ¨æ¢…å°”åˆ»åº¦ä¸Šæ˜¯ç­‰å®½çš„ï¼Œä½†åœ¨çº¿æ€§é¢‘ç‡åˆ»åº¦ä¸Šæ˜¯ä¸ç­‰å®½çš„ï¼ˆä½é¢‘åŒºåŸŸæ»¤æ³¢å™¨çª„ä¸”å¯†é›†ï¼Œé«˜é¢‘åŒºåŸŸå®½ä¸”ç¨€ç–ï¼‰ã€‚ å°†ä¸Šä¸€æ­¥å¾—åˆ°çš„åŠŸç‡è°±ä¸æ¯ä¸€ä¸ªæ¢…å°”æ»¤æ³¢å™¨è¿›è¡Œç§¯åˆ†ï¼ˆå®é™…ä¸Šæ˜¯ç›¸ä¹˜å¹¶æ±‚å’Œï¼‰ï¼Œå¾—åˆ°æ¯ä¸ªæ»¤æ³¢å™¨è¾“å‡ºçš„èƒ½é‡ã€‚è¿™æ ·å°±å°†é¢‘è°±å‹ç¼©ä¸ºnä¸ªæ›´èƒ½åæ˜ äººè€³å¬è§‰ç‰¹æ€§çš„æ»¤æ³¢å™¨ç»„èƒ½é‡ã€‚ ç¦»æ•£ä½™å¼¦å˜æ¢ ç›®çš„ï¼šå¯¹æ¢…å°”æ»¤æ³¢å™¨ç»„èƒ½é‡å–å¯¹æ•°åï¼Œè¿›è¡Œç¦»æ•£ä½™å¼¦å˜æ¢ (DCT)ã€‚è¿™ä¸€æ­¥ä¹Ÿç§°ä¸ºå€’è°±åˆ†æã€‚ å–å¯¹æ•°ï¼šå› ä¸ºäººè€³å¯¹å£°éŸ³å¼ºåº¦çš„æ„ŸçŸ¥ä¹Ÿæ˜¯å¯¹æ•°çš„ã€‚åŒæ—¶ï¼Œå¯¹æ•°æ“ä½œå¯ä»¥å°†å·ç§¯ä¿¡å·ï¼ˆå£°æºæ¿€åŠ±å’Œå£°é“æ»¤æ³¢ï¼‰è½¬åŒ–ä¸ºå¯åŠ çš„ã€‚ DCTï¼šå¯¹å–å¯¹æ•°åçš„æ»¤æ³¢å™¨ç»„èƒ½é‡è¿›è¡ŒDCTï¼Œç›¸å½“äºå¯¹é¢‘è°±è¿›è¡Œâ€œå‹ç¼©â€ã€‚DCTçš„ç»“æœä¸­ï¼Œä½ç»´ï¼ˆå‰å‡ ä¸ªï¼‰ç³»æ•°ä»£è¡¨äº†åŒ…ç»œä¿¡æ¯ï¼ˆåæ˜ äº†å£°é“å½¢çŠ¶ï¼Œæ˜¯è¯­éŸ³å†…å®¹çš„å…³é”®ï¼‰ï¼Œè€Œé«˜ç»´ç³»æ•°ä»£è¡¨äº†ç»†èŠ‚ä¿¡æ¯ï¼ˆå¦‚æ¿€åŠ±æºï¼‰ã€‚ æœ€ç»ˆçš„è¾“å‡ºé€šå¸¸åªä¿ç•™DCTåçš„å‰12-13ä¸ªç³»æ•°ï¼Œå†åŠ ä¸Šä¸€ä¸ªèƒ½é‡é¡¹ï¼ˆç¬¬0é¡¹æˆ–ç›´æ¥ä»æ—¶åŸŸå¸§ä¸­è®¡ç®—ï¼‰ï¼Œå…±åŒæ„æˆæœ€ç»ˆçš„MFCCç‰¹å¾å‘é‡ã€‚ è¿™ä¸ªæµç¨‹ä¸ºéŸ³é¢‘ä¿¡å·çš„æ¯ä¸€å¸§éƒ½è®¡ç®—å‡ºäº†ä¸€ä¸ªå›ºå®šç»´åº¦çš„MFCCç‰¹å¾å‘é‡ï¼Œè¿™äº›å‘é‡åºåˆ—å°±å¯ä»¥ç”¨äºåç»­çš„è¯­éŸ³è¯†åˆ«ã€è¯´è¯äººè¯†åˆ«ç­‰æœºå™¨å­¦ä¹ ä»»åŠ¡ã€‚ &nbsp; ä¸‹é¢æ˜¯åœ¨ä¸€ä¸ªé¡¹ç›®ä¸­ä½¿ç”¨MFCCæ–¹æ³•è¿›è¡Œç‰¹å¾æå–çš„é¢„å¤„ç†éƒ¨åˆ†ï¼Œè¿™é‡Œç”¨çš„ä¸æ˜¯æ ‡å‡†MFCCï¼Œçœå»äº†æœ€åçš„DCTéƒ¨åˆ†ï¼Œæ›´ç›´æ¥ç®€å•ã€‚è¿™ä¸ªå¤„ç†æµç¨‹æ˜¯åœ¨pythonä»¿çœŸåè¿ç§»çš„ï¼Œpythonä¸­è¿ç”¨äº†librosaåº“ï¼Œä¸è¿‡è¯¥åº“é‡Œé¢æœ‰ä¸€äº›éšå¼å¤„ç†ï¼Œå› æ­¤åœ¨è½¬æ¢æˆCç‰ˆæœ¬ä»£ç æ—¶é‡åˆ°äº†è¾ƒå¤šä¸åŒ¹é…çš„æƒ…å†µï¼Œä¸è¿‡è°ƒè¯•ä¸­ä¹Ÿæ˜¯é€æ­¥æ”¹è¿›äº†ã€‚ åˆ†å¸§å‡½æ•°å¦‚ä¸‹ï¼Œå®é™…ä½¿ç”¨æ—¶è°ƒæ•´ä¼ å‚ä½¿å…¶èƒ½å¤Ÿä¿æŒ60%çš„é‡åˆç‡ï¼Œè®©æ¯ä¸€å¸§å¹³æ»‘è¿‡æ¸¡ï¼Œä¸è¿‡è¿™ä¸ªå‡½æ•°åªè®¡ç®—å¸§æ•°ï¼ŒçœŸæ­£çš„åˆ†å¸§æ“ä½œåœ¨ä¸‹é¢çš„æµå¼å¤„ç†é‡Œé¢å¾ªç¯æ‰§è¡Œã€‚ // åˆ†å¸§å‡½æ•°ï¼Œä½¿ç”¨å±€éƒ¨ç¼“å­˜å¤„ç†æ¯ä¸€å¸§æ•°æ® int frame_signal(const int16_t* y, int y_len, int frame_length, int hop_length, int* n_frames) &#123; *n_frames = 1 + (y_len - frame_length) / hop_length; return 0; // å‡è®¾ä¸ä¼šå‡ºé”™ &#125; //n_frames ç»è¿‡å¤„ç†åä¸ºå®é™…å¸§æ•° //å®é™…è¿è¡Œæ—¶ï¼Œhoplengthå’Œframlengthå®šä¹‰å¦‚ä¸‹ // #define WIN_LENGTH 400 çª—é•¿400 // #define HOP_LENGTH 160 å¸§ç§»160 &nbsp; æ‰‹åŠ¨FFTå®ç°ï¼Œç»å…¸çš„Cooley-Tukeyè¿­ä»£FFTç®—æ³•ï¼Œé‡‡ç”¨äº†ä½åè½¬ç½®æ¢å’Œè¶å½¢è¿ç®—ï¼š // Complexç»“æ„ä½“å®šä¹‰ typedef struct &#123; float real; float imag; &#125; Complex; void fft(Complex* x) &#123; // é¢„å…ˆè®¡ç®—æ—‹è½¬å› å­ static Complex W[N_FFT/2]; static int initialized = 0; if (!initialized) &#123; for (int k = 0; k &lt; N_FFT/2; k++) &#123; float angle = -2 * PI * k / N_FFT; W[k].real = cosf(angle); W[k].imag = sinf(angle); &#125; initialized = 1; &#125; // ä½åè½¬ç½®æ¢ int j = 0; for (int i = 0; i &lt; N_FFT - 1; i++) &#123; if (i &lt; j) &#123; Complex temp = x[i]; x[i] = x[j]; x[j] = temp; &#125; int k = N_FFT >> 1; while (k &lt;= j) &#123; j -= k; k >>= 1; &#125; j += k; &#125; // è¿­ä»£FFT for (int stride = 2; stride &lt;= N_FFT; stride &lt;&lt;= 1) &#123; int half_stride = stride >> 1; int W_step = N_FFT / stride; for (int k = 0; k &lt; N_FFT; k += stride) &#123; for (int m = 0; m &lt; half_stride; m++) &#123; int idx_e = k + m; int idx_o = idx_e + half_stride; int W_idx = m * W_step; Complex t = &#123; W[W_idx].real * x[idx_o].real - W[W_idx].imag * x[idx_o].imag, W[W_idx].real * x[idx_o].imag + W[W_idx].imag * x[idx_o].real &#125;; x[idx_o].real = x[idx_e].real - t.real; x[idx_o].imag = x[idx_e].imag - t.imag; x[idx_e].real += t.real; x[idx_e].imag += t.imag; &#125; &#125; &#125; &#125; &nbsp; MelåŠŸç‡è°±è®¡ç®—ï¼Œå‡½æ•°ä¸­çš„æ±‰æ˜çª—ä¸Melæ»¤æ³¢å™¨ç»„éƒ½æ˜¯äº‹å…ˆç”Ÿæˆçš„ã€‚ // è®¡ç®—MelåŠŸç‡è°± void manual_melspectrogram(const int16_t* y, int y_len, int sr, float* mel_spec, int* n_mels_out, int* n_frames_out) &#123; int n_frames; // è®¡ç®—æœ€å¤§ç»å¯¹å€¼ï¼ˆç”¨äºå½’ä¸€åŒ–ï¼‰ float max_val = 0.0f; for (int i = 0; i &lt; y_len; i++) &#123; float abs_val = fabsf((float)y[i]); if (abs_val > max_val) &#123; max_val = abs_val; &#125; &#125; // åˆ†é…å¹¶å½’ä¸€åŒ–ä¸º float ç¼“å†²åŒº static float y_norm[8000]; // å‡è®¾æœ€å¤§é•¿åº¦8000 if (y_len > 8000) &#123; *n_frames_out = 0; return; // é˜²æ­¢è¶Šç•Œ &#125; if (max_val > 0.0f) &#123; for (int i = 0; i &lt; y_len; i++) &#123; y_norm[i] = (float)y[i] / max_val; &#125; &#125; else &#123; for (int i = 0; i &lt; y_len; i++) &#123; y_norm[i] = 0.0f; &#125; &#125; // è®¡ç®—å¸§æ•° frame_signal(y, y_len, WIN_LENGTH, HOP_LENGTH, &amp;n_frames); // æ³¨æ„è¿™é‡Œä½¿ç”¨åŸ yï¼Œå› ä¸ºåªç”¨äº n_frames è®¡ç®— *n_mels_out = N_MELS; *n_frames_out = n_frames; // å»ºç«‹FFTç¼“å†²åŒº static Complex fft_input[N_FFT]; static float power_spectrum[MEL_BINS]; for (int t = 0; t &lt; n_frames; t++) &#123; // åŠ çª—å¤„ç†ï¼ˆæ”¹ä¸ºä½¿ç”¨ y_normï¼‰ for (int n = 0; n &lt; WIN_LENGTH; n++) &#123; fft_input[n].real = y_norm[t * HOP_LENGTH + n] * HAMMING_WINDOW[n]; fft_input[n].imag = 0.0f; &#125; // æ¸…é›¶å‰©ä½™éƒ¨åˆ† for (int n = WIN_LENGTH; n &lt; N_FFT; n++) &#123; fft_input[n].real = 0.0f; fft_input[n].imag = 0.0f; &#125; // FFTè®¡ç®— fft(fft_input); // è®¡ç®—åŠŸç‡è°± (ç›´æ¥å­˜å‚¨åˆ°power_spectrum) for (int k = 0; k &lt; MEL_BINS; k++) &#123; float re = fft_input[k].real / N_FFT; float im = fft_input[k].imag / N_FFT; power_spectrum[k] = re * re + im * im; &#125; // æ¢…å°”æ»¤æ³¢ (ç›´æ¥è®¡ç®—åˆ°è¾“å‡ºmel_spec) for (int m = 0; m &lt; N_MELS; m++) &#123; float mel_energy = 0.0f; for (int k = 0; k &lt; MEL_BINS; k++) &#123; mel_energy += power_spectrum[k] * mel_filter[m][k]; &#125; mel_spec[m * n_frames + t] = mel_energy; &#125; &#125; &#125; &nbsp; æœ€ç»ˆå¤„ç†å‡½æ•°ï¼Œè¿™é‡Œæ˜¯å°†ä¸Šé¢æµç¨‹è¾“å‡ºçš„å€¼æ¯å¸§å–å‡å€¼åæ”¾å…¥åç»­ç¥ç»ç½‘ç»œçš„inputã€‚ #include \"algo.h\" #include \"MFCC.h\" #include &lt;stdint.h> #define FRAME_LENGTH 8000 #define N_MELS 40 // é™æ€ç¼“å†²åŒºï¼Œç”¨äºå­˜å‚¨å¸§ã€æ¢…å°”é¢‘è°±å’Œå¯¹æ•°æ¢…å°”ç‰¹å¾ //static float frame_global[FRAME_LENGTH]; float mel_spec_global[N_MELS * MAX_FRAMES]; //static float mean_log_mel_global[N_MELS]; int speaker_recognition_run(int16_t* pcm_data, int len) &#123; // ç¡®ä¿åªæœ‰ä¸€å¸§æ•°æ® if (len != FRAME_LENGTH) &#123; printf(\"lengtherror: need %d ï¼Œcurrent %d\\n\", FRAME_LENGTH, len); return -1; // å¦‚æœæ•°æ®é•¿åº¦ä¸åŒ¹é…ï¼Œè¿”å›é”™è¯¯ &#125; // è®¡ç®—æ¢…å°”é¢‘è°± int sr = 8000; int n_mels, n_frames; // ç›´æ¥åœ¨å…¨å±€ç¼“å†²åŒºä¸Šæ“ä½œï¼Œé¿å…åˆ†é…æ–°å†…å­˜ manual_melspectrogram(pcm_data, len, sr, mel_spec_global, &amp;n_mels, &amp;n_frames); // è®¡ç®—å¯¹æ•°æ¢…å°”ç‰¹å¾ float* log_mel_features = compute_log_mel_mean(mel_spec_global, n_mels, n_frames); if (!log_mel_features) &#123; // å¤„ç†é”™è¯¯ printf(\"log error\\n\"); return 1; &#125; // Prepare input (1 sample, 40 features) float input[BATCH_SIZE * SEQ_LENGTH * INPUT_DIM]; for (int i = 0; i &lt; INPUT_DIM; i++) &#123; input[i] = log_mel_features[i]; &#125; free(log_mel_features); // Output array for the classification results float output[BATCH_SIZE * NUM_CLASSES]; // Forward pass through the model forward(input, output, BATCH_SIZE, SEQ_LENGTH); // FindMax float max = output[0]; int out = 0; for (int j = 1; j &lt; NUM_CLASSES; j++) &#123; if (max &lt; output[j]) &#123; max = output[j]; // æ›´æ–°æœ€å¤§å€¼ out = j; // æ›´æ–°è¾“å‡ºçš„ç´¢å¼• &#125; &#125; return out; &#125; å…¶ä¸­compute_log_mel_meanå‡½æ•°å¦‚ä¸‹å®šä¹‰ï¼š // è®¡ç®—å¯¹æ•°æ¢…å°”ç‰¹å¾å¹¶å–å‡å€¼ float* compute_log_mel_mean(float* mel_spec, int n_mels, int n_frames) &#123; if (n_mels &lt; 40) &#123; fprintf(stderr, \"The audio is too short to extract Mel features.\\n\"); return NULL; &#125; float* mean_log_mel = (float*)malloc(40 * sizeof(float)); // ä¿ç•™40ä¸ªæ¢…å°”é¢‘ç‡å¸¦ // è®¡ç®—æ¯ä¸ªæ¢…å°”é¢‘ç‡å¸¦çš„å¯¹æ•°å‡å€¼ for (int i = 0; i &lt; n_mels; ++i) &#123; float sum = 0.0f; for (int j = 0; j &lt; n_frames; ++j) &#123; float value = mel_spec[i * n_frames + j]; // æŒ‰åˆ—ä¼˜å…ˆæ’åˆ— value = log10f(value + 1e-6); // åŠ ä¸Šä¸€ä¸ªå°å¸¸æ•°ä»¥é¿å…å¯¹æ•°çš„é›¶å€¼ sum += value; &#125; mean_log_mel[i] = sum / n_frames * SCALE_FACTOR; // æŒ‰å¸§æ•°å–å‡å€¼å¹¶è¿›è¡Œç¼©æ”¾ &#125; return mean_log_mel; &#125; å…¶ä¸­SCALE_FACTOR 10.0 æ˜¯æ¯”ä¾‹å› å­ï¼Œç”¨äºè¡¥å¿ä¸ Python è¾“å‡ºçš„å·®å¼‚ã€‚ å½“æ—¶ä»¿çœŸæ•ˆæœè¿˜å¯ä»¥ï¼Œå°±æ²¡æœ‰å†è€ƒè™‘æ·»åŠ DCTè½¬æ¢ä¸ºæ ‡å‡†MFCCï¼Œä¸»æ‰“èƒ½è·‘å°±è¡Œã€‚","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://miustannis.github.io/tags/Algorithm/"}]},{"title":"LeetCodeè®°å½•","slug":"250621","date":"2025-06-21T13:19:05.000Z","updated":"2025-11-12T02:31:08.527Z","comments":true,"path":"2025/06/21/250621/","link":"","permalink":"https://miustannis.github.io/2025/06/21/250621/","excerpt":"","text":"1. æ•°å­¦ 2. æ•°ç»„ 3. é“¾è¡¨ 4. å“ˆå¸Œæ•£åˆ— 5. æ ˆä¸é˜Ÿåˆ— 6. ç±»ä¸OOPåº”ç”¨ 7. äºŒå‰æ ‘ 8. å›æº¯ 9. è´ªå¿ƒ 10. åŠ¨æ€è§„åˆ’ 11. å•è°ƒæ ˆ 12. å›¾è®º 12.1 ç†è®ºåŸºç¡€ 12.2 æ·±åº¦ä¼˜å…ˆæœç´¢ç†è®ºåŸºç¡€ 12.3 å¹¿åº¦ä¼˜å…ˆæœç´¢ç†è®ºåŸºç¡€ 12.4 å¹¶æŸ¥é›†ç†è®ºåŸºç¡€ 12.5 æ¡ˆä¾‹ 1. æ•°å­¦1.1 åŸºç¡€æœ‰ä¸€å¤©, å°æ˜æ”¶åˆ°ä¸€å¼ å¥‡æ€ªçš„ä¿¡, ä¿¡ä¸Šè¦å°æ˜è®¡ç®—å‡ºç»™å®šæ•°å„ä¸ªä½ä¸Šæ•°å­—ä¸ºå¶æ•°çš„å’Œã€‚ä¾‹å¦‚ï¼š5548ï¼Œç»“æœä¸º12ï¼Œç­‰äº 4 + 8 ã€‚å°æ˜å¾ˆè‹¦æ¼ï¼Œæƒ³è¯·ä½ å¸®å¿™è§£å†³è¿™ä¸ªé—®é¢˜ #include &lt;iostream> using namespace std; int main()&#123; int n, sum = 0; //input while(cin >> n)&#123; // calculation while (n != 0)&#123; int res = 0; res = n % 10; if ((res % 2) == 0) sum += res; n = (n - res) / 10; &#125; cout &lt;&lt; sum &lt;&lt; endl; cout &lt;&lt; endl; sum = 0; &#125; return 0; &#125; 1.2 è®¡æ•°è´¨æ•°ç»™å®šæ•´æ•° n ï¼Œè¿”å› æ‰€æœ‰å°äºéè´Ÿæ•´æ•° n çš„è´¨æ•°çš„æ•°é‡ ã€‚ æšä¸¾æ³• è€ƒè™‘è´¨æ•°çš„å®šä¹‰ï¼šåœ¨å¤§äº 1 çš„è‡ªç„¶æ•°ä¸­ï¼Œé™¤äº† 1 å’Œå®ƒæœ¬èº«ä»¥å¤–ä¸å†æœ‰å…¶ä»–å› æ•°çš„è‡ªç„¶æ•°ã€‚å› æ­¤å¯¹äºæ¯ä¸ªæ•° xï¼Œæˆ‘ä»¬å¯ä»¥ä»å°åˆ°å¤§æšä¸¾ [2,xâˆ’1] ä¸­çš„æ¯ä¸ªæ•° yï¼Œåˆ¤æ–­ y æ˜¯å¦ä¸º x çš„å› æ•°ã€‚ä½†è¿™æ ·åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºè´¨æ•°çš„æ—¶é—´å¤æ‚åº¦æœ€å·®æƒ…å†µä¸‹ä¼šåˆ° O(n)ï¼Œæ— æ³•é€šè¿‡æ‰€æœ‰æµ‹è¯•æ•°æ®ã€‚ æ ¹æ®æ•°å­¦ç‰¹æ€§æ›´æ”¹æšä¸¾èŒƒå›´ï¼Œå¯ä»¥ä¸€å®šç¨‹åº¦ä¸Šé™ä½æ—¶é—´å¤æ‚åº¦ï¼Œä¸è¿‡ä¾æ—§è¶…æ—¶ class Solution &#123; public: int judge(int x)&#123; for (int i = 2; i * i &lt;= x; i++)&#123; if (x % i == 0) return 0; &#125; return 1; &#125; int countPrimes(int n) &#123; int result = 0; if (n == 0 || n == 1) result = 0; else&#123; for (int i = 2 ; i &lt; n; i++)&#123; result += judge(i); &#125; &#125; return result; &#125; &#125;; åŸƒæ°ç­› leetcodeå®˜æ–¹é¢˜è§£ï¼š æšä¸¾æ²¡æœ‰è€ƒè™‘åˆ°æ•°ä¸æ•°çš„å…³è”æ€§ï¼Œå› æ­¤éš¾ä»¥å†ç»§ç»­ä¼˜åŒ–æ—¶é—´å¤æ‚åº¦ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬ä»‹ç»ä¸€ä¸ªå¸¸è§çš„ç®—æ³•ï¼Œè¯¥ç®—æ³•ç”±å¸Œè…Šæ•°å­¦å®¶å„æ‹‰å¤šå¡ï¼ˆEratosthenesï¼‰æå‡ºï¼Œç§°ä¸ºå„æ‹‰å¤šå¡ç­›æ³•ï¼Œç®€ç§°åŸƒæ°ç­›ã€‚ æˆ‘ä»¬è€ƒè™‘è¿™æ ·ä¸€ä¸ªäº‹å®ï¼šå¦‚æœ x æ˜¯è´¨æ•°ï¼Œé‚£ä¹ˆå¤§äº x çš„ x çš„å€æ•° 2x,3x,â€¦ ä¸€å®šä¸æ˜¯è´¨æ•°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä»è¿™é‡Œå…¥æ‰‹ã€‚ æˆ‘ä»¬è®¾ isPrime[i] è¡¨ç¤ºæ•° i æ˜¯ä¸æ˜¯è´¨æ•°ï¼Œå¦‚æœæ˜¯è´¨æ•°åˆ™ä¸º 1ï¼Œå¦åˆ™ä¸º 0ã€‚ä»å°åˆ°å¤§éå†æ¯ä¸ªæ•°ï¼Œå¦‚æœè¿™ä¸ªæ•°ä¸ºè´¨æ•°ï¼Œåˆ™å°†å…¶æ‰€æœ‰çš„å€æ•°éƒ½æ ‡è®°ä¸ºåˆæ•°ï¼ˆé™¤äº†è¯¥è´¨æ•°æœ¬èº«ï¼‰ï¼Œå³ 0ï¼Œè¿™æ ·åœ¨è¿è¡Œç»“æŸçš„æ—¶å€™æˆ‘ä»¬å³èƒ½çŸ¥é“è´¨æ•°çš„ä¸ªæ•°ã€‚ è¿™ç§æ–¹æ³•çš„æ­£ç¡®æ€§æ˜¯æ¯”è¾ƒæ˜¾ç„¶çš„ï¼šè¿™ç§æ–¹æ³•æ˜¾ç„¶ä¸ä¼šå°†è´¨æ•°æ ‡è®°æˆåˆæ•°ï¼›å¦ä¸€æ–¹é¢ï¼Œå½“ä»å°åˆ°å¤§éå†åˆ°æ•° x æ—¶ï¼Œå€˜è‹¥å®ƒæ˜¯åˆæ•°ï¼Œåˆ™å®ƒä¸€å®šæ˜¯æŸä¸ªå°äº x çš„è´¨æ•° y çš„æ•´æ•°å€ï¼Œæ•…æ ¹æ®æ­¤æ–¹æ³•çš„æ­¥éª¤ï¼Œæˆ‘ä»¬åœ¨éå†åˆ° y æ—¶ï¼Œå°±ä¸€å®šä¼šåœ¨æ­¤æ—¶å°† x æ ‡è®°ä¸º isPrime[x]=0ã€‚å› æ­¤ï¼Œè¿™ç§æ–¹æ³•ä¹Ÿä¸ä¼šå°†åˆæ•°æ ‡è®°ä¸ºè´¨æ•°ã€‚ å½“ç„¶è¿™é‡Œè¿˜å¯ä»¥ç»§ç»­ä¼˜åŒ–ï¼Œå¯¹äºä¸€ä¸ªè´¨æ•° xï¼Œå¦‚æœæŒ‰ä¸Šæ–‡è¯´çš„æˆ‘ä»¬ä» 2x å¼€å§‹æ ‡è®°å…¶å®æ˜¯å†—ä½™çš„ï¼Œåº”è¯¥ç›´æ¥ä» xâ‹…x å¼€å§‹æ ‡è®°ï¼Œå› ä¸º 2x,3x,â€¦ è¿™äº›æ•°ä¸€å®šåœ¨ x ä¹‹å‰å°±è¢«å…¶ä»–æ•°çš„å€æ•°æ ‡è®°è¿‡äº†ï¼Œä¾‹å¦‚ 2 çš„æ‰€æœ‰å€æ•°ï¼Œ3 çš„æ‰€æœ‰å€æ•°ç­‰ã€‚ é“¾æ¥ï¼šhttps://leetcode.cn/problems/count-primes/solutions/507273/ji-shu-zhi-shu-by-leetcode-solution/ class Solution &#123; public: int countPrimes(int n) &#123; vector&lt;int> isPrime(n, 1); int ans = 0; for (int i = 2; i &lt; n; i++) &#123; if (isPrime[i]) &#123; ans += 1; if ((long long)i * i &lt; n) &#123; for (int j = i * i; j &lt; n; j += i) &#123; isPrime[j] = 0; &#125; &#125; &#125; &#125; return ans; &#125; &#125;; &nbsp; 2. æ•°ç»„2.1 åŸºç¡€1ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œæ¨¡æ‹Ÿæ‰“å°ä¸€ä¸ªæ­£æ–¹å½¢çš„æ¡†ã€‚ç¨‹åºåº”è¯¥æ¥å—ç”¨æˆ·è¾“å…¥çš„æ­£æ•´æ•°ä½œä¸ºæ­£æ–¹å½¢çš„è¾¹é•¿ï¼Œå¹¶æ‰“å°ç›¸åº”å¤§å°çš„æ­£æ–¹å½¢æ¡†ã€‚ è¯·æ³¨æ„ï¼Œå†…éƒ¨ä¸ºç©ºç™½ï¼Œå¤–éƒ¨æ˜¯ç”± â€œ*â€ å­—ç¬¦ç»„æˆçš„æ¡†ã€‚ #include &lt;iostream> using namespace std; int main()&#123; //input int n; cin >> n; int num = n; do&#123; if( (num == 1) || (num == n) ) &#123; for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; '*'; &#125; cout &lt;&lt; endl; &#125; else &#123; for (int i = 0; i &lt;= n; i++)&#123; if ((i == 0) || (i == (n-1))) cout &lt;&lt; '*'; else cout &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125; num --; &#125; while (num) ; &#125; 2.2 åŸºç¡€2ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œç¼–å†™ä¸€ä¸ªç¨‹åºå®ç°ä»¥ä¸‹åŠŸèƒ½ï¼š å°†è¾“å…¥çš„æ•´æ•°æ•°ç»„å€’åºè¾“å‡ºï¼Œæ¯ä¸ªæ•°ä¹‹é—´ç”¨ç©ºæ ¼åˆ†éš”ã€‚ ä»æ­£åºæ•°ç»„ä¸­ï¼Œæ¯éš”ä¸€ä¸ªå•ä½ï¼ˆå³ç´¢å¼•ä¸ºå¥‡æ•°çš„å…ƒç´ ï¼‰ï¼Œè¾“å‡ºå…¶å€¼ï¼ŒåŒæ ·ç”¨ç©ºæ ¼åˆ†éš”ã€‚ /* ç†è§£é”™äº†ï¼Œæˆ‘ä»¥ä¸ºæ˜¯æ’åºï¼Œå®é™…ä¸Šæ˜¯æŒ‰è¾“å…¥é¡ºåºé€†åº */ #include &lt;iostream> using namespace std; int main()&#123; int n; cin >> n; if ((n>=1) &amp;&amp; ( n&lt;=1000))&#123; int origin[n]; for (int i = 0; i &lt; n; i++)&#123; cin >> origin[i]; &#125; //reverse int max = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = i + 1 ; j &lt; n; j++)&#123; if (origin[j] > origin[i])&#123; max = origin[j]; origin[j] = origin[i]; origin[i] = max; &#125; &#125; &#125; //output for (int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; origin[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; //reverse int min = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = i + 1 ; j &lt; n; j++)&#123; if (origin[j] &lt; origin[i])&#123; min = origin[j]; origin[j] = origin[i]; origin[i] = min; &#125; &#125; &#125; //step output for (int i = 0; i &lt; n; i++)&#123; if((i % 2) == 0) cout &lt;&lt; origin[i] &lt;&lt; ' '; &#125; &#125; &#125; 2.3 åŸºç¡€3ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œç¼–å†™ä¸€ä¸ªç¨‹åºå®ç°ä»¥ä¸‹åŠŸèƒ½ï¼š å°†è¾“å…¥çš„æ•´æ•°æ•°ç»„å€’åºè¾“å‡ºï¼Œæ¯ä¸ªæ•°ä¹‹é—´ç”¨ç©ºæ ¼åˆ†éš”ã€‚ ä»æ­£åºæ•°ç»„ä¸­ï¼Œæ¯éš”ä¸€ä¸ªå•ä½ï¼ˆå³ç´¢å¼•ä¸ºå¥‡æ•°çš„å…ƒç´ ï¼‰ï¼Œè¾“å‡ºå…¶å€¼ï¼ŒåŒæ ·ç”¨ç©ºæ ¼åˆ†éš”ã€‚ //æˆ‘çš„ç¨‹åº #include &lt;iostream> using namespace std; int main()&#123; int n; cin >> n; if ((n>=1) &amp;&amp; ( n&lt;=1000))&#123; int origin[n]; for (int i = 0; i &lt; n; i++)&#123; cin >> origin[i]; &#125; for (int i = n-1; i >= 0; i--)&#123; cout &lt;&lt; origin[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; n; i++)&#123; if ((i % 2) == 0) cout &lt;&lt; origin[i] &lt;&lt;' ' ; &#125; &#125; &#125; //é¢˜è§£ //vector(è¢«ç§°ä¸ºå®¹å™¨)ï¼Œåšä¸ºC++ æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªå®¹å™¨ç±»ï¼Œè¡¨ç¤ºå¯¹è±¡çš„é›†åˆï¼Œå®ƒå¯ä»¥åŠ¨æ€åœ°å­˜å‚¨ä¸€ç»„å…ƒç´ ï¼Œæ‰€ä»¥å¯ä»¥æ ¹æ®éœ€è¦è½»æ¾åœ°è°ƒæ•´ vector çš„å¤§å°ã€‚ #include &lt;iostream> #include &lt;vector> using namespace std; int solution()&#123; vector&lt;int> origin; int n, num; cin >> n; if ((n>=1) &amp;&amp; ( n&lt;=1000))&#123; for (int i = 0; i &lt; n; i++)&#123; // è¿™é‡Œçš„é•¿åº¦ä¸èƒ½ç”¨origin.size() cin >> num; origin.push_back(num); &#125; for (int i = origin.size()-1; i >= 0; i--)&#123; cout &lt;&lt; origin[i] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; origin.size(); i++)&#123; if ((i % 2) == 0) cout &lt;&lt; origin[i] &lt;&lt;' ' ; &#125; &#125; return 0; &#125; 2.4 åŸºç¡€4å°æ˜å¾ˆå–œæ¬¢ç©ç§¯æœ¨ã€‚ä¸€å¤©ï¼Œä»–æŠŠè®¸å¤šç§¯æœ¨å—ç»„æˆäº†å¥½å¤šé«˜åº¦ä¸åŒçš„å †ï¼Œæ¯ä¸€å †éƒ½æ˜¯ä¸€ä¸ªæ‘ä¸€ä¸ªçš„å½¢å¼ã€‚ç„¶è€Œæ­¤æ—¶ï¼Œä»–åˆæƒ³æŠŠè¿™äº›ç§¯æœ¨å †å˜æˆé«˜åº¦ç›¸åŒçš„ã€‚ä½†æ˜¯ä»–å¾ˆæ‡’ï¼Œä»–æƒ³ç§»åŠ¨æœ€å°‘çš„ç§¯æœ¨å—æ¥å®ç°è¿™ä¸€ç›®æ ‡ï¼Œä½ èƒ½å¸®åŠ©ä»–å—ï¼Ÿ /* ç®—æ³•éå¸¸ç®€å•ï¼Œæ±‚å‡å€¼åç§»æ•° æ³¨æ„è®¡æ•°åçš„æ¸…é›¶ï¼Œéå¸¸é‡è¦ */ #include &lt;iostream> #include &lt;vector> using namespace std; int main()&#123; int n, num, sum = 0, steps = 0; while (cin >> n)&#123; if (n == 0) break; // input &amp; sum vector&lt;int> nums; for (int i = 0; i &lt; n; i++)&#123; cin >> num; nums.push_back(num); sum += nums[i]; &#125; int average = sum / n; sum = 0; steps = 0; //step calculation: for (int i = 0; i &lt; n; i++)&#123; if (nums[i] > average) steps += (-average + nums[i]); &#125; cout &lt;&lt; steps &lt;&lt; endl; cout &lt;&lt; endl; &#125; return 0; &#125; 2.5 äºŒåˆ†æŸ¥æ‰¾ç»™å®šä¸€ä¸ª n ä¸ªå…ƒç´ æœ‰åºçš„ï¼ˆå‡åºï¼‰æ•´å‹æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ target ï¼Œå†™ä¸€ä¸ªå‡½æ•°æœç´¢ nums ä¸­çš„ targetï¼Œå¦‚æœ target å­˜åœ¨è¿”å›ä¸‹æ ‡ï¼Œå¦åˆ™è¿”å› -1ã€‚ ä½ å¿…é¡»ç¼–å†™ä¸€ä¸ªå…·æœ‰ O(log n) æ—¶é—´å¤æ‚åº¦çš„ç®—æ³•ã€‚ class Solution &#123; public: int search(vector&lt;int>&amp; nums, int target) &#123; int left = 0; int right = nums.size() - 1; int middle = left + (right - left) / 2 ; while (left &lt;= right)&#123; if (target > nums[middle])&#123; left = middle+1; middle = left + (right - left) / 2 ; &#125; else if (target &lt; nums[middle])&#123; right = middle-1; middle = left + (right - left) / 2 ; &#125; else return middle; &#125; return -1; &#125; &#125;; 2.6 ç§»é™¤å…ƒç´ åŒæŒ‡é’ˆæ³• ç»™ä½ ä¸€ä¸ªæ•°ç»„ nums å’Œä¸€ä¸ªå€¼ valï¼Œä½ éœ€è¦ åŸåœ° ç§»é™¤æ‰€æœ‰æ•°å€¼ç­‰äº val çš„å…ƒç´ ã€‚å…ƒç´ çš„é¡ºåºå¯èƒ½å‘ç”Ÿæ”¹å˜ã€‚ç„¶åè¿”å› nums ä¸­ä¸ val ä¸åŒçš„å…ƒç´ çš„æ•°é‡ã€‚ å‡è®¾ nums ä¸­ä¸ç­‰äº val çš„å…ƒç´ æ•°é‡ä¸º kï¼Œè¦é€šè¿‡æ­¤é¢˜ï¼Œæ‚¨éœ€è¦æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š æ›´æ”¹ nums æ•°ç»„ï¼Œä½¿ nums çš„å‰ k ä¸ªå…ƒç´ åŒ…å«ä¸ç­‰äº val çš„å…ƒç´ ã€‚nums çš„å…¶ä½™å…ƒç´ å’Œ nums çš„å¤§å°å¹¶ä¸é‡è¦ã€‚ è¿”å› kã€‚ class Solution &#123; public: int removeElement(vector&lt;int>&amp; nums, int val) &#123; int slowindex = 0; for (int fastindex = 0; fastindex &lt; nums.size(); fastindex++) &#123; if (nums[fastindex] != val) &#123; nums[slowindex] = nums[fastindex]; slowindex++; &#125; &#125; return slowindex; &#125; &#125;; 2.7 æœ‰åºæ•°ç»„çš„å¹³æ–¹ç»™ä½ ä¸€ä¸ªæŒ‰ éé€’å‡é¡ºåº æ’åºçš„æ•´æ•°æ•°ç»„ numsï¼Œè¿”å› æ¯ä¸ªæ•°å­—çš„å¹³æ–¹ ç»„æˆçš„æ–°æ•°ç»„ï¼Œè¦æ±‚ä¹ŸæŒ‰ éé€’å‡é¡ºåº æ’åºã€‚ æš´åŠ›ï¼š class Solution &#123; public: vector&lt;int> sortedSquares(vector&lt;int>&amp; nums) &#123; for (int i = 0; i &lt; nums.size(); i++)&#123; nums[i] *= nums[i]; &#125; sort(nums.begin(),nums.end()); return nums; &#125; &#125;; åŒæŒ‡é’ˆï¼š //æ—¶é—´å¤æ‚åº¦ä¸ºO(n) class Solution &#123; public: vector&lt;int> sortedSquares(vector&lt;int>&amp; nums) &#123; int length = nums.size(); int left = 0; int right = length - 1; vector&lt;int> result(nums.size(), 0); int index = length-1; while(left &lt;= right)&#123; if (nums[left] * nums[left] &lt;= nums[right] * nums[right])&#123; result[index] = nums[right] * nums[right]; index --; right -= 1; &#125; else if (nums[left] * nums[left] >= nums[right] * nums[right])&#123; result[index] = nums[left] * nums[left]; index --; left += 1; &#125; &#125; return result; &#125; &#125;; 2.8 é•¿åº¦æœ€å°çš„å­æ•°ç»„ç»™å®šä¸€ä¸ªå«æœ‰ n ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•° target ã€‚ æ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶æ€»å’Œå¤§äºç­‰äº target çš„é•¿åº¦æœ€å°çš„ å­æ•°ç»„ [numsl, numsl+1, ..., numsr-1, numsr] ï¼Œå¹¶è¿”å›å…¶é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› 0 ã€‚ æ»‘åŠ¨çª—å£ï¼š class Solution &#123; public: int minSubArrayLen(int target, vector&lt;int>&amp; nums) &#123; int left = 0; int sum = 0; int length = 0; // åˆå§‹åŒ–ä¸ºæå¤§å€¼ï¼Œç¡®ä¿ç¬¬ä¸€æ¬¡æ¯”è¾ƒæ—¶ length ä¼šè¢«é€‰ä¸­ int result = INT32_MAX; for (int right = 0; right &lt; nums.size(); right++)&#123; sum += nums[right]; while (sum >= target)&#123; length = right - left + 1; result = result &lt; length ? result : length; sum -= nums[left++]; &#125; &#125; return result == INT32_MAX ? 0 : result; &#125; &#125;; 2.9 èºæ—‹æ•°ç»„ç»™ä½ ä¸€ä¸ªæ­£æ•´æ•° n ï¼Œç”Ÿæˆä¸€ä¸ªåŒ…å« 1 åˆ° n2 æ‰€æœ‰å…ƒç´ ï¼Œä¸”å…ƒç´ æŒ‰é¡ºæ—¶é’ˆé¡ºåºèºæ—‹æ’åˆ—çš„ n x n æ­£æ–¹å½¢çŸ©é˜µ matrix ã€‚ class Solution &#123; public: vector&lt;vector&lt;int>> generateMatrix(int n) &#123; int mid = n/2 ; int num = 1; int loop = n/2; int start_x = 0; int end_x = n-start_x - 1; int start_y = 0; int end_y = n-start_y - 1; // vector æ„å»ºäºŒç»´æ•°ç»„ vector&lt;vector&lt;int>> result(n, vector &lt;int>(n, 0)); while (loop -- )&#123; for (int i = start_x, j = start_y; i &lt; end_x; i++)&#123; result[j][i] = num; num ++; &#125; for (int i = start_y, j = end_x; i &lt; end_y; i++)&#123; result[i][j] = num; num ++; &#125; for (int i = end_y, j = end_x; j > start_x; j--)&#123; result[i][j] = num; num ++; &#125; for (int i = end_y, j = start_x; i > start_y; i--)&#123; result[i][j] = num; num ++; &#125; start_x +=1; start_y +=1; end_x -= 1; end_y -=1; &#125; if (n % 2 == 1)&#123; result[mid][mid] = n*n; &#125; return result; &#125; &#125;; 2.10 åŒºé—´å’Œç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ Arrayï¼Œè¯·è®¡ç®—è¯¥æ•°ç»„åœ¨æ¯ä¸ªæŒ‡å®šåŒºé—´å†…å…ƒç´ çš„æ€»å’Œã€‚ è¾“å…¥æè¿° ç¬¬ä¸€è¡Œè¾“å…¥ä¸ºæ•´æ•°æ•°ç»„ Array çš„é•¿åº¦ nï¼Œæ¥ä¸‹æ¥ n è¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæ•°ç»„çš„å…ƒç´ ã€‚éšåçš„è¾“å…¥ä¸ºéœ€è¦è®¡ç®—æ€»å’Œçš„åŒºé—´ï¼Œç›´è‡³æ–‡ä»¶ç»“æŸã€‚ è¾“å‡ºæè¿° è¾“å‡ºæ¯ä¸ªæŒ‡å®šåŒºé—´å†…å…ƒç´ çš„æ€»å’Œã€‚ /* å¡æš´åŠ›ï¼Œä½¿ç”¨å‰ç¼€å’Œï¼Œå³æ•°åˆ—å’Œçš„å·®å€¼ */ #include &lt;iostream> #include &lt;vector> using namespace std; int main()&#123; int n; int num; int start = 0, end = 0; int result = 0; int pre_sum = 0; vector&lt;int> pre(n,0); cin >> n; int i = 0; // calculate å‰ç¼€å’Œ while (n--)&#123; cin >> num; pre_sum += num; pre[i] = pre_sum; i++; &#125; while(cin >> start >> end)&#123; result = pre[end] - pre[start-1]; cout &lt;&lt; result &lt;&lt; endl; &#125; &#125; 2.11 å­—ç¬¦ä¸²åŸºç¡€æ¯é—¨è¯¾çš„æˆç»©åˆ†ä¸ºAã€Bã€Cã€Dã€Fäº”ä¸ªç­‰çº§ï¼Œä¸ºäº†è®¡ç®—å¹³å‡ç»©ç‚¹ï¼Œè§„å®šAã€Bã€Cã€Dã€Fåˆ†åˆ«ä»£è¡¨4åˆ†ã€3åˆ†ã€2åˆ†ã€1åˆ†ã€0åˆ†ã€‚æœ‰å¤šç»„æµ‹è¯•æ ·ä¾‹ã€‚æ¯ç»„è¾“å…¥æ•°æ®å ä¸€è¡Œï¼Œç”±ä¸€ä¸ªæˆ–å¤šä¸ªå¤§å†™å­—æ¯ç»„æˆï¼Œå­—æ¯ä¹‹é—´ç”±ç©ºæ ¼åˆ†éš”ã€‚æ¯ç»„è¾“å‡ºç»“æœå ä¸€è¡Œã€‚å¦‚æœè¾“å…¥çš„å¤§å†™å­—æ¯éƒ½åœ¨é›†åˆï½›A,B,C,D,Fï½ä¸­ï¼Œåˆ™è¾“å‡ºå¯¹åº”çš„å¹³å‡ç»©ç‚¹ï¼Œç»“æœä¿ç•™ä¸¤ä½å°æ•°ã€‚å¦åˆ™ï¼Œè¾“å‡ºâ€œUnknownâ€ã€‚ //1. stringå¤„ç†ï¼Œ C++çš„å­—ç¬¦ä¸²æ“ä½œï¼Œå¤´æ–‡ä»¶stringï¼Œ é•¿åº¦ .sizeï¼Œ è®¿é—®å­—ç¬¦ [] // åˆ¤æ–­æ˜¯å¦ä¸ºç©º .empty()ï¼Œè¾“å…¥è¾“å‡ºå¯ä»¥ç”¨æ ‡å‡†åº“ä¸­çš„iostream // cin >> word è¯»å–åˆ°ç©ºæ ¼å°±ä¼šåœæ­¢ // getline(cin , word) è¯»å–ä¸€è¡Œç›´åˆ°æ¢è¡Œç¬¦æˆ–è€…æ–‡ä»¶ç»“æŸç¬¦åœæ­¢ //2. &lt;iomanip> å¯¹æ ‡å‡†è¾“å‡ºè¿›è¡Œæ ¼å¼åŒ–å¤„ç† æ¯”å¦‚æ­¤é¢˜ä¸­çš„ cout &lt;&lt; fixed &lt;&lt; setprecision(2); è®¾ç½®ç²¾åº¦ä¸º2ä½å°æ•° //æ³¨æ„ç‚¹ï¼š //getline(cin, grades) ä¼šè¯»å–æ•´è¡Œè¾“å…¥ï¼ŒåŒ…æ‹¬ç©ºæ ¼ï¼Œ //æ‰€ä»¥å½“è¾“å…¥åŒ…å«ç©ºæ ¼æ—¶ï¼Œdefault åˆ†æ”¯ä¼šè¢«è§¦å‘ï¼Œå¯¼è‡´è¾“å‡º Unknown é”™è¯¯äº§ç”Ÿ #include &lt;iostream> #include &lt;string> #include &lt;iomanip> using namespace std; int main()&#123; string grades; while (getline(cin,grades))&#123; bool flag = 0; float total = 0; int count = 0; for (int i = 0; i &lt; grades.size(); i++) &#123; if (grades[i] == ' ') continue; switch(grades[i])&#123; case 'A': total += 4.0; count += 1; break; case 'B': total += 3.0; count += 1; break; case 'C': total += 2.0; count += 1; break; case 'D': total += 1.0; count += 1; break; case 'F': total += 0.0; count += 1; break; default: flag = 1; break; &#125; &#125; if (flag == 0)&#123; float final = 0.0; final = total / count; cout &lt;&lt; fixed &lt;&lt; setprecision(2); cout &lt;&lt; final &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; \"Unknown \" &lt;&lt; endl; &#125; &#125; return 0; &#125; 2.12 å¤§å†™ç»„åˆè¾“å‡ºä¸€ä¸ªè¯ç»„ä¸­æ¯ä¸ªå•è¯çš„é¦–å­—æ¯çš„å¤§å†™ç»„åˆã€‚è¾“å…¥çš„ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ•´æ•°nï¼Œè¡¨ç¤ºä¸€å…±æœ‰nç»„æµ‹è¯•æ•°æ®ã€‚ï¼ˆè¾“å…¥åªæœ‰ä¸€ä¸ªnï¼Œæ²¡æœ‰å¤šç»„nçš„è¾“å…¥ï¼‰æ¥ä¸‹æ¥æœ‰nè¡Œï¼Œæ¯ç»„æµ‹è¯•æ•°æ®å ä¸€è¡Œï¼Œæ¯è¡Œæœ‰ä¸€ä¸ªè¯ç»„ï¼Œæ¯ä¸ªè¯ç»„ç”±ä¸€ä¸ªæˆ–å¤šä¸ªå•è¯ç»„æˆï¼›æ¯ç»„çš„å•è¯ä¸ªæ•°ä¸è¶…è¿‡10ä¸ªï¼Œæ¯ä¸ªå•è¯æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªå¤§å†™æˆ–å°å†™å­—æ¯ç»„æˆï¼›å•è¯é•¿åº¦ä¸è¶…è¿‡10ï¼Œç”±ä¸€ä¸ªæˆ–å¤šä¸ªç©ºæ ¼åˆ†éš”è¿™äº›å•è¯ //æ³¨æ„è¿™é‡Œä½¿ç”¨äº† getchar() å‡½æ•°æ¥å¸æ”¶ä¸€ä¸ªå›è½¦ç¬¦ï¼Œå› ä¸ºåœ¨è¾“å…¥ n ä¹‹åé€šå¸¸éœ€è¦è¾“å…¥å›è½¦ç¬¦æ‰ä¼šè¾“å…¥ä¸‹ä¸€è¡Œã€‚ /* cin >> n ä¼šç•™ä¸‹æ¢è¡Œç¬¦ \\n åœ¨ç¼“å†²åŒº å½“è¾“å…¥ n çš„å€¼ï¼ˆæ¯”å¦‚ 2ï¼‰å¹¶æŒ‰å›è½¦åï¼Œç¼“å†²åŒºçš„å†…å®¹æ˜¯ï¼š\"2\\n\"ã€‚ cin >> n åªè¯»å– 2ï¼Œå‰©ä¸‹çš„ \\n ä»ç„¶åœ¨ç¼“å†²åŒºã€‚ getline(cin, line) ä¼šè¯»å–ç¼“å†²åŒºä¸­å‰©ä½™çš„ \\n getline é‡åˆ° \\n æ—¶ä¼šç›´æ¥è¯»å–å¹¶è¿”å›ç©ºå­—ç¬¦ä¸² \"\"ï¼Œå¯¼è‡´ line ä¸ºç©ºï¼Œå› æ­¤ for å¾ªç¯ä¸ä¼šæ‰§è¡Œã€‚ */ #include &lt;iostream> #include &lt;string> using namespace std; char upper(char a)&#123; char upper; if ((a >= 'a') &amp;&amp; (a &lt;= 'z')) cout &lt;&lt; char(a + 'A' - 'a'); else if ((a >= 'A') &amp;&amp; (a &lt;= 'Z')) cout &lt;&lt; char(a); return upper; &#125; int main() &#123; string line; int n; cin >> n; getchar(); while (n--) &#123; getline(cin, line); if (line[0] != ' ') &#123; if ((line[0] >= 'a') &amp;&amp; (line[0] &lt;= 'z')) cout &lt;&lt; char(line[0] + 'A' - 'a'); else if ((line[0] >= 'A') &amp;&amp; (line[0] &lt;= 'Z')) cout &lt;&lt; char(line[0]); &#125; /* if (line[0] != ' ') &#123; upper(line[0]); &#125; */ for (int i = 1; i &lt; line.size(); i++) &#123; if ((line[i] != ' ') &amp;&amp; (line[i - 1] == ' ')) &#123; if ((line[i] >= 'a') &amp;&amp; (line[i] &lt;= 'z')) cout &lt;&lt; char(line[i] + 'A' - 'a'); else if ((line[i] >= 'A') &amp;&amp; (line[i] &lt;= 'Z')) cout &lt;&lt; char(line[i]); &#125; &#125; /* for (int i = 1; i &lt; line.size(); i++) &#123; if ((line[i] != ' ') &amp;&amp; (line[i - 1] == ' ')) &#123; upper(line[i]); &#125; &#125; */ cout &lt;&lt; endl; &#125; return 0; &#125; 2.13 å­—ç¬¦ä¸²å¥‡å¶ä½ç¿»è½¬ç»™å®šä¸€ä¸ªé•¿åº¦ä¸ºå¶æ•°ä½çš„å­—ç¬¦ä¸²ï¼Œè¯·ç¼–ç¨‹å®ç°å­—ç¬¦ä¸²çš„å¥‡å¶ä½äº’æ¢ã€‚è¾“å…¥åŒ…å«å¤šç»„æµ‹è¯•æ•°æ®ã€‚è¾“å…¥çš„ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ•´æ•°nï¼Œè¡¨ç¤ºæœ‰æµ‹è¯•æ•°æ®ã€‚ï¼ˆæ•´ä¸ªè¾“å…¥ä¸­ï¼Œåªæœ‰ä¸€ä¸ªnï¼‰æ¥ä¸‹æ¥æ˜¯nç»„æµ‹è¯•æ•°æ®ï¼Œä¿è¯ä¸²é•¿ä¸ºå¶æ•°ä½(ä¸²é•¿&lt;=50)ã€‚ //é¢˜è§£ä½¿ç”¨äº†è‡ªå®šä¹‰çš„äº¤æ¢å‡½æ•°ï¼Œå…¶ä¸­ç”¨äº†å˜é‡å¼•ç”¨ï¼Œ which is C++çš„ç‰¹æ€§ /* // ä¸è¿”å›(return)ç»“æœï¼Œæ‰€ä»¥è¿”å›ç±»å‹ä¸ºvoidï¼Œ å‡½æ•°åç§°ä¸ºswap // ä¼ å…¥çš„å‚æ•°ä¸ºä¸¤ä¸ªå­—ç¬¦ï¼Œæ‰€ä»¥ç±»å‹ä¸ºchar, å‚æ•°åç§°ä¸ºa å’Œ b void swap(char &amp;a, char &amp;b) &#123; // äº¤æ¢ä¸¤ä¸ªå­—ç¬¦ä¸², aå’Œbçš„å†…å®¹éœ€è¦æ”¹å˜ï¼Œæ‰€ä»¥éœ€è¦ä¼ é€’å¼•ç”¨ // å®šä¹‰ç¬¬ä¸‰ä¸ªå­—ç¬¦ï¼Œå¹¶å°†å­—ç¬¦açš„å†…å®¹èµ‹å€¼ç»™ç¬¬ä¸‰ä¸ªå­—ç¬¦ char tmp = a; // å°†å­—ç¬¦açš„å†…å®¹ä¿®æ”¹ä¸ºå­—ç¬¦bçš„å†…å®¹ a = b; // å°†å­—ç¬¦bçš„å†…å®¹ä¿®æ”¹ä¸ºç¬¬ä¸‰ä¸ªå­—ç¬¦çš„å†…å®¹ï¼Œä¹Ÿå°±æ˜¯å­—ç¬¦açš„å†…å®¹ï¼Œaå’Œbä¹‹é—´å®Œæˆæ›¿æ¢ b = tmp; &#125; */ #include &lt;iostream> #include &lt;string> using namespace std; int main()&#123; string line; int n; cin >> n; getchar(); while(n--)&#123; getline(cin,line); char c; for (int i = 0; i &lt; line.size()-1; i++)&#123; if((i)%2 == 0)&#123; c = line[i]; line[i] = line[i+1]; line[i+1] = c; &#125; &#125; cout &lt;&lt; line &lt;&lt; endl; &#125; return 0; &#125; 2.14 åè½¬å­—ç¬¦ä¸²ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå…¶ä½œç”¨æ˜¯å°†è¾“å…¥çš„å­—ç¬¦ä¸²åè½¬è¿‡æ¥ã€‚è¾“å…¥å­—ç¬¦ä¸²ä»¥å­—ç¬¦æ•°ç»„ s çš„å½¢å¼ç»™å‡ºã€‚ æš´åŠ›ï¼š class Solution &#123; public: void reverseString(vector&lt;char>&amp; s) &#123; int n = s.size(); vector&lt;int> restore(n); for(int i = 0 ; i &lt; n; i++)&#123; restore[i] = s[i] -'a'; &#125; for (int i = n - 1; i >= 0; i-- )&#123; s[n-i-1] = restore[i] + 'a'; &#125; &#125; &#125;; åŒæŒ‡é’ˆï¼š class Solution &#123; public: void reverseString(vector&lt;char>&amp; s) &#123; int n = s.size(); int left = 0; int right = n-1; while (left &lt; right)&#123; swap(s[left], s[right]); left ++; right --; &#125; &#125; &#125;; 2.15 åè½¬å­—ç¬¦ä¸²â…¡ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªæ•´æ•° kï¼Œä»å­—ç¬¦ä¸²å¼€å¤´ç®—èµ·ï¼Œæ¯è®¡æ•°è‡³ 2k ä¸ªå­—ç¬¦ï¼Œå°±åè½¬è¿™ 2k å­—ç¬¦ä¸­çš„å‰ k ä¸ªå­—ç¬¦ã€‚ å¦‚æœå‰©ä½™å­—ç¬¦å°‘äº k ä¸ªï¼Œåˆ™å°†å‰©ä½™å­—ç¬¦å…¨éƒ¨åè½¬ã€‚ å¦‚æœå‰©ä½™å­—ç¬¦å°äº 2k ä½†å¤§äºæˆ–ç­‰äº k ä¸ªï¼Œåˆ™åè½¬å‰ k ä¸ªå­—ç¬¦ï¼Œå…¶ä½™å­—ç¬¦ä¿æŒåŸæ ·ã€‚ class Solution &#123; public: string reverseStr(string s, int k) &#123; int n = s.size(); int roll1 = n / (2*k); int roll2 = n % (2*k); int start = 0; while (roll1 --)&#123; int left = start; int right = start + k -1; while (left &lt; right)&#123; swap(s[left] , s[right]); left ++; right --; &#125; start += 2 * k; &#125; roll1 = n / (2*k); if (roll2 &lt; k)&#123; int start = 2 * k * roll1; int left = start; int right = start + roll2 - 1; while (left &lt; right)&#123; swap(s[left] , s[right]); left ++; right --; &#125; &#125; else if (roll2 >= k &amp;&amp; roll2 &lt; 2 * k)&#123; int start = 2 * k * roll1; int left = start; int right = start + k - 1; while (left &lt; right)&#123; swap(s[left] , s[right]); left ++; right --; &#125; &#125; return s; &#125; &#125;; 2.16 æ›¿æ¢æ•°å­—ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œå®ƒåŒ…å«å°å†™å­—æ¯å’Œæ•°å­—å­—ç¬¦ï¼Œè¯·ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ä¸­çš„å­—æ¯å­—ç¬¦ä¿æŒä¸å˜ï¼Œè€Œå°†æ¯ä¸ªæ•°å­—å­—ç¬¦æ›¿æ¢ä¸ºnumberã€‚ ä¾‹å¦‚ï¼Œå¯¹äºè¾“å…¥å­—ç¬¦ä¸² â€œa1b2c3â€ï¼Œå‡½æ•°åº”è¯¥å°†å…¶è½¬æ¢ä¸º â€œanumberbnumbercnumberâ€ã€‚ #include &lt;iostream> #include &lt;string> using namespace std; int main()&#123; string input; cin >> input; int total = 0; for (auto &amp;s : input)&#123; if (s >= '0' &amp;&amp; s &lt;= '9') total ++; &#125; int space = input.size() + total * 5; char output[space + 1]; int start = input.size() - 1; /* åœ¨ C/C++ ä¸­ï¼Œå­—ç¬¦æ•°ç»„ï¼ˆchar[]ï¼‰ç”¨äºè¡¨ç¤ºå­—ç¬¦ä¸²æ—¶ï¼Œå¿…é¡»ä»¥ '\\0'ï¼ˆç©ºå­—ç¬¦ï¼ŒASCII ç ä¸º 0ï¼‰ç»“å°¾ã€‚ å¦‚æœç¼ºå°‘è¿™ä¸ªç»ˆæ­¢ç¬¦ï¼Œcout æˆ–å…¶ä»–å­—ç¬¦ä¸²å¤„ç†å‡½æ•°ï¼ˆå¦‚ strlenã€strcpyï¼‰å¯èƒ½ä¼šè¯»å–è¶Šç•Œï¼Œ å¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼ˆUndefined Behavior, UBï¼‰ï¼Œå¸¸è§è¡¨ç°åŒ…æ‹¬ï¼š 1. è¾“å‡ºä¹±ç  2. ç¨‹åºå´©æºƒ 3. æ— é™å¾ªç¯ï¼ˆå¦‚æœå†…å­˜ä¸­ç¢°å·§æœ‰éé›¶æ•°æ®ï¼‰ */ output[space] = '\\0'; // Ensure null-termination int end = space - 1; while (start >= 0)&#123; if (input[start] >= '0' &amp;&amp; input[start] &lt;= '9')&#123; output[end] = 'r'; end --; output[end] = 'e'; end --; output[end] = 'b'; end --; output[end] = 'm'; end --; output[end] = 'u'; end --; output[end] = 'n'; end --; &#125; else&#123; output[end] = input[start]; end --; &#125; start --; &#125; cout &lt;&lt; output &lt;&lt; endl; return 0; &#125; 2.17 æ‰¾å‡ºå­—ç¬¦ä¸²ä¸­ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹çš„ä¸‹æ ‡ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸² haystack å’Œ needle ï¼Œè¯·ä½ åœ¨ haystack å­—ç¬¦ä¸²ä¸­æ‰¾å‡º needle å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹çš„ä¸‹æ ‡ï¼ˆä¸‹æ ‡ä» 0 å¼€å§‹ï¼‰ã€‚å¦‚æœ needle ä¸æ˜¯ haystack çš„ä¸€éƒ¨åˆ†ï¼Œåˆ™è¿”å› -1 ã€‚ æš´åŠ›ï¼ˆä¼ªåŒæŒ‡é’ˆï¼‰ï¼š class Solution &#123; public: int strStr(string haystack, string needle) &#123; int n1 = needle.size(); int n2 = haystack.size(); int left1 = 0; int left2 = 0; int right1 = n1 - 1; int right2 = n1 - 1; int flag = 1; while(right2 &lt; n2)&#123; if(haystack[left2] == needle[left1] &amp;&amp; haystack[right2] == needle[right1])&#123; flag = 1; int restore = left2; for (int i = left2, j = left1; i &lt; right2, j &lt; right1; i++, j++)&#123; if(haystack[i] != needle[j]) &#123; flag = 0; break; &#125; &#125; if (flag == 1)&#123; return restore; &#125; &#125; left2++; right2++; &#125; return -1; &#125; &#125;; KMPï¼šå­—ç¬¦ä¸²åŒ¹é…ç®—æ³•ï¼Œå€¼å¾—ç†è§£ class Solution &#123; public: void getprefix(const string &amp;s, int *prefix)&#123; int fend = 0; prefix[0] = 0; for (int bend = 1; bend &lt; s.size(); bend++)&#123; while (fend > 0 &amp;&amp; s[fend] != s[bend])&#123; fend = prefix[fend - 1]; &#125; if (s[bend] == s[fend]) fend++; prefix[bend] = fend; &#125; &#125; int strStr(string haystack, string needle) &#123; if (needle.size() == 0) return 0; if (needle.size() > haystack.size()) return -1; vector&lt;int> prefix(needle.size()); getprefix(needle, &amp;prefix[0]); int index = 0; for (int i = 0; i &lt; haystack.size() ; i++)&#123; while (index > 0 &amp;&amp; haystack[i] != needle[index]) &#123; index = prefix[index - 1]; &#125; if (haystack[i] == needle[index]) index++; if (index == needle.size()) return (i - index + 1); &#125; return -1; &#125; &#125;; 2.18 ç¿»è½¬å­—ç¬¦ä¸²é‡Œçš„å•è¯ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œè¯·ä½ åè½¬å­—ç¬¦ä¸²ä¸­ å•è¯ çš„é¡ºåºã€‚ å•è¯ æ˜¯ç”±éç©ºæ ¼å­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ã€‚s ä¸­ä½¿ç”¨è‡³å°‘ä¸€ä¸ªç©ºæ ¼å°†å­—ç¬¦ä¸²ä¸­çš„ å•è¯ åˆ†éš”å¼€ã€‚ è¿”å› å•è¯ é¡ºåºé¢ å€’ä¸” å•è¯ ä¹‹é—´ç”¨å•ä¸ªç©ºæ ¼è¿æ¥çš„ç»“æœå­—ç¬¦ä¸²ã€‚ æ³¨æ„ï¼šè¾“å…¥å­—ç¬¦ä¸² sä¸­å¯èƒ½ä¼šå­˜åœ¨å‰å¯¼ç©ºæ ¼ã€å°¾éšç©ºæ ¼æˆ–è€…å•è¯é—´çš„å¤šä¸ªç©ºæ ¼ã€‚è¿”å›çš„ç»“æœå­—ç¬¦ä¸²ä¸­ï¼Œå•è¯é—´åº”å½“ä»…ç”¨å•ä¸ªç©ºæ ¼åˆ†éš”ï¼Œä¸”ä¸åŒ…å«ä»»ä½•é¢å¤–çš„ç©ºæ ¼ã€‚ class Solution &#123; public: void removeextra(string &amp;s)&#123; int slow = 0; for (int fast = 0; fast &lt; s.size(); fast ++)&#123; if (s[fast] != ' ')&#123; if (slow > 0) s[slow++] = ' '; while (fast &lt; s.size() &amp;&amp; s[fast] != ' ')&#123; s[slow++] = s[fast++]; &#125; &#125; &#125; s.resize(slow); &#125; void reverse(string &amp;s, int left, int right)&#123; for (int i = left, j = right; i &lt; j; i++, j--) &#123; swap(s[i], s[j]); &#125; &#125; string reverseWords(string s) &#123; removeextra(s); reverse(s, 0, s.size()-1); int start = 0; for (int end = 1; end &lt; s.size(); end++)&#123; if(s[end] == ' ')&#123; reverse(s, start , end-1); start = end + 1; &#125; else if (end == s.size() - 1)&#123; reverse(s, start , end); &#125; &#125; return s; &#125; &#125;; 2.19 å³æ—‹å­—ç¬¦ä¸²å­—ç¬¦ä¸²çš„å³æ—‹è½¬æ“ä½œæ˜¯æŠŠå­—ç¬¦ä¸²å°¾éƒ¨çš„è‹¥å¹²ä¸ªå­—ç¬¦è½¬ç§»åˆ°å­—ç¬¦ä¸²çš„å‰é¢ã€‚ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªæ­£æ•´æ•° kï¼Œè¯·ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ä¸­çš„åé¢ k ä¸ªå­—ç¬¦ç§»åˆ°å­—ç¬¦ä¸²çš„å‰é¢ï¼Œå®ç°å­—ç¬¦ä¸²çš„å³æ—‹è½¬æ“ä½œã€‚ ä¾‹å¦‚ï¼Œå¯¹äºè¾“å…¥å­—ç¬¦ä¸² â€œabcdefgâ€ å’Œæ•´æ•° 2ï¼Œå‡½æ•°åº”è¯¥å°†å…¶è½¬æ¢ä¸º â€œfgabcdeâ€ã€‚ #include &lt;iostream> #include &lt;string> using namespace std; int main() &#123; int n; string s; cin >> n; cin >> s; int left0 = 0; int right0 = s.length() - 1; //å…¨éƒ¨ç¿»è½¬1 while (left0 &lt; right0) &#123; swap(s[left0], s[right0]); left0++; right0--; &#125; //å±€éƒ¨ç¿»è½¬1 left0 = 0; right0 = n - 1; while (left0 &lt; right0) &#123; swap(s[left0], s[right0]); left0++; right0--; &#125; //å±€éƒ¨ç¿»è½¬2 left0 = n; right0 = s.length() - 1; while (left0 &lt; right0) &#123; swap(s[left0], s[right0]); left0++; right0--; &#125; cout &lt;&lt; s; &#125; 2.20 é‡å¤çš„å­å­—ç¬¦ä¸²ç»™å®šä¸€ä¸ªéç©ºçš„å­—ç¬¦ä¸² s ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥é€šè¿‡ç”±å®ƒçš„ä¸€ä¸ªå­ä¸²é‡å¤å¤šæ¬¡æ„æˆã€‚ class Solution &#123; public: bool repeatedSubstringPattern(string s) &#123; vector&lt;int> prefix(s.size()); prefix[0] = 0; int j = 0; for (int i = 1; i &lt; s.size(); i++)&#123; while (j > 0 &amp;&amp; s[i] != s[j])&#123; j = prefix[j- 1]; &#125; if (s[i] == s[j]) j++; prefix[i] = j; &#125; printf(\"%d\\r\\n\", prefix[s.size()-1]); if (s.size() == 2)&#123; if (prefix[s.size()-1] == 1) return true; &#125; if (s.size() > 2)&#123; if (prefix[s.size()-1] != 0 &amp;&amp; s.size() % (s.size()-(prefix[s.size() - 1]) )== 0) return true; &#125; return false; &#125; &#125;; &nbsp; 3. é“¾è¡¨3.1 åŸºç¡€1æ„å»ºä¸€ä¸ªå•å‘é“¾è¡¨ï¼Œé“¾è¡¨ä¸­åŒ…å«ä¸€ç»„æ•´æ•°æ•°æ®ã€‚è¾“å‡ºé“¾è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚ è¦æ±‚ï¼š ä½¿ç”¨è‡ªå®šä¹‰çš„é“¾è¡¨æ•°æ®ç»“æ„ æä¾›ä¸€ä¸ª linkedList ç±»æ¥ç®¡ç†é“¾è¡¨ï¼ŒåŒ…å«æ„å»ºé“¾è¡¨å’Œè¾“å‡ºé“¾è¡¨å…ƒç´ çš„æ–¹æ³• åœ¨ main å‡½æ•°ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªåŒ…å«ä¸€ç»„æ•´æ•°æ•°æ®çš„é“¾è¡¨ï¼Œç„¶åè°ƒç”¨é“¾è¡¨çš„è¾“å‡ºæ–¹æ³•å°†æ‰€æœ‰å…ƒç´ æ‰“å°å‡ºæ¥ // 0. æ„é€ å‡½æ•°ï¼šListNode(int x) : val(x), next(nullptr) &#123;&#125; // è¿™é‡Œçš„ListNode(int x)è¡¨ç¤ºå®šä¹‰ä¸€ä¸ªæ¥æ”¶æ•´æ•°å‚æ•° xçš„åç§°ä¸ºListNodeçš„æ„é€ å‡½æ•°ï¼ˆåç§°å’Œç»“æ„ä½“ç›¸åŒï¼‰ï¼Œ:è¡¨ç¤ºåˆå§‹åŒ–åˆ—è¡¨çš„å¼€å§‹ï¼Œval(x)è¡¨ç¤ºé“¾è¡¨æ•°æ®åŸŸçš„å€¼è¢«åˆå§‹åŒ–ä¸ºä¼ é€’çš„å‚æ•° x ï¼Œnext(nullptr)åˆ™è¡¨ç¤ºnextæŒ‡é’ˆè¢«åˆå§‹åŒ–ä¸ºnullptrï¼Œè¡¨ç¤ºæ²¡æœ‰ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚ /* è¿™é‡Œæœ‰ä¸¤ä¸ªæ–°çš„è¯­æ³•ï¼šnewè¿ç®—ç¬¦å’Œç®­å¤´è¯­æ³•-> 1. newæ˜¯ä¸€ä¸ªè¿ç®—ç¬¦ï¼Œå®ƒçš„ä½œç”¨å°±æ˜¯åœ¨å †å†…å­˜ä¸­åŠ¨æ€åˆ†é…å†…å­˜ç©ºé—´ï¼Œå¹¶è¿”å›åˆ†é…å†…å­˜çš„åœ°å€ï¼Œä½¿ç”¨æ–¹å¼ä¸€èˆ¬ä¸ºï¼š æŒ‡é’ˆå˜é‡ = new æ•°æ®ç±»å‹, æ¯”å¦‚ä¸‹é¢çš„ä»£ç ï¼š int *arr = new int[5]; // åˆ†é…ä¸€ä¸ªåŒ…å«5ä¸ªæ•´æ•°çš„æ•°ç»„çš„å†…å­˜ç©ºé—´ï¼Œå¹¶è¿”å›ä¸€ä¸ªåœ°å€ï¼ŒæŒ‡é’ˆarræŒ‡å‘è¿™ä¸ªåœ°å€ 2. ç®­å¤´è¯­æ³•ï¼ˆ->ï¼‰ï¼šç”¨äºé€šè¿‡æŒ‡é’ˆè®¿é—®æŒ‡é’ˆæ‰€æŒ‡å‘çš„å¯¹è±¡çš„æˆå‘˜ï¼Œcur æ˜¯ä¸€ä¸ªæŒ‡å‘ ListNode ç»“æ„ä½“å¯¹è±¡çš„æŒ‡é’ˆï¼Œè€Œ next æ˜¯ ListNode ç»“æ„ä½“å†…éƒ¨çš„ä¸€ä¸ªæˆå‘˜å˜é‡ï¼ˆæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆï¼‰ã€‚ä½¿ç”¨ cur->next è¡¨ç¤ºè®¿é—® cur æ‰€æŒ‡å‘çš„èŠ‚ç‚¹çš„ next æˆå‘˜å˜é‡ã€‚ */ #include &lt;iostream> using namespace std; struct ListNode&#123; int val; ListNode *next; ListNode(int x) : val(x) , next(nullptr)&#123;&#125; &#125;; int main()&#123; // æŒ‡é’ˆå˜é‡ = new æ•°æ®ç±»å‹ // å»ºç«‹ä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹ ListNode *dummyhead = new ListNode(0); int m, n; while (cin >> n)&#123; ListNode *cur = dummyhead; while(n--)&#123; cin >> m; ListNode *newnode = new ListNode(m); cur-> next = newnode; cur = cur -> next; &#125; cur = dummyhead; while (cur->next != NULL)&#123; cout &lt;&lt; cur->next->val &lt;&lt; ' '; cur = cur->next; &#125; cout &lt;&lt; endl; &#125; &#125; 3.2 åŸºç¡€2è¯·ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œå®ç°ä»¥ä¸‹æ“ä½œï¼š æ„å»ºä¸€ä¸ªå•å‘é“¾è¡¨ï¼Œé“¾è¡¨ä¸­åŒ…å«ä¸€ç»„æ•´æ•°æ•°æ®ï¼Œè¾“å‡ºé“¾è¡¨ä¸­çš„ç¬¬ m ä¸ªå…ƒç´ ï¼ˆm ä» 1 å¼€å§‹è®¡æ•°ï¼‰ã€‚è¦æ±‚ï¼š ä½¿ç”¨è‡ªå®šä¹‰çš„é“¾è¡¨æ•°æ®ç»“æ„ æä¾›ä¸€ä¸ª linkedList ç±»æ¥ç®¡ç†é“¾è¡¨ï¼ŒåŒ…å«æ„å»ºé“¾è¡¨ã€è¾“å‡ºé“¾è¡¨å…ƒç´ ä»¥åŠè¾“å‡ºç¬¬ m ä¸ªå…ƒç´ çš„æ–¹æ³• åœ¨ main å‡½æ•°ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªåŒ…å«ä¸€ç»„æ•´æ•°æ•°æ®çš„é“¾è¡¨ï¼Œç„¶åè¾“å…¥ mï¼Œè°ƒç”¨é“¾è¡¨çš„æ–¹æ³•è¾“å‡ºç¬¬ m ä¸ªå…ƒç´  &nbsp;è¾“å…¥æè¿°ï¼š ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° n å’Œ kï¼Œn è¡¨ç¤ºéœ€è¦æ„å»ºçš„é“¾è¡¨çš„é•¿åº¦ï¼Œk ä»£è¡¨è¾“å…¥çš„ m çš„ä¸ªæ•°ã€‚æ¥ä¸‹æ¥ä¸€è¡ŒåŒ…å« n ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºé“¾è¡¨ä¸­çš„å…ƒç´ ã€‚æ¥ä¸‹æ¥ä¸€è¡ŒåŒ…å« k ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºè¾“å‡ºé“¾è¡¨ä¸­çš„ç¬¬ m ä¸ªå…ƒç´ ã€‚ &nbsp;è¾“å‡ºæè¿°æµ‹è¯•æ•°æ®è¾“å‡ºå  k è¡Œã€‚æ¯è¡Œè¾“å‡ºé“¾è¡¨ä¸­çš„ç¬¬ m ä¸ªå…ƒç´ ã€‚å¦‚æœ m ä½ç½®ä¸åˆæ³•ï¼Œåˆ™è¾“å‡ºâ€œOutput position out of bounds.â€ã€‚ #include &lt;iostream> using namespace std; struct linknode&#123; int val; linknode* next; linknode(int x): val(x), next(nullptr) &#123;&#125; &#125;; int main()&#123; int n, k; int num; cin >> n >> k ; linknode* dummynode = new linknode(0); linknode* cur; cur = dummynode; // creat linklist while (n--)&#123; cin >> num; linknode *newnode =new linknode(num); cur->next = newnode; cur = cur -> next; &#125; // output while (k--)&#123; cin >> num; cur = dummynode; // judge range for (int i = 0; i &lt; num; i++)&#123; // if exceed, break if (cur != NULL) cur = cur->next ; else break; &#125; // cur == NULL : exceed // cur == dummyHead : m = 0 if (cur == NULL || cur == dummynode) &#123; cout &lt;&lt; \"Output position out of bounds.\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; cur->val &lt;&lt; endl; &#125; &#125; return 0; &#125; 3.3 åŸºç¡€3è¯·ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œå®ç°ä»¥ä¸‹é“¾è¡¨æ“ä½œï¼šæ„å»ºä¸€ä¸ªå•å‘é“¾è¡¨ï¼Œé“¾è¡¨ä¸­åŒ…å«ä¸€ç»„æ•´æ•°æ•°æ®ã€‚ å®ç°åœ¨é“¾è¡¨çš„ç¬¬ n ä¸ªä½ç½®æ’å…¥ä¸€ä¸ªå…ƒç´ ï¼Œè¾“å‡ºæ•´ä¸ªé“¾è¡¨çš„æ‰€æœ‰å…ƒç´ ã€‚ å®ç°åˆ é™¤é“¾è¡¨çš„ç¬¬ m ä¸ªä½ç½®çš„å…ƒç´ ï¼Œè¾“å‡ºæ•´ä¸ªé“¾è¡¨çš„æ‰€æœ‰å…ƒç´ ã€‚ è¦æ±‚ï¼š ä½¿ç”¨è‡ªå®šä¹‰çš„é“¾è¡¨æ•°æ®ç»“æ„ã€‚ æä¾›ä¸€ä¸ª linkedList ç±»æ¥ç®¡ç†é“¾è¡¨ï¼ŒåŒ…å«æ„å»ºé“¾è¡¨ã€æ’å…¥å…ƒç´ ã€åˆ é™¤å…ƒç´ å’Œè¾“å‡ºé“¾è¡¨å…ƒç´ çš„æ–¹æ³•ã€‚ åœ¨ main å‡½æ•°ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªåŒ…å«ä¸€ç»„æ•´æ•°æ•°æ®çš„é“¾è¡¨ï¼Œç„¶åæ ¹æ®è¾“å…¥çš„ n å’Œ mï¼Œè°ƒç”¨é“¾è¡¨çš„æ–¹æ³•æ’å…¥å’Œåˆ é™¤å…ƒç´ ï¼Œå¹¶è¾“å‡ºæ•´ä¸ªé“¾è¡¨çš„æ‰€æœ‰å…ƒç´ ã€‚&nbsp; è¾“å…¥æè¿°: æ¯æ¬¡è¾“å‡ºåªæœ‰ä¸€ç»„æµ‹è¯•æ•°æ®ã€‚ æ¯ç»„çš„ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•° kï¼Œè¡¨ç¤ºéœ€è¦æ„å»ºçš„é“¾è¡¨çš„é•¿åº¦ã€‚ ç¬¬äºŒè¡ŒåŒ…å« k ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºé“¾è¡¨ä¸­çš„å…ƒç´ ã€‚ ç¬¬ä¸‰è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•° Sï¼Œè¡¨ç¤ºåç»­ä¼šæœ‰ S è¡Œè¾“å…¥ï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•°ï¼Œç¬¬ä¸€ä¸ªæ•´æ•°ä¸º nï¼Œç¬¬äºŒä¸ªæ•´æ•°ä¸º x ï¼Œä»£è¡¨åœ¨é“¾è¡¨çš„ç¬¬ n ä¸ªä½ç½®æ’å…¥ xã€‚ S è¡Œè¾“å…¥â€¦ åœ¨ S è¡Œè¾“å…¥åï¼Œåç»­ä¼šè¾“å…¥ä¸€ä¸ªæ•´æ•° Lï¼Œè¡¨ç¤ºåç»­ä¼šæœ‰ L è¡Œè¾“å…¥ï¼Œæ¯è¡Œä¸€ä¸ªæ•´æ•° mï¼Œä»£è¡¨åˆ é™¤é“¾è¡¨ä¸­çš„ç¬¬ m ä¸ªå…ƒç´ ã€‚ L è¡Œè¾“å…¥â€¦&nbsp; è¾“å‡ºæè¿°: åŒ…å«å¤šç»„è¾“å‡ºã€‚ æ¯ç»„ç¬¬ä¸€è¡Œè¾“å‡ºæ„å»ºçš„é“¾è¡¨ï¼Œé“¾è¡¨å…ƒç´ ä¸­ç”¨ç©ºæ ¼éš”å¼€ï¼Œæœ€åä¸€ä¸ªå…ƒç´ åæ²¡æœ‰ç©ºæ ¼ã€‚ ç„¶åæ˜¯ S è¡Œè¾“å‡ºï¼Œæ¯æ¬¡æ’å…¥ä¸€ä¸ªå…ƒç´ ä¹‹åéƒ½å°†é“¾è¡¨è¾“å‡ºä¸€æ¬¡ï¼Œå…ƒç´ ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ï¼Œæœ€åä¸€ä¸ªå…ƒç´ åæ²¡æœ‰ç©ºæ ¼ï¼› å¦‚æœæ’å…¥ä½ç½®ä¸åˆæ³•ï¼Œåˆ™è¾“å‡ºâ€œInsertion position is invalid.â€ã€‚ ç„¶åæ˜¯ L è¡Œè¾“å‡ºï¼Œæ¯æ¬¡åˆ é™¤ä¸€ä¸ªå…ƒç´ ä¹‹åéƒ½å°†é“¾è¡¨è¾“å‡ºä¸€æ¬¡ï¼Œå…ƒç´ ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ï¼Œæœ€åä¸€ä¸ªå…ƒç´ åæ²¡æœ‰ç©ºæ ¼ï¼›å¦‚æœåˆ é™¤å…ƒç´ åé“¾è¡¨çš„é•¿åº¦ä¸º0ï¼Œåˆ™ä¸æ‰“å°é“¾è¡¨ã€‚ å¦‚æœåˆ é™¤ä½ç½®ä¸åˆæ³•ï¼Œåˆ™è¾“å‡ºâ€œDeletion position is invalid.â€ã€‚ å¦‚æœé“¾è¡¨å·²ç»ä¸ºç©ºï¼Œæ‰§è¡Œåˆ é™¤æ“ä½œæ—¶ä¸éœ€è¦æ‰“å°ä»»ä½•æ•°æ®ã€‚ #include &lt;iostream> using namespace std; struct linknode &#123; int val; linknode *next; linknode(int x) : val(x), next(nullptr) &#123;&#125; &#125;; // function for print the linklist void printlinklist(linknode *listhead) &#123; linknode *cur = listhead; while (cur->next != NULL) &#123; cout &lt;&lt; cur->next->val &lt;&lt; ' '; cur = cur->next; &#125; cout &lt;&lt; endl; &#125; int main() &#123; int k, s, l; int num; int place, var; int deleteplace; bool flag = 0; linknode *dummyhead = new linknode(0); linknode *cur; cin >> k; // linklist create cur = dummyhead; // linklist length int listLen = k; while (k--) &#123; cin >> num; cur->next = new linknode(num); cur = cur->next; &#125; // insert cin >> s; while (s--) &#123; cur = dummyhead; cin >> place >> var; if ((place > listLen) || (place &lt;= 0)) &#123; cout &lt;&lt; \"Insertion position is invalid.\" &lt;&lt; endl; continue; &#125; else &#123; for (int i = 1; i &lt; place; i++) &#123; cur = cur->next; &#125; linknode *insertnode = new linknode(var); insertnode->next = cur->next; cur->next = insertnode; // add length listLen++; &#125; // output printlinklist(dummyhead); &#125; // delete cin >> l; while (l--) &#123; cin >> deleteplace; if ((deleteplace > listLen) || (deleteplace &lt;= 0)) &#123; cout &lt;&lt; \"Deletion position is invalid.\" &lt;&lt; endl; continue; &#125; else &#123; cur = dummyhead; for (int i = 1; i &lt; deleteplace; i++) &#123; cur = cur->next; &#125; cur->next = cur->next->next; listLen--; &#125; if (listLen) printlinklist(dummyhead); &#125; return 0; &#125; 3.4 è®¾è®¡é“¾è¡¨ä½ å¯ä»¥é€‰æ‹©ä½¿ç”¨å•é“¾è¡¨æˆ–è€…åŒé“¾è¡¨ï¼Œè®¾è®¡å¹¶å®ç°è‡ªå·±çš„é“¾è¡¨ã€‚ï¼ˆè¿™é‡Œä½¿ç”¨å•é“¾è¡¨ï¼‰ å•é“¾è¡¨ä¸­çš„èŠ‚ç‚¹åº”è¯¥å…·å¤‡ä¸¤ä¸ªå±æ€§ï¼šval å’Œ next ã€‚val æ˜¯å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œnext æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ/å¼•ç”¨ã€‚ å¦‚æœæ˜¯åŒå‘é“¾è¡¨ï¼Œåˆ™è¿˜éœ€è¦å±æ€§ prev ä»¥æŒ‡ç¤ºé“¾è¡¨ä¸­çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹ã€‚å‡è®¾é“¾è¡¨ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ä¸‹æ ‡ä» 0 å¼€å§‹ã€‚ å®ç° MyLinkedList ç±»ï¼š MyLinkedList() åˆå§‹åŒ– MyLinkedList å¯¹è±¡ã€‚ int get(int index) è·å–é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹çš„å€¼ã€‚å¦‚æœä¸‹æ ‡æ— æ•ˆï¼Œåˆ™è¿”å› -1 ã€‚ void addAtHead(int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹æ’å…¥åˆ°é“¾è¡¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰ã€‚åœ¨æ’å…¥å®Œæˆåï¼Œæ–°èŠ‚ç‚¹ä¼šæˆä¸ºé“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ void addAtTail(int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹è¿½åŠ åˆ°é“¾è¡¨ä¸­ä½œä¸ºé“¾è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚ void addAtIndex(int index, int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹æ’å…¥åˆ°é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹ä¹‹å‰ã€‚å¦‚æœ index ç­‰äºé“¾è¡¨çš„é•¿åº¦ï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹ä¼šè¢«è¿½åŠ åˆ°é“¾è¡¨çš„æœ«å°¾ã€‚å¦‚æœ index æ¯”é•¿åº¦æ›´å¤§ï¼Œè¯¥èŠ‚ç‚¹å°† ä¸ä¼šæ’å…¥ åˆ°é“¾è¡¨ä¸­ã€‚ void deleteAtIndex(int index) å¦‚æœä¸‹æ ‡æœ‰æ•ˆï¼Œåˆ™åˆ é™¤é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹ã€‚ class MyLinkedList &#123; public: struct LinkNode&#123; int val; LinkNode* next; LinkNode(int val): val(val), next(nullptr)&#123;&#125; &#125;; // åˆå§‹åŒ– MyLinkedList() &#123; dummyhead = new LinkNode(0); size = 0; &#125; int get(int index) &#123; if ( index &lt; 0 || index > (size - 1)) return -1; LinkNode* cur = dummyhead -> next; while (index --)&#123; cur = cur -> next; &#125; return cur ->val; &#125; void addAtHead(int val) &#123; LinkNode* newhead = new LinkNode(val); newhead->next = dummyhead ->next; dummyhead ->next = newhead; size ++; &#125; void addAtTail(int val) &#123; LinkNode* newtail = new LinkNode(val); LinkNode* cur = dummyhead; while (cur -> next != NULL)&#123; cur = cur -> next; &#125; cur -> next = newtail; size ++; &#125; void addAtIndex(int index, int val) &#123; LinkNode* newinsert = new LinkNode(val); if (index &lt; 0 || index > size) return; LinkNode* cur = dummyhead; while (index --)&#123; cur = cur-> next; &#125; newinsert -> next = cur -> next; cur -> next = newinsert; size ++; &#125; void deleteAtIndex(int index) &#123; LinkNode* cur = dummyhead; if (index &lt; 0 || index >= size) return ; while (index --)&#123; cur = cur->next; &#125; cur ->next = cur->next->next; size --; &#125; private: LinkNode* dummyhead; int size = 0; &#125;; /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj->get(index); * obj->addAtHead(val); * obj->addAtTail(val); * obj->addAtIndex(index,val); * obj->deleteAtIndex(index); */ 3.5 åè½¬é“¾è¡¨ç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨ã€‚ /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* reverseList(ListNode* head) &#123; ListNode* pre = NULL; ListNode* cur = head ; ListNode* temp; //æ³¨æ„ä¸´ç•Œæ¡ä»¶ while (cur != NULL)&#123; temp = cur->next; cur->next = pre; pre = cur; cur = temp; &#125; return pre; &#125; &#125;; 3.6 ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›äº¤æ¢åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚ä½ å¿…é¡»åœ¨ä¸ä¿®æ”¹èŠ‚ç‚¹å†…éƒ¨çš„å€¼çš„æƒ…å†µä¸‹å®Œæˆæœ¬é¢˜ï¼ˆå³ï¼Œåªèƒ½è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ï¼‰ã€‚ /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* swapPairs(ListNode* head) &#123; ListNode* dummyhead = new ListNode(0); dummyhead->next = head; ListNode* cur = dummyhead; while (cur->next != nullptr &amp;&amp; cur->next->next != nullptr)&#123; ListNode* temp = cur->next; ListNode* temp_1 = cur->next->next->next; cur->next = cur->next->next; cur->next->next = temp; cur->next->next->next = temp_1; cur = temp; &#125; return dummyhead->next; &#125; &#125;; 3.7 åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œåˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ n ä¸ªç»“ç‚¹ï¼Œå¹¶ä¸”è¿”å›é“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚ æš´åŠ›ï¼š /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummyhead = new ListNode(0); dummyhead->next = head; ListNode* cur = dummyhead; int count = 0; while (cur->next != NULL)&#123; cur = cur->next; count ++; &#125; int count_reverse = count - n ; // cout &lt;&lt; count &lt;&lt; endl; cur = dummyhead; for (int i = 0; i &lt; count_reverse ; i++)&#123; cur = cur->next; &#125; // cout &lt;&lt; cur->val &lt;&lt; endl; if (cur->next != NULL) cur->next = cur->next->next; return dummyhead->next; &#125; &#125;; åŒæŒ‡é’ˆï¼š /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* dummy = new ListNode(0); dummy->next = head; ListNode* fast = dummy; while (n--)&#123; fast = fast->next; &#125; ListNode* slow = dummy; while (fast->next != NULL)&#123; fast = fast->next; slow = slow->next; &#125; slow->next = slow->next->next; return dummy->next; &#125; &#125;; 3.8 é“¾è¡¨ç›¸äº¤ç»™ä½ ä¸¤ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ headA å’Œ headB ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚å¦‚æœä¸¤ä¸ªé“¾è¡¨æ²¡æœ‰äº¤ç‚¹ï¼Œè¿”å› null ã€‚ æš´åŠ›ï¼š /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode* dummyA = new ListNode(0); ListNode* dummyB = new ListNode(0); dummyA->next = headA; dummyB->next = headB; ListNode* curA = dummyA; ListNode* curB = dummyB; while(curA->next != NULL)&#123; curA = curA->next; while (curB-> next != NULL)&#123; curB = curB ->next; if (curB == curA) return curA; &#125; curB = dummyB; &#125; return NULL; &#125; &#125;; æš´åŠ›2ï¼š ä¸¤é“¾è¡¨å°¾ç«¯å¯¹é½åï¼Œä¸¤éå†èŠ‚ç‚¹åŒæ—¶å–çŸ­é“¾è¡¨headï¼Œå‘åç§»åŠ¨å¹¶æ£€æŸ¥ class Solution &#123; public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode* curA = headA; ListNode* curB = headB; int lenA = 0, lenB = 0; while (curA != NULL) &#123; // æ±‚é“¾è¡¨Açš„é•¿åº¦ lenA++; curA = curA->next; &#125; while (curB != NULL) &#123; // æ±‚é“¾è¡¨Bçš„é•¿åº¦ lenB++; curB = curB->next; &#125; curA = headA; curB = headB; // è®©curAä¸ºæœ€é•¿é“¾è¡¨çš„å¤´ï¼ŒlenAä¸ºå…¶é•¿åº¦ if (lenB > lenA) &#123; swap (lenA, lenB); swap (curA, curB); &#125; // æ±‚é•¿åº¦å·® int gap = lenA - lenB; // è®©curAå’ŒcurBåœ¨åŒä¸€èµ·ç‚¹ä¸Šï¼ˆæœ«å°¾ä½ç½®å¯¹é½ï¼‰ while (gap--) &#123; curA = curA->next; &#125; // éå†curA å’Œ curBï¼Œé‡åˆ°ç›¸åŒåˆ™ç›´æ¥è¿”å› while (curA != NULL) &#123; if (curA == curB) &#123; return curA; &#125; curA = curA->next; curB = curB->next; &#125; return NULL; &#125; &#125;; 3.9 ç¯å½¢é“¾è¡¨ç»™å®šä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¿”å›é“¾è¡¨å¼€å§‹å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å¦‚æœé“¾è¡¨æ— ç¯ï¼Œåˆ™è¿”å› nullã€‚ å¦‚æœé“¾è¡¨ä¸­æœ‰æŸä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥é€šè¿‡è¿ç»­è·Ÿè¸ª next æŒ‡é’ˆå†æ¬¡åˆ°è¾¾ï¼Œåˆ™é“¾è¡¨ä¸­å­˜åœ¨ç¯ã€‚ ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œè¯„æµ‹ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨æ•´æ•° pos æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆç´¢å¼•ä» 0 å¼€å§‹ï¼‰ã€‚å¦‚æœ pos æ˜¯ -1ï¼Œåˆ™åœ¨è¯¥é“¾è¡¨ä¸­æ²¡æœ‰ç¯ã€‚æ³¨æ„ï¼špos ä¸ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’ï¼Œä»…ä»…æ˜¯ä¸ºäº†æ ‡è¯†é“¾è¡¨çš„å®é™…æƒ…å†µã€‚ ä¸å…è®¸ä¿®æ”¹ é“¾è¡¨ã€‚ æš´åŠ›å“ˆå¸Œï¼š /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode *detectCycle(ListNode *head) &#123; unordered_set&lt;ListNode*> store; ListNode* dummy = new ListNode(0); dummy->next = head; ListNode* cur = dummy; while (cur->next != NULL)&#123; store.insert(cur->next); cur = cur->next; //if (store.count(cur->next)) ä¹Ÿè¡Œ if (store.find(cur->next) != store.end()) return cur->next; &#125; return NULL; &#125; &#125;; åŒæŒ‡é’ˆï¼šfastæ˜¯èµ°ä¸¤æ­¥ï¼Œslowæ˜¯èµ°ä¸€æ­¥ï¼Œå…¶å®ç›¸å¯¹äºslowæ¥è¯´ï¼Œfastæ˜¯ä¸€ä¸ªèŠ‚ç‚¹ä¸€ä¸ªèŠ‚ç‚¹çš„é è¿‘slowçš„ï¼Œæ‰€ä»¥fastä¸€å®šå¯ä»¥å’Œslowé‡åˆã€‚ class Solution &#123; public: ListNode *detectCycle(ListNode *head) &#123; ListNode* fast = head; ListNode* slow = head; while(fast != NULL &amp;&amp; fast->next != NULL) &#123; slow = slow->next; fast = fast->next->next; // å¿«æ…¢æŒ‡é’ˆç›¸é‡ï¼Œæ­¤æ—¶ä»headå’Œç›¸é‡ç‚¹ï¼ŒåŒæ—¶æŸ¥æ‰¾ç›´è‡³ç›¸é‡ if (slow == fast) &#123; ListNode* index1 = fast; ListNode* index2 = head; while (index1 != index2) &#123; index1 = index1->next; index2 = index2->next; &#125; return index2; // è¿”å›ç¯çš„å…¥å£ &#125; &#125; return NULL; &#125; &#125;; &nbsp; 4. å“ˆå¸Œæ•£åˆ—4.1 åŸºç¡€ï¼šæ•°ç»„ç»™å®šä¸€ä¸ªåªåŒ…å«å°å†™å­—æ¯çš„å­—ç¬¦ä¸²ï¼Œç»Ÿè®¡å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå­—æ¯å‡ºç°çš„é¢‘ç‡ï¼Œå¹¶æ‰¾å‡ºå‡ºç°é¢‘ç‡æœ€é«˜çš„å­—æ¯ï¼Œå¦‚æœæœ€é«˜é¢‘ç‡çš„å­—æ¯æœ‰å¤šä¸ªï¼Œè¾“å‡ºå­—å…¸åºé å‰çš„é‚£ä¸ªå­—æ¯ã€‚ åŒ…å«å¤šç»„æµ‹è¯•æ•°æ®ï¼Œæ¯ç»„æµ‹è¯•æ•°æ®å ä¸€è¡Œã€‚ æœ‰å¤šç»„è¾“å‡ºï¼Œæ¯ç»„è¾“å‡ºå ä¸€è¡Œã€‚ #include &lt;iostream> #include &lt;string> using namespace std; int main() &#123; int n; string s; while (cin >> n) &#123; while (n--) &#123; cin >> s; int count[26] = &#123;0&#125;; int max = 0; int max_flag = 0; // hash for (int i = 0; i &lt; s.size(); i++) &#123; count[s[i] - 'a']++; &#125; // select max for (int j = 0; j &lt; 26; j++) &#123; if (count[j] > max) &#123; max = count[j]; max_flag = j; &#125; &#125; char result; result = max_flag + 'a'; cout &lt;&lt; result; cout &lt;&lt; endl; &#125; &#125; return 0; &#125; 4.2 åŸºç¡€ï¼šsetç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œåˆ¤æ–­ç»™å®šçš„æ•´æ•° n æ˜¯å¦å­˜åœ¨äºç»™å®šçš„é›†åˆä¸­ã€‚ æœ‰å¤šç»„æµ‹è¯•æ•°æ®ï¼Œç¬¬ä¸€è¡Œæœ‰ä¸€ä¸ªæ•´æ•° kï¼Œä»£è¡¨æœ‰ k ç»„æµ‹è¯•æ•°æ®ã€‚ æ¯ç»„æ•°æ®ç¬¬ä¸€è¡Œé¦–å…ˆæ˜¯ä¸€ä¸ªæ­£æ•´æ•° mï¼Œè¡¨ç¤ºé›†åˆä¸­å…ƒç´ çš„æ•°é‡ï¼ˆ1 &lt;= m &lt;= 1000ï¼‰ã€‚ æ¥ä¸‹æ¥ä¸€è¡ŒåŒ…å« m ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºé›†åˆä¸­çš„å…ƒç´ ã€‚ æœ€åä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•° nï¼Œè¡¨ç¤ºéœ€è¦è¿›è¡Œåˆ¤æ–­çš„ç›®æ ‡æ•´æ•°ã€‚ åŒ…å«å¤šç»„è¾“å‡ºï¼Œæ¯ç»„è¾“å‡ºå ä¸€è¡Œã€‚ å¦‚æœé›†åˆä¸­å­˜åœ¨ mï¼Œè¾“å‡ºâ€œYESâ€ï¼Œå¦åˆ™è¾“å‡ºâ€œNOâ€ã€‚ // set é›†åˆ #include &lt;iostream> #include &lt;unordered_set> using namespace std; int main() &#123; int m, n, l; int test; cin >> m; while (m--) &#123; cin >> n; unordered_set&lt;int> uset; while (n--) &#123; cin >> l; // set insert uset.insert(l); &#125; //test cin >> test; if (uset.find(test) != uset.end()) // check iterator cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125; &#125; 4.3 åŸºç¡€ï¼šmapå‡è®¾ä½ æ‰‹é‡Œæœ‰ä¸€ä¸²é’¥åŒ™ï¼Œè¿™ä¸²é’¥åŒ™ä¸Šæ¯æŠŠé’¥åŒ™éƒ½æœ‰ä¸€ä¸ªç¼–å·ï¼Œå¯¹åº”ç€ä¸€ä¸ªæˆ¿é—¨çš„ç¼–å·ã€‚ç°ç»™ä½ ä¸€ä¸ªæˆ¿é—¨ç¼–å·ï¼Œä½ éœ€è¦åˆ¤æ–­æ˜¯å¦èƒ½å¤Ÿæ‰“å¼€è¯¥æˆ¿é—¨ã€‚ æµ‹è¯•æ•°æ®å…±æœ‰å¤šç»„ã€‚ ç¬¬ä¸€è¡Œä¸ºä¸€ä¸ªæ•´æ•° sï¼Œè¡¨ç¤ºå…±æœ‰å¤šå°‘ç»„æµ‹è¯•æ•°æ®ã€‚ æ¯ç»„ç¬¬ä¸€è¡Œæœ‰ä¸€ä¸ªæ•´æ•° nï¼Œè¡¨ç¤ºé’¥åŒ™ä¸²ä¸Šæœ‰å¤šå°‘æŠŠé’¥åŒ™ã€‚ åé¢å…±æœ‰ n è¡Œè¾“å…¥ï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•°ï¼Œç¬¬ä¸€ä¸ªæ•´æ•° k è¡¨ç¤ºé’¥åŒ™ç¼–å·ï¼Œç¬¬äºŒä¸ªæ•´æ•° d è¡¨ç¤ºæˆ¿é—¨ç¼–å·ã€‚ æœ€åä¸€è¡Œæœ‰ä¸€ä¸ªæ•´æ•° xï¼Œè¡¨ç¤ºéœ€è¦æ‰“å¼€çš„æˆ¿é—¨ç¼–å·ã€‚ è¾“å‡ºå¤šç»„ï¼Œæ¯ç»„å ä¸€è¡Œã€‚ å¦‚æœèƒ½æ‰“å¼€ï¼Œåˆ™è¾“å‡ºé’¥åŒ™ç¼–å·ï¼Œä¸èƒ½æ‰“å¼€åˆ™è¾“å‡ºâ€œCanâ€™t open the door.â€ã€‚ #include &lt;iostream> #include &lt;unordered_map> using namespace std; int main() &#123; int n, m; cin >> n; int key_num; int door_num; int x; while (n--) &#123; cin >> m; unordered_map&lt;int, int> umap; while (m--) &#123; cin >> key_num >> door_num; umap[key_num] = door_num; &#125; cin >> x; bool flag = 0; int answer = 0; for (const pair&lt;int,int> &amp;kv : umap) &#123; if (kv.second == x) &#123; flag = 1; answer = kv.first; break; &#125; &#125; if (flag == 1) &#123; cout &lt;&lt; answer &lt;&lt; endl; &#125; else cout &lt;&lt; \"Can't open the door.\" &lt;&lt; endl; &#125; &#125; 4.4 å­˜åœ¨é‡å¤å…ƒç´ ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ã€‚å¦‚æœä»»ä¸€å€¼åœ¨æ•°ç»„ä¸­å‡ºç° è‡³å°‘ä¸¤æ¬¡ ï¼Œè¿”å› true ï¼›å¦‚æœæ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ äº’ä¸ç›¸åŒï¼Œè¿”å› false ã€‚ class Solution &#123; public: bool containsDuplicate(vector&lt;int>&amp; nums) &#123; unordered_set&lt;int> res; for (int num: nums)&#123; if (res.contains(num)) return true; else res.insert(num); &#125; return false; &#125; &#125;; 4.5 åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ç»™ä½ ä¸€ä¸ª éç©º æ•´æ•°æ•°ç»„ nums ï¼Œé™¤äº†æŸä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ä»¥å¤–ï¼Œå…¶ä½™æ¯ä¸ªå…ƒç´ å‡å‡ºç°ä¸¤æ¬¡ã€‚æ‰¾å‡ºé‚£ä¸ªåªå‡ºç°äº†ä¸€æ¬¡çš„å…ƒç´ ã€‚ ä½ å¿…é¡»è®¾è®¡å¹¶å®ç°çº¿æ€§æ—¶é—´å¤æ‚åº¦çš„ç®—æ³•æ¥è§£å†³æ­¤é—®é¢˜ï¼Œä¸”è¯¥ç®—æ³•åªä½¿ç”¨å¸¸é‡é¢å¤–ç©ºé—´ã€‚ class Solution &#123; public: int singleNumber(vector&lt;int>&amp; nums) &#123; unordered_map&lt;int , int > count; for (int num: nums)&#123; count[num] ++; &#125; for (int num : nums)&#123; if (count[num] == 1)&#123; return num; &#125; &#125; return -1; &#125; &#125;; 4.6 æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² s å’Œ t ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­ t æ˜¯å¦æ˜¯ s çš„ å­—æ¯å¼‚ä½è¯ã€‚ s å’Œ t ä»…åŒ…å«å°å†™å­—æ¯ class Solution &#123; public: bool isAnagram(string s, string t) &#123; vector&lt;int> table(26.0); //é•¿åº¦ä¸åŒå¿…å®šfalse if (s.length() != t.length()) return false; for (char &amp;ch : s)&#123; table[ch - 'a'] ++; &#125; for (char &amp;ch : t)&#123; table[ch - 'a']--; if (table[ch- 'a'] &lt; 0) return false; &#125; return true; &#125; &#125;; 4.7 ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†ç»™å®šä¸¤ä¸ªæ•°ç»„ nums1 å’Œ nums2 ï¼Œè¿”å› å®ƒä»¬çš„ äº¤é›† ã€‚è¾“å‡ºç»“æœä¸­çš„æ¯ä¸ªå…ƒç´ ä¸€å®šæ˜¯ å”¯ä¸€ çš„ã€‚æˆ‘ä»¬å¯ä»¥ ä¸è€ƒè™‘è¾“å‡ºç»“æœçš„é¡ºåº ã€‚ class Solution &#123; public: vector&lt;int> intersection(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2) &#123; unordered_set&lt;int> result, restore; for (auto &amp;num : nums1)&#123; if(!restore.count(num)) restore.insert(num); &#125; for (auto &amp;num : nums2)&#123; if (restore.count(num)) result.insert(num); &#125; //vector&lt;int> a(begin_iterator, end_iterator);ï¼šä½¿ç”¨èŒƒå›´æ„é€ å‡½æ•°ï¼Œç”¨è¿­ä»£å™¨æŒ‡å®šçš„èŒƒå›´æ¥åˆå§‹åŒ–å‘é‡ã€‚ return vector&lt;int>(result.begin(), result.end()); &#125; &#125;; 4.8 å¿«ä¹æ•°ç¼–å†™ä¸€ä¸ªç®—æ³•æ¥åˆ¤æ–­ä¸€ä¸ªæ•° n æ˜¯ä¸æ˜¯å¿«ä¹æ•°ã€‚ ã€Œå¿«ä¹æ•°ã€ å®šä¹‰ä¸ºï¼š å¯¹äºä¸€ä¸ªæ­£æ•´æ•°ï¼Œæ¯ä¸€æ¬¡å°†è¯¥æ•°æ›¿æ¢ä¸ºå®ƒæ¯ä¸ªä½ç½®ä¸Šçš„æ•°å­—çš„å¹³æ–¹å’Œã€‚ ç„¶åé‡å¤è¿™ä¸ªè¿‡ç¨‹ç›´åˆ°è¿™ä¸ªæ•°å˜ä¸º 1ï¼Œä¹Ÿå¯èƒ½æ˜¯ æ— é™å¾ªç¯ ä½†å§‹ç»ˆå˜ä¸åˆ° 1ã€‚ å¦‚æœè¿™ä¸ªè¿‡ç¨‹ ç»“æœä¸º 1ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å°±æ˜¯å¿«ä¹æ•°ã€‚ å¦‚æœ n æ˜¯ å¿«ä¹æ•° å°±è¿”å› true ï¼›ä¸æ˜¯ï¼Œåˆ™è¿”å› false ã€‚ class Solution &#123; public: bool isHappy(int n) &#123; unordered_set &lt;int> sum; int result = n; while (sumsquare(result) != 1 )&#123; result = sumsquare(result); if (sum.count(result)) return false; sum.insert(result); &#125; return true; &#125; int sumsquare(int x)&#123; int sum = 0; int j = 0; while (x > 0)&#123; j = x % 10; // x = (x - j) / 10; x /= 10; sum += j * j; &#125; return sum; &#125; &#125;; 4.9 ä¸¤æ•°ä¹‹å’Œç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º å’Œä¸ºç›®æ ‡å€¼ target çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚ ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆï¼Œå¹¶ä¸”ä½ ä¸èƒ½ä½¿ç”¨ä¸¤æ¬¡ç›¸åŒçš„å…ƒç´ ã€‚ ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚ class Solution &#123; public: vector&lt;int> twoSum(vector&lt;int>&amp; nums, int target) &#123; unordered_map&lt;int,int> pair; for (int i = 0 ; i&lt; nums.size(); i++)&#123; if (pair.count(target-nums[i])) return &#123;pair[target- nums[i]], i&#125;; pair[nums[i]] = i; &#125; return &#123;&#125;; &#125; &#125;; 4.10 å››æ•°ç›¸åŠ â…¡ç»™ä½ å››ä¸ªæ•´æ•°æ•°ç»„ nums1ã€nums2ã€nums3 å’Œ nums4 ï¼Œæ•°ç»„é•¿åº¦éƒ½æ˜¯ n ï¼Œè¯·ä½ è®¡ç®—æœ‰å¤šå°‘ä¸ªå…ƒç»„ (i, j, k, l) èƒ½æ»¡è¶³ï¼š 0 &lt;= i, j, k, l &lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 class Solution &#123; public: int fourSumCount(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2, vector&lt;int>&amp; nums3, vector&lt;int>&amp; nums4) &#123; int count = 0; int n = nums1.size(); int sum = 0; unordered_map&lt;int, int> result; for (int i = 0 ; i &lt; n ; i++ )&#123; for (int j = 0; j &lt; n ; j++)&#123; sum = nums1[i] + nums2[j]; result[sum] += 1; &#125; &#125; for (int i = 0 ; i &lt; n ; i++ )&#123; for (int j = 0; j &lt; n ; j++)&#123; sum = nums3[i] + nums4[j]; if(result.find(-sum) != result.end()) count += result[-sum]; &#125; &#125; return count; &#125; &#125;; 4.11 èµé‡‘ä¿¡ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼šransomNote å’Œ magazine ï¼Œåˆ¤æ–­ ransomNote èƒ½ä¸èƒ½ç”± magazine é‡Œé¢çš„å­—ç¬¦æ„æˆã€‚ å¦‚æœå¯ä»¥ï¼Œè¿”å› true ï¼›å¦åˆ™è¿”å› false ã€‚ magazine ä¸­çš„æ¯ä¸ªå­—ç¬¦åªèƒ½åœ¨ ransomNote ä¸­ä½¿ç”¨ä¸€æ¬¡ã€‚ class Solution &#123; public: bool canConstruct(string ransomNote, string magazine) &#123; unordered_map&lt;int, int> uptime; for (auto &amp;ch : magazine)&#123; uptime[ch-'a']++; &#125; for (auto &amp;ch : ransomNote)&#123; if (uptime[ch - 'a'] == 0)&#123; return false; &#125; uptime[ch - 'a'] --; &#125; return true; &#125; &#125;; 4.12 ä¸‰æ•°ä¹‹å’Œï¼šåŒæŒ‡é’ˆç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸‰å…ƒç»„ [nums[i], nums[j], nums[k]] æ»¡è¶³ i != jã€i != k ä¸” j != k ï¼ŒåŒæ—¶è¿˜æ»¡è¶³ nums[i] + nums[j] + nums[k] == 0 ã€‚è¯·ä½ è¿”å›æ‰€æœ‰å’Œä¸º 0 ä¸”ä¸é‡å¤çš„ä¸‰å…ƒç»„ã€‚ æ³¨æ„ï¼šç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„ä¸‰å…ƒç»„ã€‚ class Solution &#123; public: vector&lt;vector&lt;int>> threeSum(vector&lt;int>&amp; nums) &#123; vector&lt;vector&lt;int>> result; sort(nums.begin(),nums.end()); //æœ¬é¢˜ä¸ºé˜²æ­¢é‡å¤å…ƒç´ å‡ºç°ï¼Œéœ€è¦å¯¹å†…å¤–å±‚å»é‡ for (int a = 0; a &lt; nums.size(); a++) &#123; if (nums[a] > 0) &#123; return result; &#125; //å¯¹aå»é‡ if (a > 0 &amp;&amp; nums[a] == nums[a - 1]) &#123; continue; &#125; int left = a + 1; int right = nums.size()-1; while (left &lt; right)&#123; if (nums[a] + nums[left] + nums[right] &lt; 0) left ++; else if (nums[a] + nums[left] + nums[right] > 0) right --; else &#123; result.push_back(vector&lt;int>&#123;nums[a], nums[left], nums[right]&#125;); // å»é‡é€»è¾‘åº”è¯¥æ”¾åœ¨æ‰¾åˆ°ä¸€ä¸ªä¸‰å…ƒç»„ä¹‹åï¼Œå¯¹bå’Œcå»é‡ while (right > left &amp;&amp; nums[right] == nums[right - 1]) &#123;right--&#125;; while (right > left &amp;&amp; nums[left] == nums[left + 1]) &#123;left++&#125;; // æ‰¾åˆ°ç­”æ¡ˆæ—¶ï¼ŒåŒæŒ‡é’ˆåŒæ—¶æ”¶ç¼© right--; left++; &#125; &#125; &#125; return result; &#125; &#125;; 4.13 å››æ•°ä¹‹å’Œç»™ä½ ä¸€ä¸ªç”± n ä¸ªæ•´æ•°ç»„æˆçš„æ•°ç»„ nums ï¼Œå’Œä¸€ä¸ªç›®æ ‡å€¼ target ã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›æ»¡è¶³ä¸‹è¿°å…¨éƒ¨æ¡ä»¶ä¸”ä¸é‡å¤çš„å››å…ƒç»„ [nums[a], nums[b], nums[c], nums[d]] ï¼ˆè‹¥ä¸¤ä¸ªå››å…ƒç»„å…ƒç´ ä¸€ä¸€å¯¹åº”ï¼Œåˆ™è®¤ä¸ºä¸¤ä¸ªå››å…ƒç»„é‡å¤ï¼‰ï¼š 0 &lt;= a, b, c, d &lt; n aã€bã€c å’Œ d äº’ä¸ç›¸åŒ nums[a] + nums[b] + nums[c] + nums[d] == target ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆ ã€‚ class Solution &#123; public: vector&lt;vector&lt;int>> fourSum(vector&lt;int>&amp; nums, int target) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int>> result; for(int a = 0; a &lt; nums.size(); a++)&#123; // å»é‡ if (a > 0 &amp;&amp; nums[a] == nums[a - 1]) &#123; continue; &#125; // å‰ªæ if (nums[a] > target &amp;&amp; nums[a] >= 0) &#123; break; &#125; for (int b = a + 1; b &lt; nums.size(); b++)&#123; // å»é‡ if (b > a + 1 &amp;&amp; nums[b] == nums[b - 1]) &#123; continue; &#125; // å‰ªæ if (nums[a] + nums[b] > target &amp;&amp; nums[b] >= 0) &#123; break; &#125; int left = b + 1; int right = nums.size() - 1; while (left &lt; right)&#123; if ((long)nums[a] + nums[b] + nums[left] + nums[right] &lt; target) left ++; else if ((long)nums[a] + nums[b] + nums[left] + nums[right] > target) right --; else &#123; result.push_back(vector&lt;int>&#123;nums[a], nums[b], nums[left], nums[right]&#125;); while (right > left &amp;&amp; nums[left+1] == nums[left]) left ++; while (right > left &amp;&amp; nums[right] == nums[right - 1]) right --; left ++; right --; &#125; &#125; &#125; &#125; return result; &#125; &#125;; &nbsp; 5. æ ˆä¸é˜Ÿåˆ—5.1 åŸºç¡€ï¼šæ ˆåœ¨é¤å…é‡Œï¼Œæ´—ç›˜å­çš„å·¥ä½œéœ€è¦ä½¿ç”¨åˆ°æ ˆè¿™ç§æ•°æ®ç»“æ„ã€‚ å‡è®¾ä½ æ‰‹é‡Œæœ‰ä¸€ä¸ªç›˜å­å †æ”¾åŒºã€‚ç°åœ¨éœ€è¦æ¨¡æ‹Ÿæ´—ç›˜å­çš„è¿‡ç¨‹ï¼Œæ¯ä¸ªç›˜å­éƒ½æœ‰ä¸€ä¸ªç¼–å·ã€‚ ç›˜å­å †æ”¾åŒºæ“ä½œè¯´æ˜ï¼š å½“æ“ä½œä¸º 1 æ—¶ï¼Œè¡¨ç¤ºä»ç›˜å­å †æ”¾åŒºæ‹¿èµ°é¡¶éƒ¨çš„ç›˜å­æ¸…æ´—ã€‚ å½“æ“ä½œä¸º 2 æ—¶ï¼Œè¡¨ç¤ºæœ‰æœªæ´—çš„ç›˜å­æ”¾å…¥ç›˜å­å †æ”¾åŒºã€‚ åœ¨ä¸€ç³»åˆ—æ“ä½œä¹‹åï¼Œä½ éœ€è¦å›ç­”ï¼šä¸‹ä¸€ä¸ªæ¸…æ´—çš„ç›˜å­ç¼–å·ï¼Ÿ ç¬¬ä¸€è¡Œæœ‰ä¸€ä¸ªæ•´æ•° nï¼Œä»£è¡¨åˆå§‹ç›˜å­å †æ”¾åŒºä¸­ç›˜å­çš„æ•°é‡ä¸º nã€‚ ç¬¬äºŒè¡Œæœ‰ n ä¸ªæ•´æ•°ï¼Œä»£è¡¨äº†ç›˜å­çš„ç¼–å·ï¼ŒåŒæ—¶æ•´æ•°ä¹‹é—´çš„é¡ºåºä¹Ÿä»£è¡¨äº†æœªæ´—ç›˜å­åŠ å…¥ç›˜å­å †æ”¾åŒºçš„é¡ºåºã€‚ ç¬¬ä¸‰è¡Œä¸ºä¸€ä¸ªæ•´æ•° mï¼Œä»£è¡¨æ¥ä¸‹æ¥å°†ä¼šæœ‰ m æ¬¡æ“ä½œã€‚ æ¥ä¸‹æ¥ä¸€å…±æœ‰ m è¡Œï¼Œä»£è¡¨å…±æœ‰ m æ¬¡æ“ä½œã€‚ å¦‚æœæ˜¯æ“ä½œ 1ï¼Œé‚£ä¹ˆè¯¥è¡Œåªä¼šæœ‰ä¸€ä¸ªæ•°å­— 1ï¼Œä»£è¡¨æœ‰ä¸€ä¸ªç›˜å­è¢«æ‹¿èµ°æ¸…æ´—ã€‚ å¦‚æœæ˜¯æ“ä½œ 2ï¼Œé‚£ä¹ˆè¯¥è¡Œæœ‰ä¸¤ä¸ªæ•°å­—ï¼Œç¬¬ä¸€ä¸ªæ•°å­— 2 è¡¨ç¤ºæœ‰æœªæ´—çš„ç›˜å­åŠ å…¥ï¼Œç¬¬äºŒä¸ªæ•°å­—ä»£è¡¨æœªæ´—çš„ç›˜å­ç¼–å·ã€‚ è¾“å‡ºå…±ä¸€è¡Œï¼Œä¸ºä¸‹ä¸€ä¸ªè¯¥æ¸…æ´—çš„ç›˜å­ç¼–å·ã€‚ å¦‚æœæ²¡æœ‰ä¸‹ä¸€ä¸ªè¯¥æ¸…æ´—çš„ç›˜å­ï¼Œé‚£ä¹ˆè¯·è¾“å‡º â€œAll the dishes have been washed.â€ #include &lt;iostream> #include &lt;stack> using namespace std; int main()&#123; int num, dish_num, oper_num; int wash_flag; cin >> num; stack &lt;int> dishes; // enter while (num -- )&#123; cin >> dish_num; dishes.push(dish_num); &#125; //operate cin >> oper_num; while ( oper_num --)&#123; cin >> wash_flag; if (wash_flag == 1 &amp;&amp; !dishes.empty()) dishes.pop(); if (wash_flag == 2)&#123; cin >> dish_num; dishes.push(dish_num); &#125; &#125; // judge if (dishes.empty()) cout &lt;&lt; \"All the dishes have been washed.\" &lt;&lt; endl; else cout &lt;&lt; dishes.top() &lt;&lt; endl; &#125; 5.2 åŸºç¡€ï¼šé˜Ÿåˆ—å‡è®¾æœ‰ä¸€å®¶å¥¶èŒ¶åº—ï¼Œç°åœ¨æœ‰ä¸€äº›äººåœ¨æ’é˜Ÿç­‰å¾…å–å¥¶èŒ¶ï¼ŒåŒæ—¶ä¹Ÿæœ‰äººåœ¨å–å¥¶èŒ¶ã€‚ è¯·ä½ è®¾è®¡ä¸€ä¸ªç¨‹åºæ¨¡æ‹Ÿè¿™ç§æƒ…å†µä¸‹çš„å¥¶èŒ¶é˜Ÿåˆ—ç®¡ç†ã€‚ å‡è®¾æ¯ä¸ªäººå–å¥¶èŒ¶çš„æ—¶é—´éå¸¸çŸ­ï¼Œå¯ä»¥å¿½ç•¥ä¸è®¡ï¼Œåªéœ€è¦è€ƒè™‘é˜Ÿåˆ—ä¸­çš„æ“ä½œã€‚ é˜Ÿåˆ—æ“ä½œè¯´æ˜ï¼š å½“æ“ä½œä¸º 1 æ—¶ï¼Œè¡¨ç¤ºæœ‰äººå·²ç»å–èµ°å¥¶èŒ¶ï¼Œä»é˜Ÿåˆ—ä¸­åˆ é™¤è¯¥äººçš„ä¿¡æ¯ã€‚ å½“æ“ä½œä¸º 2 æ—¶ï¼Œè¡¨ç¤ºæœ‰æ–°äººåŠ å…¥æ’é˜Ÿï¼Œå°†è¯¥äººçš„ä¿¡æ¯åŠ å…¥é˜Ÿåˆ—ã€‚ åœ¨ä¸€ç³»åˆ—æ“ä½œä¹‹åï¼Œä½ éœ€è¦å›ç­”ï¼šä¸‹ä¸€ä¸ªå–å¥¶èŒ¶çš„äººæ˜¯è°ï¼Ÿ ç¬¬ä¸€è¡Œæœ‰ä¸€ä¸ªæ•´æ•° nï¼Œä»£è¡¨åˆå§‹é˜Ÿåˆ—æœ‰ n ä¸ªäººã€‚ ç¬¬äºŒè¡Œæœ‰ n ä¸ªå­—ç¬¦ä¸²ï¼Œä»£è¡¨å½“å‰å¥¶èŒ¶é˜Ÿåˆ—ä¸­çš„äººã€‚ ç¬¬ä¸‰è¡Œä¸ºä¸€ä¸ªæ•´æ•° mï¼Œä»£è¡¨æ¥ä¸‹æ¥å°†ä¼šæœ‰ m æ¬¡æ“ä½œã€‚ æ¥ä¸‹æ¥ä¸€å…±æœ‰ m è¡Œï¼Œä»£è¡¨å…±æœ‰ m æ¬¡æ“ä½œã€‚ å¦‚æœæ˜¯æ“ä½œ 1ï¼Œé‚£ä¹ˆè¯¥è¡Œåªä¼šæœ‰ä¸€ä¸ªæ•°å­—ï¼Œä»£è¡¨æœ‰äººå–èµ°äº†å¥¶èŒ¶ã€‚å¦‚æœæ˜¯æ“ä½œ 2ï¼Œé‚£ä¹ˆè¯¥è¡Œæœ‰ä¸€ä¸ªæ•°å­—å’Œä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç¬¬ä¸€ä¸ªæ•°å­— 2 è¡¨ç¤ºæœ‰äººåŠ å…¥äº†å¥¶èŒ¶é˜Ÿåˆ—ï¼Œç¬¬äºŒä¸ªå­—ç¬¦ä¸²ä»£è¡¨æ–°åŠ å…¥çš„å¥¶èŒ¶é˜Ÿåˆ—çš„äººã€‚ è¾“å‡ºåªæœ‰ä¸€è¡Œï¼Œä¸ºä¸‹ä¸€ä¸ªå–å¥¶èŒ¶çš„äººã€‚ å¦‚æœå·²ç»æ²¡æœ‰å»å¥¶èŒ¶çš„äººäº†ï¼Œè¾“å‡ºâ€œThere are no more people in the queue.â€ã€‚ #include &lt;iostream> #include &lt;queue> #include &lt;string> using namespace std; int main()&#123; int origin_num; cin >> origin_num; // queue setup string name; queue &lt;string> milktea_queue; while (origin_num --)&#123; cin >> name; milktea_queue.push(name); &#125; // queue operation int opera_num, operation; cin >> opera_num; while(opera_num --)&#123; cin >> operation; if (operation == 1 &amp;&amp; !milktea_queue.empty()) milktea_queue.pop(); if (operation == 2) &#123; cin >> name; milktea_queue.push(name); &#125; &#125; // output if(milktea_queue.empty()) cout &lt;&lt; \"There are no more people in the queue.\" &lt;&lt; endl; else cout &lt;&lt; milktea_queue.front() &lt;&lt; endl; &#125; 5.3 æœ‰æ•ˆçš„æ‹¬å·ç»™å®šä¸€ä¸ªåªåŒ…æ‹¬ &#39;(&#39;ï¼Œ&#39;)&#39;ï¼Œ&#39;&#123;&#39;ï¼Œ&#39;&#125;&#39;ï¼Œ&#39;[&#39;ï¼Œ&#39;]&#39; çš„å­—ç¬¦ä¸² s ï¼Œåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆã€‚ æœ‰æ•ˆå­—ç¬¦ä¸²éœ€æ»¡è¶³ï¼š å·¦æ‹¬å·å¿…é¡»ç”¨ç›¸åŒç±»å‹çš„å³æ‹¬å·é—­åˆã€‚ å·¦æ‹¬å·å¿…é¡»ä»¥æ­£ç¡®çš„é¡ºåºé—­åˆã€‚ æ¯ä¸ªå³æ‹¬å·éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ç›¸åŒç±»å‹çš„å·¦æ‹¬å·ã€‚ class Solution &#123; public: bool isValid(string s) &#123; stack&lt;char> left; for (char item : s)&#123; if (item == '(' || item == '[' || item == '&#123;')&#123; left.push(item); &#125; else if (!left.empty() &amp;&amp; left.top() == leftreturn(item))&#123; left.pop(); &#125; else return false; &#125; return left.empty(); &#125; char leftreturn (char right)&#123; if(right == ')') return '('; if(right == '&#125;') return '&#123;'; if(right == ']') return '['; return false; &#125; &#125;; 5.4 ä¹°ç¥¨éœ€è¦çš„æ—¶é—´æœ‰ n ä¸ªäººå‰æ¥æ’é˜Ÿä¹°ç¥¨ï¼Œå…¶ä¸­ç¬¬ 0 äººç«™åœ¨é˜Ÿä¼ æœ€å‰æ–¹ ï¼Œç¬¬ (n - 1) äººç«™åœ¨é˜Ÿä¼ æœ€åæ–¹ ã€‚ ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» 0 å¼€å§‹çš„æ•´æ•°æ•°ç»„ tickets ï¼Œæ•°ç»„é•¿åº¦ä¸º n ï¼Œå…¶ä¸­ç¬¬ i äººæƒ³è¦è´­ä¹°çš„ç¥¨æ•°ä¸º tickets[i] ã€‚ æ¯ä¸ªäººä¹°ç¥¨éƒ½éœ€è¦ç”¨æ‰ æ°å¥½ 1 ç§’ ã€‚ä¸€ä¸ªäºº ä¸€æ¬¡åªèƒ½ä¹°ä¸€å¼ ç¥¨ ï¼Œå¦‚æœéœ€è¦è´­ä¹°æ›´å¤šç¥¨ï¼Œä»–å¿…é¡»èµ°åˆ° é˜Ÿå°¾ é‡æ–°æ’é˜Ÿï¼ˆç¬é—´ å‘ç”Ÿï¼Œä¸è®¡æ—¶é—´ï¼‰ã€‚å¦‚æœä¸€ä¸ªäººæ²¡æœ‰å‰©ä¸‹éœ€è¦ä¹°çš„ç¥¨ï¼Œé‚£ä»–å°†ä¼š ç¦»å¼€ é˜Ÿä¼ã€‚ è¿”å›ä½äºä½ç½® kï¼ˆä¸‹æ ‡ä» 0 å¼€å§‹ï¼‰çš„äººå®Œæˆä¹°ç¥¨éœ€è¦çš„æ—¶é—´ï¼ˆä»¥ç§’ä¸ºå•ä½ï¼‰ã€‚ class Solution &#123; public: int timeRequiredToBuy(vector&lt;int>&amp; tickets, int k) &#123; int n = tickets.size(); vector&lt;int> time(n); queue&lt;int> line; int timecost = 0; // åˆå§‹åŒ–é˜Ÿåˆ—ï¼Œå­˜å‚¨æ¯ä¸ªäººçš„ç¼–å· id for(int i = 0; i &lt; n; i++)&#123; line.push(i); &#125; while(line.size())&#123; if (tickets[line.front()] > 1)&#123; timecost ++; tickets[line.front()]--; line.push(line.front()); line.pop(); &#125; else if (tickets[line.front()] == 1)&#123; timecost ++; time[line.front()] = timecost; line.pop(); &#125; &#125; return time[k]; &#125; &#125;; 5.5 ç”¨æ ˆå®ç°é˜Ÿåˆ—è¯·ä½ ä»…ä½¿ç”¨ä¸¤ä¸ªæ ˆå®ç°å…ˆå…¥å…ˆå‡ºé˜Ÿåˆ—ã€‚é˜Ÿåˆ—åº”å½“æ”¯æŒä¸€èˆ¬é˜Ÿåˆ—æ”¯æŒçš„æ‰€æœ‰æ“ä½œï¼ˆpushã€popã€peekã€emptyï¼‰ï¼š å®ç° MyQueue ç±»ï¼š void push(int x) å°†å…ƒç´  x æ¨åˆ°é˜Ÿåˆ—çš„æœ«å°¾ int pop() ä»é˜Ÿåˆ—çš„å¼€å¤´ç§»é™¤å¹¶è¿”å›å…ƒç´  int peek() è¿”å›é˜Ÿåˆ—å¼€å¤´çš„å…ƒç´  boolean empty() å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false è¯´æ˜ï¼š ä½  åªèƒ½ ä½¿ç”¨æ ‡å‡†çš„æ ˆæ“ä½œ â€”â€” ä¹Ÿå°±æ˜¯åªæœ‰ push to top, peek/pop from top, size, å’Œ is empty æ“ä½œæ˜¯åˆæ³•çš„ã€‚ ä½ æ‰€ä½¿ç”¨çš„è¯­è¨€ä¹Ÿè®¸ä¸æ”¯æŒæ ˆã€‚ä½ å¯ä»¥ä½¿ç”¨ list æˆ–è€… dequeï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰æ¥æ¨¡æ‹Ÿä¸€ä¸ªæ ˆï¼Œåªè¦æ˜¯æ ‡å‡†çš„æ ˆæ“ä½œå³å¯ã€‚ class MyQueue &#123; private: stack&lt;int> input; stack&lt;int> output; public: MyQueue() &#123; &#125; void push(int x) &#123; input.push(x); &#125; int pop() &#123; int temp; if(output.empty())&#123; while (!input.empty())&#123; temp = input.top(); input.pop(); output.push(temp); &#125; &#125; int result; result = output.top(); output.pop(); return result; &#125; int peek() &#123; int temp; if(output.empty())&#123; while (!input.empty())&#123; temp = input.top(); input.pop(); output.push(temp); &#125; &#125; int result; result = output.top(); return result; &#125; bool empty() &#123; return input.empty() &amp;&amp; output.empty(); &#125; &#125;; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->peek(); * bool param_4 = obj->empty(); */ 5.6 ç”¨é˜Ÿåˆ—å®ç°æ ˆè¯·ä½ ä»…ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—å®ç°ä¸€ä¸ªåå…¥å…ˆå‡ºï¼ˆLIFOï¼‰çš„æ ˆï¼Œå¹¶æ”¯æŒæ™®é€šæ ˆçš„å…¨éƒ¨å››ç§æ“ä½œï¼ˆpushã€topã€pop å’Œ emptyï¼‰ã€‚ å®ç° MyStack ç±»ï¼š void push(int x) å°†å…ƒç´  x å‹å…¥æ ˆé¡¶ã€‚ int pop() ç§»é™¤å¹¶è¿”å›æ ˆé¡¶å…ƒç´ ã€‚ int top() è¿”å›æ ˆé¡¶å…ƒç´ ã€‚ boolean empty() å¦‚æœæ ˆæ˜¯ç©ºçš„ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚ class MyStack &#123; public: queue&lt;int> input; queue&lt;int> output; MyStack() &#123; &#125; void push(int x) &#123; input.push(x); &#125; int pop() &#123; while(input.size() > 1)&#123; output.push(input.front()); input.pop(); &#125; int result = input.front(); input.pop(); while(!output.empty())&#123; input.push(output.front()); output.pop(); &#125; return result; &#125; int top() &#123; int temp = this->pop(); input.push(temp); return temp; &#125; bool empty() &#123; return input.empty(); &#125; &#125;; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->top(); * bool param_4 = obj->empty(); */ 5.7 åˆ é™¤å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰ç›¸é‚»é‡å¤é¡¹ç»™å‡ºç”±å°å†™å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸² sï¼Œé‡å¤é¡¹åˆ é™¤æ“ä½œä¼šé€‰æ‹©ä¸¤ä¸ªç›¸é‚»ä¸”ç›¸åŒçš„å­—æ¯ï¼Œå¹¶åˆ é™¤å®ƒä»¬ã€‚ åœ¨ s ä¸Šåå¤æ‰§è¡Œé‡å¤é¡¹åˆ é™¤æ“ä½œï¼Œç›´åˆ°æ— æ³•ç»§ç»­åˆ é™¤ã€‚ åœ¨å®Œæˆæ‰€æœ‰é‡å¤é¡¹åˆ é™¤æ“ä½œåè¿”å›æœ€ç»ˆçš„å­—ç¬¦ä¸²ã€‚ç­”æ¡ˆä¿è¯å”¯ä¸€ã€‚ class Solution &#123; public: string removeDuplicates(string s) &#123; stack&lt;char> lowercase; for (int i = 0; i &lt; s.size(); i++)&#123; if (i == 0) lowercase.push(s[i]); else&#123; if ((!lowercase.empty() &amp;&amp; s[i] != lowercase.top()) || lowercase.empty()) lowercase.push(s[i]); else lowercase.pop(); &#125; &#125; string result = \"\"; while (!lowercase.empty()) &#123; result += lowercase.top();// å°†æ ˆä¸­å…ƒç´ æ”¾åˆ°resultå­—ç¬¦ä¸²æ±‡æ€» lowercase.pop(); &#125; reverse (result.begin(), result.end()); // å­—ç¬¦ä¸²éœ€è¦åè½¬ä¸€ä¸‹ return result; &#125; &#125;; 5.8 é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ tokens ï¼Œè¡¨ç¤ºä¸€ä¸ªæ ¹æ® é€†æ³¢å…°è¡¨ç¤ºæ³• è¡¨ç¤ºçš„ç®—æœ¯è¡¨è¾¾å¼ã€‚ è¯·ä½ è®¡ç®—è¯¥è¡¨è¾¾å¼ã€‚è¿”å›ä¸€ä¸ªè¡¨ç¤ºè¡¨è¾¾å¼å€¼çš„æ•´æ•°ã€‚ æ³¨æ„ï¼š æœ‰æ•ˆçš„ç®—ç¬¦ä¸º &#39;+&#39;ã€&#39;-&#39;ã€&#39;*&#39; å’Œ &#39;/&#39; ã€‚ æ¯ä¸ªæ“ä½œæ•°ï¼ˆè¿ç®—å¯¹è±¡ï¼‰éƒ½å¯ä»¥æ˜¯ä¸€ä¸ªæ•´æ•°æˆ–è€…å¦ä¸€ä¸ªè¡¨è¾¾å¼ã€‚ ä¸¤ä¸ªæ•´æ•°ä¹‹é—´çš„é™¤æ³•æ€»æ˜¯ å‘é›¶æˆªæ–­ ã€‚ è¡¨è¾¾å¼ä¸­ä¸å«é™¤é›¶è¿ç®—ã€‚ è¾“å…¥æ˜¯ä¸€ä¸ªæ ¹æ®é€†æ³¢å…°è¡¨ç¤ºæ³•è¡¨ç¤ºçš„ç®—æœ¯è¡¨è¾¾å¼ã€‚ ç­”æ¡ˆåŠæ‰€æœ‰ä¸­é—´è®¡ç®—ç»“æœå¯ä»¥ç”¨ 32 ä½ æ•´æ•°è¡¨ç¤ºã€‚ class Solution &#123; public: int evalRPN(vector&lt;string>&amp; tokens) &#123; stack&lt;int> rpn; for(auto &amp;ch : tokens)&#123; if (ch == \"+\" || ch == \"-\" || ch == \"*\" || ch == \"/\") &#123; // ç¡®ä¿æ ˆä¸­è‡³å°‘æœ‰2ä¸ªå…ƒç´ æ‰èƒ½è¿›è¡Œè¿ç®— if (rpn.size() &lt; 2) return 0; int temp = rpn.top(); rpn.pop(); int first = rpn.top(); rpn.pop(); if (ch == \"+\") &#123; rpn.push(first + temp); &#125; else if (ch == \"-\") &#123; rpn.push(first - temp); &#125; else if (ch == \"*\") &#123; rpn.push(first * temp); &#125; else if (ch == \"/\") &#123; rpn.push(first / temp); &#125; &#125; else &#123; // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°å‹å…¥æ ˆ rpn.push(stoi(ch)); &#125; &#125; return rpn.top(); &#125; &#125;; 5.9 æ»‘åŠ¨çª—å£æœ€å¤§å€¼ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œæœ‰ä¸€ä¸ªå¤§å°ä¸º k çš„æ»‘åŠ¨çª—å£ä»æ•°ç»„çš„æœ€å·¦ä¾§ç§»åŠ¨åˆ°æ•°ç»„çš„æœ€å³ä¾§ã€‚ä½ åªå¯ä»¥çœ‹åˆ°åœ¨æ»‘åŠ¨çª—å£å†…çš„ k ä¸ªæ•°å­—ã€‚æ»‘åŠ¨çª—å£æ¯æ¬¡åªå‘å³ç§»åŠ¨ä¸€ä½ã€‚ è¿”å› æ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼ ã€‚ æš´åŠ›ï¼ˆåŠ›æ‰£è¶…æ—¶ï¼‰ï¼š class Solution &#123; public: vector&lt;int> maxSlidingWindow(vector&lt;int>&amp; nums, int k) &#123; int size = nums.size() - k + 1; if (size &lt;= 0) &#123; vector&lt;int> result; return result; &#125; else &#123; vector&lt;int> result; vector&lt;int> compare(k); for (int i = 0; i &lt; size; i++)&#123; for(int j = i; j &lt; i + k; j++)&#123; compare[j - i] = nums[j]; &#125; sort(compare.begin(), compare.end(),[](const int &amp;a, const int &amp;b)&#123; return a &lt; b; &#125;); result.push_back(compare[k-1]); &#125; return result; &#125; &#125; &#125;; queueå•å‘é˜Ÿåˆ—åšï¼ˆåŠ›æ‰£è¶…æ—¶ï¼‰ï¼š class Solution &#123; public: vector&lt;int> maxSlidingWindow(vector&lt;int>&amp; nums, int k) &#123; int size = nums.size() - k + 1; int max = nums[0]; queue&lt;int> Max; vector&lt;int> result; for (int i = 0 ; i &lt; size; i++)&#123; int window = i + k; int i0 = i; if (Max.empty()) Max.push(nums[0]); if (i > 0 &amp;&amp; nums[i - 1] == Max.front())&#123; Max.pop(); &#125; while (i0 &lt; window)&#123; if (nums[i0] >= Max.front())&#123; while (!Max.empty())&#123; Max.pop(); &#125; Max.push(nums[i0]); &#125; else Max.push(nums[i0]); i0++; &#125; result.push_back(Max.front()); &#125; return result; &#125; &#125;; dequeåŒå‘é˜Ÿåˆ—ï¼šå¯ä»æœ«å°¾åˆ é™¤ï¼Œæƒ³æ³•ä¸Šä¹Ÿæ›´åˆç† #include &lt;vector> #include &lt;deque> using namespace std; class Solution &#123; public: vector&lt;int> maxSlidingWindow(vector&lt;int>&amp; nums, int k) &#123; vector&lt;int> result; deque&lt;int> dq; // å­˜å‚¨ç´¢å¼• for (int i = 0; i &lt; nums.size(); ++i) &#123; // ç§»é™¤ç¦»å¼€çª—å£çš„å…ƒç´  while (!dq.empty() &amp;&amp; dq.front() &lt;= i - k) &#123; dq.pop_front(); &#125; // ä»é˜Ÿå°¾ç§»é™¤æ¯”å½“å‰å°çš„å…ƒç´  while (!dq.empty() &amp;&amp; nums[dq.back()] &lt; nums[i]) &#123; dq.pop_back(); &#125; // åŠ å…¥å½“å‰å…ƒç´ ç´¢å¼• dq.push_back(i); // çª—å£å½¢æˆåè®°å½•æœ€å¤§å€¼ if (i >= k - 1) &#123; result.push_back(nums[dq.front()]); &#125; &#125; return result; &#125; &#125;; 5.10 å‰Kä¸ªé«˜é¢‘å…ƒç´ ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° k ï¼Œè¯·ä½ è¿”å›å…¶ä¸­å‡ºç°é¢‘ç‡å‰ k é«˜çš„å…ƒç´ ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚ class Solution &#123; public: vector&lt;int> topKFrequent(vector&lt;int>&amp; nums, int k) &#123; unordered_map&lt;int,int> count(0); for (int i = 0; i &lt; nums.size(); i++)&#123; count[nums[i]] ++; &#125; // è½¬æ¢ä¸ºvector vector&lt;pair&lt;int, int>> freqVec(count.begin(), count.end()); //lambdaè¡¨è¾¾å¼ sort(freqVec.begin(), freqVec.end(), [](const pair&lt;int, int>&amp; a, const pair&lt;int, int>&amp; b) &#123; return a.second > b.second; &#125;); // æå–å‰ k ä¸ªé«˜é¢‘å…ƒç´  vector&lt;int> result; for (int i = 0; i &lt; k &amp;&amp; i &lt; freqVec.size(); i++) &#123; result.push_back(freqVec[i].first); &#125; return result; &#125; &#125;; &nbsp; 6. ç±»ä¸OOPåº”ç”¨6.1 å›¾å½¢é¢ç§¯è€ƒè™‘ä¸€ä¸ªç®€å•çš„å›¾å½¢ç±»å±‚æ¬¡ç»“æ„ï¼ŒåŒ…æ‹¬åŸºç±» Shape å’Œä¸¤ä¸ªæ´¾ç”Ÿç±» Rectangle å’Œ Circleã€‚æ¯ä¸ªç±»éƒ½æœ‰ä¸€ä¸ªç”¨äºè®¡ç®—é¢ç§¯çš„æ–¹æ³•ã€‚ä½ çš„ä»»åŠ¡æ˜¯ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œæ ¹æ®è¾“å…¥æ•°æ®åˆ›å»ºä¸€ä¸ªå›¾å½¢å¯¹è±¡ï¼Œç„¶åè®¡ç®—å¹¶è¾“å‡ºå…¶é¢ç§¯ã€‚ è¾“å…¥åŒ…æ‹¬å¤šè¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªå›¾å½¢çš„æè¿°ã€‚ æè¿°çš„ç¬¬ä¸€ä¸ªå•è¯æ˜¯å›¾å½¢ç±»å‹ï¼ˆâ€rectangleâ€æˆ–â€circleâ€ï¼‰ï¼Œç„¶åæ˜¯ä¸è¯¥å›¾å½¢ç›¸å…³çš„å‚æ•°ã€‚ å¯¹äºçŸ©å½¢ï¼Œå‚æ•°æ˜¯å®½åº¦å’Œé«˜åº¦ï¼Œå¯¹äºåœ†å½¢ï¼Œå‚æ•°æ˜¯åŠå¾„ã€‚è¾“å…¥ä»¥å•è¯â€endâ€ç»“æŸã€‚ å¯¹äºæ¯ä¸ªå›¾å½¢æè¿°ï¼Œè¾“å‡ºå…¶ç±»å‹å’Œé¢ç§¯ã€‚ä½¿ç”¨ä¸¤ä½å°æ•°ç‚¹ç²¾åº¦è¾“å‡ºé¢ç§¯ã€‚ #include &lt;iomanip> #include &lt;iostream> #include &lt;string> #include &lt;vector> using namespace std; class Shape &#123; public: // virtual function virtual double getArea() const = 0; virtual string getType() const = 0; &#125;; // Class Circle class Circle : public Shape &#123; public: Circle(int r) : radius(r) &#123;&#125; // f1 string getType() const override &#123; return \"Circle\"; &#125; // f2 double getArea() const override &#123; return 3.14 * radius * radius; &#125; private: int radius; &#125;; // Class Rectangle class Rectangle : public Shape &#123; public: Rectangle(int w, int h) : width(w), height(h) &#123;&#125; // f1 string getType() const override &#123; return \"Rectangle\"; &#125; // f2 double getArea() const override &#123; return static_cast&lt;double>(width * height); &#125; private: int width; int height; &#125;; int main() &#123; vector&lt;Shape *> shapes; while (true) &#123; string type; cin >> type; if (type == \"end\") break; if (type == \"circle\") &#123; int radius; cin >> radius; shapes.push_back(new Circle(radius)); &#125; else if (type == \"rectangle\") &#123; int width, height; cin >> width >> height; shapes.push_back(new Rectangle(width, height)); &#125; &#125; for (const Shape *shape : shapes) &#123; cout &lt;&lt; shape->getType() &lt;&lt; \" area: \" &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; shape->getArea() &lt;&lt; endl; &#125; return 0; &#125; &nbsp; 7. äºŒå‰æ ‘7.1 äºŒå‰æ ‘çš„é€’å½’éå†ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å› å®ƒçš„ å‰ä¸­ååº éå† ã€‚ /** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */ class Solution &#123; public: //å‰åºéå† void presearch(TreeNode* cur, vector&lt;int> &amp;val)&#123; if (cur == NULL) return; val.push_back(cur->val); presearch(cur->left,val); presearch(cur->right,val); &#125; //ä¸­åºéå† void middlesearch(TreeNode *cur, vector&lt;int> &amp;val)&#123; if (cur == NULL) return; middlesearch(cur->left, val); val.push_back(cur->val); middlesearch(cur->right, val); &#125; //ååºéå† void backsearch(TreeNode *cur, vector&lt;int> &amp;val)&#123; if (cur == NULL) return; backsearch(cur->left, val); backsearch(cur->right,val); val.push_back(cur->val); &#125; vector&lt;int> inorderTraversal(TreeNode* root) &#123; vector&lt;int> result; middlesearch(root, result); return result; &#125; &#125;; 7.2 äºŒå‰æ ‘çš„è¿­ä»£éå†ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å› å®ƒçš„ å‰ä¸­ååº éå† ã€‚ /** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */ class Solution &#123; public: //å‰åºéå† void presearch(TreeNode* root, vector&lt;int> &amp;val)&#123; stack&lt;TreeNode*> st; if (root == NULL) return; st.push(root); while (!st.empty())&#123; TreeNode* head = st.top(); st.pop(); val.push_back(head->val); if (head->right) st.push(head->right); if (head->left) st.push(head->left); &#125; &#125; //ä¸­åºéå† void middlesearch(TreeNode* root, vector&lt;int> &amp;val)&#123; stack&lt;TreeNode*> st; if (root == NULL) return; TreeNode* cur = root; while ( !st.empty() || cur != NULL)&#123; if (cur != NULL) &#123; st.push(cur); cur = cur->left; &#125; else &#123; cur = st.top(); st.pop(); val.push_back(cur->val); cur = cur->right; &#125; &#125; &#125; //ååºéå† void backsearch(TreeNode *head, vector&lt;int> &amp;val)&#123; stack&lt;TreeNode*> st; if (head == NULL) return; // å¦‚æœå§‹ç»ˆæ²¡æœ‰æ‰“å°è¿‡èŠ‚ç‚¹ï¼Œheadå°±ä¸€ç›´æ˜¯å¤´èŠ‚ç‚¹ // ä¸€æ—¦æ‰“å°è¿‡èŠ‚ç‚¹ï¼Œheadå°±å˜æˆæ‰“å°èŠ‚ç‚¹ // ä¹‹åheadï¼šä¸Šä¸€æ¬¡æ‰“å°å®Œçš„èŠ‚ç‚¹ st.push(head); TreeNode* cur; while ( !st.empty())&#123; cur = st.top(); //æœ‰å·¦æ ‘ ä¸”å·¦æ ‘æ²¡å¤„ç†è¿‡ if (cur->left != NULL &amp;&amp; head != cur->left &amp;&amp; head != cur->right)&#123; st.push(cur->left); &#125; //æœ‰å³æ ‘ ä¸”å³æ ‘æ²¡å¤„ç†è¿‡ else if (cur->right != NULL &amp;&amp; head != cur->right)&#123; st.push(cur->right); &#125; //å·¦æ ‘ å³æ ‘ éƒ½ä¸ºNULL æˆ–éƒ½å¤„ç†è¿‡äº† else &#123; head = st.top(); val.push_back(st.top()->val); st.pop(); &#125; &#125; &#125; vector&lt;int> preorderTraversal(TreeNode* root) &#123; vector&lt;int> result; presearch(root , result); return result; &#125; &#125;; 7.3 äºŒå‰æ ‘çš„å±‚åºéå†ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ å±‚åºéå† ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚ /** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */ class Solution &#123; public: vector&lt;vector&lt;int>> levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int>> result; queue&lt;TreeNode*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); vector&lt;int> layer; for (int i = 0; i &lt; size; i++)&#123; TreeNode* cur = que.front(); que.pop(); layer.push_back(cur->val); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); &#125; result.push_back(layer); &#125; // å¦‚æœè¦ä»åº•å±‚å¼€å§‹ï¼Œç¿»è½¬ä¸€ä¸‹å°±è¡Œ // reverse(result.begin(), result.end()); return result; &#125; &#125;; 7.4 äºŒå‰æ ‘çš„å³è§†å›¾ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ æ ¹èŠ‚ç‚¹ rootï¼Œæƒ³è±¡è‡ªå·±ç«™åœ¨å®ƒçš„å³ä¾§ï¼ŒæŒ‰ç…§ä»é¡¶éƒ¨åˆ°åº•éƒ¨çš„é¡ºåºï¼Œè¿”å›ä»å³ä¾§æ‰€èƒ½çœ‹åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ *å³è¿›è¡Œå±‚åºéå†æ—¶åˆ¤æ–­å½“å‰æ˜¯å¦ä¸ºè¯¥å±‚æœ€åä¸€ä¸ªå…ƒç´  class Solution &#123; public: vector&lt;int> rightSideView(TreeNode* root) &#123; TreeNode* cur = root; vector&lt;int> result; queue&lt;TreeNode*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); for (int i = 0; i &lt; size; i++)&#123; cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); if (i == (size - 1)) result.push_back(cur->val); &#125; &#125; return result; &#125; &#125;; 7.5 äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼ç»™å®šä¸€ä¸ªéç©ºäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root , ä»¥æ•°ç»„çš„å½¢å¼è¿”å›æ¯ä¸€å±‚èŠ‚ç‚¹çš„å¹³å‡å€¼ã€‚ä¸å®é™…ç­”æ¡ˆç›¸å·® 10-5 ä»¥å†…çš„ç­”æ¡ˆå¯ä»¥è¢«æ¥å—ã€‚ class Solution &#123; public: vector&lt;double> averageOfLevels(TreeNode* root) &#123; vector&lt;double> result; queue&lt;TreeNode*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); int count = 0; double sum = 0; for (int i = 0; i &lt; size; i++)&#123; TreeNode* cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); sum += cur->val; count++; &#125; result.push_back(sum/count); &#125; return result; &#125; &#125;; 7.6 Nå‰æ ‘çš„å±‚åºéå†ç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„å±‚åºéå†ã€‚ï¼ˆå³ä»å·¦åˆ°å³ï¼Œé€å±‚éå†ï¼‰ã€‚ æ ‘çš„åºåˆ—åŒ–è¾“å…¥æ˜¯ç”¨å±‚åºéå†ï¼Œæ¯ç»„å­èŠ‚ç‚¹éƒ½ç”± null å€¼åˆ†éš”ã€‚ /* // Definition for a Node. class Node &#123; public: int val; vector&lt;Node*> children; Node() &#123;&#125; Node(int _val) &#123; val = _val; &#125; Node(int _val, vector&lt;Node*> _children) &#123; val = _val; children = _children; &#125; &#125;; */ class Solution &#123; public: vector&lt;vector&lt;int>> levelOrder(Node* root) &#123; vector&lt;vector&lt;int>> result; queue&lt;Node*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); vector&lt;int> local; for (int i = 0; i &lt; size; i++)&#123; Node* cur = que.front(); for (auto &amp;ch : cur->children)&#123; if (ch)&#123; que.push(ch); &#125; &#125; que.pop(); local.push_back(cur->val); &#125; result.push_back(local); &#125; return result; &#125; &#125;; 7.7 åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼ç»™å®šä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¯·æ‰¾å‡ºè¯¥äºŒå‰æ ‘ä¸­æ¯ä¸€å±‚çš„æœ€å¤§å€¼ã€‚ class Solution &#123; public: vector&lt;int> largestValues(TreeNode* root) &#123; vector&lt;int> max; queue&lt;TreeNode*> que; if (root) que.push(root); while (!que.empty())&#123; int max_num = INT_MIN; int size = que.size(); for(int i = 0; i &lt; size; i++)&#123; TreeNode* cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); if (cur->val >= max_num) max_num = cur->val; &#125; max.push_back(max_num); &#125; return max; &#125; &#125;; 7.8 å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼š struct Node &#123; int val; Node *left; Node *right; Node *next; &#125; å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º NULL ã€‚ åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰ next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º NULL ã€‚ /* // Definition for a Node. class Node &#123; public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125; Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125; Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) &#123;&#125; &#125;; */ class Solution &#123; public: Node* connect(Node* root) &#123; queue&lt;Node*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); for (int i = 0; i &lt; size; i++)&#123; Node* cur = que.front(); que.pop(); if (i == size-1) cur->next = NULL; else cur->next = que.front(); if(cur->left) que.push(cur->left); if(cur->right) que.push(cur->right); &#125; &#125; return root; &#125; &#125;; 7.9 äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ root ï¼Œè¿”å›å…¶æœ€å¤§æ·±åº¦ã€‚ äºŒå‰æ ‘çš„ æœ€å¤§æ·±åº¦ æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚ è¿­ä»£å†™æ³•ï¼š class Solution &#123; public: int maxDepth(TreeNode* root) &#123; int depth = 0; queue&lt;TreeNode*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); for (int i = 0 ; i &lt; size; i++)&#123; TreeNode* cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); &#125; depth++; &#125; return depth; &#125; &#125;; é€’å½’å†™æ³•ï¼š class Solution &#123; public: int checkdepth(TreeNode* root)&#123; if (root == NULL)&#123; return 0; &#125; else&#123; int leftdepth = 0; int rightdepth = 0; if (root->left != NULL) leftdepth = checkdepth(root->left) + 1; if (root->right != NULL) rightdepth = checkdepth(root->right) + 1; if (root->left == NULL &amp;&amp; root->right == NULL) return 1; return max(leftdepth, rightdepth); &#125; &#125; int maxDepth(TreeNode* root) &#123; int depth = 0; depth = checkdepth(root); return depth; &#125; &#125;; 7.10 äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚ æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚ è¯´æ˜ï¼šå¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚ è¿­ä»£å†™æ³•ï¼š class Solution &#123; public: int minDepth(TreeNode* root) &#123; int depth = 0; queue&lt;TreeNode*> que; if (root) que.push(root); while (!que.empty())&#123; int size = que.size(); for (int i = 0 ; i &lt; size; i++)&#123; TreeNode* cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); if (!cur->left &amp;&amp; !cur->right)&#123; depth++; return depth; &#125; &#125; depth++; &#125; return depth; &#125; &#125;; é€’å½’å†™æ³•ï¼š class Solution &#123; public: int checkdepth(TreeNode* root)&#123; if (root == NULL)&#123; return 0; &#125; else&#123; if (root->left == NULL &amp;&amp; root->right == NULL) return 1; int leftdepth = INT_MAX; int rightdepth = INT_MAX; if (root->left != NULL ) leftdepth = checkdepth(root->left) + 1; if (root->right != NULL) rightdepth = checkdepth(root->right) + 1; return min(leftdepth, rightdepth); &#125; &#125; int minDepth(TreeNode* root) &#123; int depth = 0; depth = checkdepth(root); return depth; &#125; &#125;; 7.11 ç¿»è½¬äºŒå‰æ ‘ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œç¿»è½¬è¿™æ£µäºŒå‰æ ‘ï¼Œå¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚ class Solution &#123; public: void reverstreenode (TreeNode* cur)&#123; if (cur == NULL) return; reverstreenode(cur->left); reverstreenode(cur->right); TreeNode* temp; temp = cur->right; cur->right = cur->left; cur->left = temp; &#125; TreeNode* invertTree(TreeNode* root) &#123; reverstreenode(root); return root; &#125; &#125;; 7.12 å¯¹ç§°äºŒå‰æ ‘ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚ é€’å½’å†™æ³•ï¼š class Solution &#123; public: bool check(TreeNode* branch1, TreeNode* branch2)&#123; if (branch1 == NULL &amp;&amp; branch2 == NULL) return true; // é€’å½’é€€å‡ºæ¡ä»¶ else if (branch1 != NULL &amp;&amp; branch2 == NULL) return false; else if (branch1 == NULL &amp;&amp; branch2 != NULL) return false; else if (branch1 != NULL &amp;&amp; branch2 != NULL) &#123; if (branch1->val != branch2->val) return false; &#125; return (check(branch1->left, branch2->right) &amp;&amp; (check(branch1->right, branch2->left))); &#125; bool isSymmetric(TreeNode* root) &#123; if (root == NULL) return false; return check(root->left, root->right); &#125; &#125;; è¿­ä»£å†™æ³•ï¼š class Solution &#123; public: bool isSymmetric(TreeNode* root) &#123; stack&lt;TreeNode*> st; if (root == NULL) return false; else if (root->left == NULL &amp;&amp; root->right == NULL) return true; else if (root->left != NULL &amp;&amp; root->right == NULL) return false; else if (root->left == NULL &amp;&amp; root->right != NULL) return false; else &#123; st.push(root->left); st.push(root->right); &#125; while (!st.empty())&#123; TreeNode* cur1 = st.top(); st.pop(); TreeNode* cur2 = st.top(); st.pop(); if (cur1->left == NULL &amp;&amp; cur2->right != NULL) return false; if (cur1->left != NULL &amp;&amp; cur2->right == NULL) return false; if (cur1->right == NULL &amp;&amp; cur2->left != NULL) return false; if (cur1->right != NULL &amp;&amp; cur2->left == NULL) return false; if (cur1->val != cur2->val) &#123; return false; &#125; if (cur1->left) st.push(cur1->left); if (cur2->right) st.push(cur2->right); if (cur1->right) st.push(cur1->right); if (cur2->left) st.push(cur2->left); &#125; return true; &#125; &#125;; 7.13 å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ç»™ä½ ä¸€æ£µ å®Œå…¨äºŒå‰æ ‘ çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ±‚å‡ºè¯¥æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚ å®Œå…¨äºŒå‰æ ‘ çš„å®šä¹‰å¦‚ä¸‹ï¼šåœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚èŠ‚ç‚¹å¯èƒ½æ²¡å¡«æ»¡å¤–ï¼Œå…¶ä½™æ¯å±‚èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼Œå¹¶ä¸”æœ€ä¸‹é¢ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é›†ä¸­åœ¨è¯¥å±‚æœ€å·¦è¾¹çš„è‹¥å¹²ä½ç½®ã€‚è‹¥æœ€åº•å±‚ä¸ºç¬¬ h å±‚ï¼ˆä»ç¬¬ 0 å±‚å¼€å§‹ï¼‰ï¼Œåˆ™è¯¥å±‚åŒ…å« 1~ 2h ä¸ªèŠ‚ç‚¹ã€‚ class Solution &#123; public: int countNodes(TreeNode* root) &#123; int count = 0; if (root == NULL) return 0; queue&lt;TreeNode*> que; que.push(root); while (!que.empty())&#123; int size = que.size(); TreeNode* cur; for (int i = 0; i &lt; size; i++)&#123; cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); count++; &#125; &#125; return count; &#125; &#125;; 7.14 å¹³è¡¡äºŒå‰æ ‘ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯ å¹³è¡¡äºŒå‰æ ‘ ï¼ˆ æ˜¯æŒ‡è¯¥æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„é«˜åº¦ç›¸å·®ä¸è¶…è¿‡ 1ã€‚ï¼‰ class Solution &#123; public: int height (TreeNode* root)&#123; int count = 0; if (root == NULL) return 0; else &#123; int leftdepth = 0; int rightdepth = 0; if (root->left != NULL) leftdepth = height(root->left); if (root->right != NULL) rightdepth = height(root->right); if (root->left == NULL &amp;&amp; root->right == NULL) return 1; return max(leftdepth, rightdepth) + 1; &#125; &#125; bool isBalanced(TreeNode* root) &#123; if (root == NULL) return true; queue&lt;TreeNode*> que; que.push(root); while (!que.empty())&#123; int size = que.size(); TreeNode* cur; for (int i = 0; i &lt; size; i++)&#123; cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); if (height(cur->left) > height(cur->right))&#123; if (height(cur->left) - height(cur->right) > 1) return false; &#125; if (height(cur->left) &lt; height(cur->right))&#123; if (height(cur->right) - height(cur->left) > 1) return false; &#125; &#125; &#125; return true; &#125; &#125;; 7.15 å·¦å¶å­ä¹‹å’Œç»™å®šäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›æ‰€æœ‰å·¦å¶å­ä¹‹å’Œã€‚ class Solution &#123; public: int sumOfLeftLeaves(TreeNode* root) &#123; if (root == NULL) return 0; int sum = 0; queue&lt;TreeNode*> que; que.push(root); while (!que.empty())&#123; int size = que.size(); TreeNode* cur; for (int i = 0; i &lt; size; i++)&#123; cur = que.front(); que.pop(); if (cur->left) &#123; if (cur->left->left == NULL &amp;&amp; cur->left->right == NULL) sum += cur->left->val; que.push(cur->left); &#125; if (cur->right) que.push(cur->right); &#125; &#125; return sum; &#125; &#125;; 7.16 äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼ŒæŒ‰ ä»»æ„é¡ºåº ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚ å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚ *å›æº¯æ€æƒ³ class Solution &#123; public: void travelback(TreeNode* root, vector&lt;int> &amp;path, vector&lt;string> &amp;result)&#123; path.push_back(root->val); //ç»ˆæ­¢æ¡ä»¶ if (root->left == NULL &amp;&amp; root->right == NULL)&#123; string str; for (auto ch : path)&#123; str += to_string(ch); str += \"->\"; &#125; str.pop_back(); str.pop_back(); result.push_back(str); return; &#125; if (root->left != NULL)&#123; travelback(root->left, path, result); path.pop_back(); // å›æº¯ &#125; if (root->right != NULL)&#123; travelback(root->right, path, result); path.pop_back(); // å›æº¯ &#125; &#125; vector&lt;string> binaryTreePaths(TreeNode* root) &#123; vector&lt;string> result; vector&lt;int> path; if (root == NULL) return result; travelback(root, path, result); return result; &#125; &#125;; 7.17 æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ æ ¹èŠ‚ç‚¹ rootï¼Œè¯·æ‰¾å‡ºè¯¥äºŒå‰æ ‘çš„ æœ€åº•å±‚ æœ€å·¦è¾¹ èŠ‚ç‚¹çš„å€¼ã€‚ å‡è®¾äºŒå‰æ ‘ä¸­è‡³å°‘æœ‰ä¸€ä¸ªèŠ‚ç‚¹ã€‚ class Solution &#123; public: int findBottomLeftValue(TreeNode* root) &#123; int result = 0; queue&lt;TreeNode*> que; // if (root == NULL) return -1; que.push(root); while (!que.empty())&#123; int size = que.size(); TreeNode* cur; for (int i = 0; i &lt; size; i++)&#123; cur = que.front(); que.pop(); if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); if ( i == 0) result = cur->val; &#125; &#125; return result; &#125; &#125;; 7.18 è·¯å¾„æ€»å’Œç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•° targetSum ã€‚åˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’Œ targetSum ã€‚å¦‚æœå­˜åœ¨ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚ å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚ class Solution &#123; public: void sumcheck(TreeNode* root , int &amp;sum, int &amp;result, int &amp;calculate)&#123; calculate += root->val; if (root ->left == NULL &amp;&amp; root->right == NULL)&#123; if (calculate == sum) result += 1; &#125; if (root->left != NULL)&#123; sumcheck(root->left, sum, result,calculate); calculate -= root->left->val; &#125; if (root->right != NULL)&#123; sumcheck(root->right, sum, result,calculate); calculate -= root->right->val; &#125; &#125; bool hasPathSum(TreeNode* root, int targetSum) &#123; int result = 0; int calculate = 0; if (root == NULL) return false; sumcheck(root, targetSum, result, calculate); if (result) return true; else return false; &#125; &#125;; 7.19 ä»ä¸­åºå’Œååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ inorder å’Œ postorder ï¼Œå…¶ä¸­ inorder æ˜¯äºŒå‰æ ‘çš„ä¸­åºéå†ï¼Œ postorder æ˜¯åŒä¸€æ£µæ ‘çš„ååºéå†ï¼Œè¯·ä½ æ„é€ å¹¶è¿”å›è¿™é¢— äºŒå‰æ ‘ ã€‚ *é€’å½’ //é€‰æ‹©ç”¨ç´¢å¼•åº”è¯¥ä¼šæ›´å¥½ class Solution &#123; public: TreeNode* rebuild(vector&lt;int>&amp; inorder, vector&lt;int>&amp; postorder)&#123; if (postorder.size() == 0) return NULL; int rootvalue = postorder[postorder.size()-1]; TreeNode* root = new TreeNode(rootvalue); if (postorder.size() == 1) return root; vector&lt;int> newleftmiddle; vector&lt;int> newrightmiddle; vector&lt;int> newleftback; vector&lt;int> newrightback; int flag = 0; // å·¦é€’å½’å¤„ç† for (auto &amp;ch : inorder)&#123; if (ch != rootvalue &amp;&amp; flag == 0) newleftmiddle.push_back(ch); else if (ch == rootvalue &amp;&amp; flag == 0)&#123; flag = 1; &#125; else newrightmiddle.push_back(ch); &#125; // å³é€’å½’å¤„ç† for (int i = 0; i &lt; newleftmiddle.size(); i++)&#123; newleftback.push_back(postorder[i]); &#125; for (int i = newleftmiddle.size(); i &lt; postorder.size()-1; i++)&#123; newrightback.push_back(postorder[i]); &#125; root->left = rebuild(newleftmiddle, newleftback); root->right = rebuild(newrightmiddle, newrightback); return root; &#125; TreeNode* buildTree(vector&lt;int>&amp; inorder, vector&lt;int>&amp; postorder) &#123; return rebuild(inorder,postorder); &#125; &#125;; 7.20 æœ€å¤§äºŒå‰æ ‘ç»™å®šä¸€ä¸ªä¸é‡å¤çš„æ•´æ•°æ•°ç»„ nums ã€‚ æœ€å¤§äºŒå‰æ ‘ å¯ä»¥ç”¨ä¸‹é¢çš„ç®—æ³•ä» nums é€’å½’åœ°æ„å»º: åˆ›å»ºä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå…¶å€¼ä¸º nums ä¸­çš„æœ€å¤§å€¼ã€‚ é€’å½’åœ°åœ¨æœ€å¤§å€¼ å·¦è¾¹ çš„ å­æ•°ç»„å‰ç¼€ä¸Š æ„å»ºå·¦å­æ ‘ã€‚ é€’å½’åœ°åœ¨æœ€å¤§å€¼ å³è¾¹ çš„ å­æ•°ç»„åç¼€ä¸Š æ„å»ºå³å­æ ‘ã€‚ è¿”å› nums æ„å»ºçš„ æœ€å¤§äºŒå‰æ ‘\\ ã€‚ class Solution &#123; public: TreeNode* rebuild(vector&lt;int> &amp;nums)&#123; if (nums.size() == 0) return NULL; int max = INT_MIN; int maxindex = 0; for (int i = 0; i &lt; nums.size(); i++)&#123; if (nums[i] > max) &#123; max = nums[i]; maxindex = i; &#125; &#125; TreeNode* root = new TreeNode(max); vector&lt;int> leftnew(nums.begin(), nums.begin()+maxindex); vector&lt;int> rightnew(nums.begin()+maxindex+1, nums.end()); root->left = rebuild(leftnew); root->right = rebuild(rightnew); return root; &#125; TreeNode* constructMaximumBinaryTree(vector&lt;int>&amp; nums) &#123; return rebuild(nums); &#125; &#125;; 7.21 åˆå¹¶äºŒå‰æ ‘ç»™ä½ ä¸¤æ£µäºŒå‰æ ‘ï¼š root1 å’Œ root2 ã€‚ æƒ³è±¡ä¸€ä¸‹ï¼Œå½“ä½ å°†å…¶ä¸­ä¸€æ£µè¦†ç›–åˆ°å¦ä¸€æ£µä¹‹ä¸Šæ—¶ï¼Œä¸¤æ£µæ ‘ä¸Šçš„ä¸€äº›èŠ‚ç‚¹å°†ä¼šé‡å ï¼ˆè€Œå¦ä¸€äº›ä¸ä¼šï¼‰ã€‚ä½ éœ€è¦å°†è¿™ä¸¤æ£µæ ‘åˆå¹¶æˆä¸€æ£µæ–°äºŒå‰æ ‘ã€‚åˆå¹¶çš„è§„åˆ™æ˜¯ï¼šå¦‚æœä¸¤ä¸ªèŠ‚ç‚¹é‡å ï¼Œé‚£ä¹ˆå°†è¿™ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼ç›¸åŠ ä½œä¸ºåˆå¹¶åèŠ‚ç‚¹çš„æ–°å€¼ï¼›å¦åˆ™ï¼Œä¸ä¸º null çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹ã€‚ è¿”å›åˆå¹¶åçš„äºŒå‰æ ‘ã€‚ æ³¨æ„: åˆå¹¶è¿‡ç¨‹å¿…é¡»ä»ä¸¤ä¸ªæ ‘çš„æ ¹èŠ‚ç‚¹å¼€å§‹ã€‚ class Solution &#123; public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123; if (root1 == NULL &amp;&amp; root2 == NULL) return NULL; if (root1 == NULL &amp;&amp; root2 != NULL) return root2; if (root1 != NULL &amp;&amp; root2 == NULL) return root1; queue&lt;TreeNode*> que; que.push(root1); que.push(root2); while(!que.empty())&#123; TreeNode* cur1; TreeNode* cur2; cur1 = que.front(); que.pop(); cur2 = que.front(); que.pop(); cur1->val += cur2->val; if (cur1->left &amp;&amp; cur2->left) &#123; que.push(cur1->left); que.push(cur2->left); &#125; if (cur1->right &amp;&amp; cur2->right) &#123; que.push(cur1->right); que.push(cur2->right); &#125; if (!cur1->left &amp;&amp; cur2->left) &#123; cur1->left = cur2->left; &#125; if (!cur1->right &amp;&amp; cur2->right) &#123; cur1->right = cur2->right; &#125; &#125; return root1; &#125; &#125;; 7.22 äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢ç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªæ•´æ•°å€¼ valã€‚ ä½ éœ€è¦åœ¨ BST ä¸­æ‰¾åˆ°èŠ‚ç‚¹å€¼ç­‰äº val çš„èŠ‚ç‚¹ã€‚ è¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘ã€‚ å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› null ã€‚ äºŒå‰æœç´¢æ ‘æ˜¯ä¸€ä¸ªæœ‰åºæ ‘ï¼š è‹¥å®ƒçš„å·¦å­æ ‘ä¸ç©ºï¼Œåˆ™å·¦å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å°äºå®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼› è‹¥å®ƒçš„å³å­æ ‘ä¸ç©ºï¼Œåˆ™å³å­æ ‘ä¸Šæ‰€æœ‰ç»“ç‚¹çš„å€¼å‡å¤§äºå®ƒçš„æ ¹ç»“ç‚¹çš„å€¼ï¼› å®ƒçš„å·¦ã€å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¸ºäºŒå‰æœç´¢æ ‘ // å†™å¤æ‚äº†ï¼Œå…¶å®ä¸éœ€è¦é˜Ÿåˆ— class Solution &#123; public: TreeNode* searchBST(TreeNode* root, int val) &#123; if (root == NULL) return NULL; queue&lt;TreeNode*> que; que.push(root); TreeNode* resultnode; while (!que.empty())&#123; TreeNode* cur = que.front(); que.pop(); if (cur->val > val)&#123; if (cur->left) que.push(cur->left); else return NULL; &#125; else if (cur->val &lt; val)&#123; if (cur->right) que.push(cur->right); else return NULL; &#125; else &#123; resultnode = cur; break; &#125; &#125; return resultnode; &#125; &#125;; 7.23 éªŒè¯äºŒå‰æœç´¢æ ‘ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚ æœ‰æ•ˆ äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« ä¸¥æ ¼å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚ èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« ä¸¥æ ¼å¤§äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚ æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚ // åªéœ€è¦åˆ©ç”¨è¿™ä¸ªç‰¹æ€§ï¼šäºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†æ˜¯é€’å¢æ•°åˆ— class Solution &#123; public: bool isValidBST(TreeNode* root) &#123; stack&lt;TreeNode*> st; if (root == NULL) return true; TreeNode* cur = root; TreeNode* pre = NULL; while ( !st.empty() || cur != NULL)&#123; if (cur != NULL) &#123; st.push(cur); cur = cur->left; &#125; else &#123; cur = st.top(); st.pop(); if (pre != NULL &amp;&amp; cur->val &lt;= pre->val) return false; pre = cur; //ä¿å­˜å‰ä¸€ä¸ªè®¿é—®çš„ç»“ç‚¹ cur = cur->right; &#125; &#125; return true; &#125; &#125;; 7.24 äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®ç»™ä½ ä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å› æ ‘ä¸­ä»»æ„ä¸¤ä¸åŒèŠ‚ç‚¹å€¼ä¹‹é—´çš„æœ€å°å·®å€¼ ã€‚ å·®å€¼æ˜¯ä¸€ä¸ªæ­£æ•°ï¼Œå…¶æ•°å€¼ç­‰äºä¸¤å€¼ä¹‹å·®çš„ç»å¯¹å€¼ã€‚ // ä¸­åºéå† é€’å¢ class Solution &#123; public: int getMinimumDifference(TreeNode* root) &#123; // if (root == NULL) return 0; stack&lt;TreeNode*> st; TreeNode* cur = root; TreeNode* pre = NULL; int min = INT_MAX; while ( !st.empty() || cur != NULL)&#123; if (cur)&#123; st.push(cur); cur = cur->left; &#125; else &#123; cur = st.top(); st.pop(); //å¤„ç† if(pre != NULL)&#123; if ((cur->val) - (pre->val) &lt; min) min = (cur->val) - (pre->val); &#125; pre = cur; cur = cur ->right; &#125; &#125; return min; &#125; &#125;; 7.25 äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°ç»™ä½ ä¸€ä¸ªå«é‡å¤å€¼çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ‰¾å‡ºå¹¶è¿”å› BST ä¸­çš„ä¼—æ•°ï¼Œå³å‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ã€‚ å¦‚æœæ ‘ä¸­æœ‰ä¸æ­¢ä¸€ä¸ªä¼—æ•°ï¼Œå¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ã€‚ å‡å®š BST æ»¡è¶³å¦‚ä¸‹å®šä¹‰ï¼š ç»“ç‚¹å·¦å­æ ‘ä¸­æ‰€å«èŠ‚ç‚¹çš„å€¼ å°äºç­‰äº å½“å‰èŠ‚ç‚¹çš„å€¼ ç»“ç‚¹å³å­æ ‘ä¸­æ‰€å«èŠ‚ç‚¹çš„å€¼ å¤§äºç­‰äº å½“å‰èŠ‚ç‚¹çš„å€¼ å·¦å­æ ‘å’Œå³å­æ ‘éƒ½æ˜¯äºŒå‰æœç´¢æ ‘ class Solution &#123; private: void searchBST(TreeNode* root, vector&lt;int> &amp;result) &#123; if (root == NULL) return; stack&lt;TreeNode*> st; int maxcount = 0; int count = 0; TreeNode* cur = root; TreeNode* pre = NULL; while (!st.empty() || cur != NULL)&#123; if (cur)&#123; st.push(cur); cur = cur->left; &#125; else&#123; cur = st.top(); st.pop(); // é‡å¤å¤„ç†é€»è¾‘ if (pre == NULL) count = 1; else &#123; if (pre->val == cur->val)&#123; count ++; &#125; else count = 1; &#125; if (count == maxcount) result.push_back(cur->val); if (count > maxcount)&#123; maxcount = count; result.clear(); result.push_back(cur->val); &#125; pre = cur; cur = cur->right; &#125; &#125; &#125; public: vector&lt;int> findMode(TreeNode* root) &#123; vector&lt;int> result; searchBST(root, result); return result; &#125; &#125;; 7.26 äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚ æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€ // æœ‰ç‚¹éš¾åº¦ class Solution &#123; public: TreeNode* ancestorbackforth(TreeNode* root, TreeNode* p, TreeNode* q)&#123; if (root == NULL) return NULL; if (root == p || root == q) return root; TreeNode* left = ancestorbackforth(root->left, p , q); TreeNode* right = ancestorbackforth(root->right, p, q); if (left &amp;&amp; right) return root; else if (!left &amp;&amp; right) return right; else if (left &amp;&amp; !right) return left; else return NULL; &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; return ancestorbackforth(root, p, q); &#125; &#125;; 7.27 äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆç›¸æ¯”ä¸Šä¸€é¢˜éš¾åº¦é™ä½å¾ˆå¤šï¼Œåˆ©ç”¨æœ‰åºæ€§å°±è¡Œ class Solution &#123; public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == NULL) return NULL; TreeNode* cur = root; while (cur)&#123; if (cur->val > p->val &amp;&amp; cur->val > q->val) cur = cur->left; if (cur->val &lt; p->val &amp;&amp; cur->val &lt; q->val) cur = cur->right; else return cur; &#125; return NULL; &#125; &#125;; 7.28 å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå…¶ä¸­å…ƒç´ å·²ç»æŒ‰ å‡åº æ’åˆ—ï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºä¸€æ£µ å¹³è¡¡ äºŒå‰æœç´¢æ ‘ã€‚ï¼ˆæŒ‡è¯¥æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å·¦å³å­æ ‘çš„é«˜åº¦ç›¸å·®ä¸è¶…è¿‡ 1ã€‚ï¼‰ class Solution &#123; public: TreeNode* BSTbuild(vector&lt;int> &amp;nums)&#123; TreeNode* root = new TreeNode(0); int middleindex = 0; vector&lt;int> newleft; vector&lt;int> newright; if (nums.size() == 0) return NULL; else if (nums.size() % 2 == 1)&#123; middleindex = nums.size() / 2; root->val = nums[middleindex]; for (int i = 0; i &lt; middleindex; i++)&#123; newleft.push_back(nums[i]); &#125; for (int i = middleindex + 1; i &lt; nums.size(); i++)&#123; newright.push_back(nums[i]); &#125; &#125; else if (nums.size() % 2 == 0)&#123; middleindex = nums.size() / 2; root->val = nums[middleindex]; for (int i = 0; i &lt; middleindex; i++)&#123; newleft.push_back(nums[i]); &#125; for (int i = middleindex + 1; i &lt; nums.size(); i++)&#123; newright.push_back(nums[i]); &#125; &#125; root->left = BSTbuild(newleft); root->right = BSTbuild(newright); return root; &#125; TreeNode* sortedArrayToBST(vector&lt;int>&amp; nums) &#123; // é¢˜ç›®å¯ä»¥è½¬æ¢ä¸ºï¼šçŸ¥é“äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ï¼Œè¿˜åŸæ ‘ // å¾ˆå®¹æ˜“æƒ³åˆ°é€’å½’ return BSTbuild(nums); &#125; &#125;; 7.29 äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ root å’Œè¦æ’å…¥æ ‘ä¸­çš„å€¼ value ï¼Œå°†å€¼æ’å…¥äºŒå‰æœç´¢æ ‘ã€‚ è¿”å›æ’å…¥åäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ è¾“å…¥æ•°æ® ä¿è¯ ï¼Œæ–°å€¼å’ŒåŸå§‹äºŒå‰æœç´¢æ ‘ä¸­çš„ä»»æ„èŠ‚ç‚¹å€¼éƒ½ä¸åŒã€‚ æ³¨æ„ï¼Œå¯èƒ½å­˜åœ¨å¤šç§æœ‰æ•ˆçš„æ’å…¥æ–¹å¼ï¼Œåªè¦æ ‘åœ¨æ’å…¥åä»ä¿æŒä¸ºäºŒå‰æœç´¢æ ‘å³å¯ã€‚ ä½ å¯ä»¥è¿”å› ä»»æ„æœ‰æ•ˆçš„ç»“æœ ã€‚ class Solution &#123; public: TreeNode* insertIntoBST(TreeNode* root, int val) &#123; TreeNode* cur = new TreeNode(val); if (root == NULL) &#123; root = cur; return root; &#125; TreeNode* cur1 = root; TreeNode* pre = new TreeNode(0); while (cur1)&#123; if (cur1->val > val) &#123; pre = cur1; cur1 = cur1->left; &#125; else if (cur1->val &lt; val) &#123; pre = cur1; cur1 = cur1->right; &#125; &#125; if (pre->val &lt; val) pre->right = cur; if (pre->val > val) pre->left = cur; return root; &#125; &#125;; 7.30 ä¿®å‰ªäºŒå‰æœç´¢æ ‘ç»™ä½ äºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼ŒåŒæ—¶ç»™å®šæœ€å°è¾¹ç•Œlow å’Œæœ€å¤§è¾¹ç•Œ highã€‚é€šè¿‡ä¿®å‰ªäºŒå‰æœç´¢æ ‘ï¼Œä½¿å¾—æ‰€æœ‰èŠ‚ç‚¹çš„å€¼åœ¨[low, high]ä¸­ã€‚ä¿®å‰ªæ ‘ ä¸åº”è¯¥ æ”¹å˜ä¿ç•™åœ¨æ ‘ä¸­çš„å…ƒç´ çš„ç›¸å¯¹ç»“æ„ (å³ï¼Œå¦‚æœæ²¡æœ‰è¢«ç§»é™¤ï¼ŒåŸæœ‰çš„çˆ¶ä»£å­ä»£å…³ç³»éƒ½åº”å½“ä¿ç•™)ã€‚ å¯ä»¥è¯æ˜ï¼Œå­˜åœ¨ å”¯ä¸€çš„ç­”æ¡ˆ ã€‚ æ‰€ä»¥ç»“æœåº”å½“è¿”å›ä¿®å‰ªå¥½çš„äºŒå‰æœç´¢æ ‘çš„æ–°çš„æ ¹èŠ‚ç‚¹ã€‚æ³¨æ„ï¼Œæ ¹èŠ‚ç‚¹å¯èƒ½ä¼šæ ¹æ®ç»™å®šçš„è¾¹ç•Œå‘ç”Ÿæ”¹å˜ã€‚ class Solution &#123; public: TreeNode* trimBST(TreeNode* root, int L, int R) &#123; if (!root) return nullptr; // å¤„ç†å¤´ç»“ç‚¹ï¼Œè®©rootç§»åŠ¨åˆ°[L, R] èŒƒå›´å†…ï¼Œæ³¨æ„æ˜¯å·¦é—­å³é—­ while (root != nullptr &amp;&amp; (root->val &lt; L || root->val > R)) &#123; if (root->val &lt; L) root = root->right; // å°äºLå¾€å³èµ° else root = root->left; // å¤§äºRå¾€å·¦èµ° &#125; TreeNode *cur = root; // å·¦ä¾§ä¿®å‰ªæ‹¼æ¥ while (cur != nullptr) &#123; while (cur->left &amp;&amp; cur->left->val &lt; L) &#123; cur->left = cur->left->right; &#125; cur = cur->left; &#125; cur = root; // å³ä¾§ä¿®å‰ªæ‹¼æ¥ while (cur != nullptr) &#123; while (cur->right &amp;&amp; cur->right->val > R) &#123; cur->right = cur->right->left; &#125; cur = cur->right; &#125; return root; &#125; &#125;; 7.31 åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªå€¼ keyï¼Œåˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„ key å¯¹åº”çš„èŠ‚ç‚¹ï¼Œå¹¶ä¿è¯äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ä¸å˜ã€‚è¿”å›äºŒå‰æœç´¢æ ‘ï¼ˆæœ‰å¯èƒ½è¢«æ›´æ–°ï¼‰çš„æ ¹èŠ‚ç‚¹çš„å¼•ç”¨ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œåˆ é™¤èŠ‚ç‚¹å¯åˆ†ä¸ºä¸¤ä¸ªæ­¥éª¤ï¼š é¦–å…ˆæ‰¾åˆ°éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼› å¦‚æœæ‰¾åˆ°äº†ï¼Œåˆ é™¤å®ƒã€‚ // æ²¡æœ‰æƒ³è±¡ä¸­ç®€å•ï¼Œéœ€è¦æŠŠè¾¹ç•Œæ¡ä»¶ç†æ¸…æ¥š class Solution &#123; public: TreeNode* deleteNode(TreeNode* root, int key) &#123; if (root == NULL) return NULL; TreeNode* cur = root; TreeNode* pre = root; while (cur)&#123; if (cur->val > key) &#123; pre = cur; cur = cur -> left; &#125; else if (cur->val &lt; key) &#123; pre = cur; cur = cur -> right; &#125; else break; &#125; if (cur == NULL) return root; else &#123; if (key &lt; pre->val)&#123; if (cur -> right) &#123; TreeNode* newleft = cur ->right; while (newleft -> left)&#123; newleft = newleft ->left; &#125; newleft -> left = cur ->left; pre ->left = cur->right; &#125; else if (cur->left) pre ->left = cur->left; else pre->left = NULL; &#125; if (key > pre->val)&#123; if (cur -> left)&#123; TreeNode* newright = cur ->left; while (newright -> right)&#123; newright = newright ->right; &#125; newright->right = cur->right; pre ->right = cur->left; &#125; else if (cur->right) pre ->right = cur->right; else pre->right = NULL; &#125; if (key == pre->val)&#123; if (cur->left)&#123; TreeNode* newright = cur ->left; while (newright -> right)&#123; newright = newright ->right; &#125; newright->right = cur->right; root = cur->left; &#125; else if (cur->right) root = pre ->right; else &#123; root = NULL; &#125; &#125; &#125; return root; &#125; &#125;; 7.32 æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘ç»™å‡ºäºŒå‰ æœç´¢ æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¯¥æ ‘çš„èŠ‚ç‚¹å€¼å„ä¸ç›¸åŒï¼Œè¯·ä½ å°†å…¶è½¬æ¢ä¸ºç´¯åŠ æ ‘ï¼ˆGreater Sum Treeï¼‰ï¼Œä½¿æ¯ä¸ªèŠ‚ç‚¹ node çš„æ–°å€¼ç­‰äºåŸæ ‘ä¸­å¤§äºæˆ–ç­‰äº node.val çš„å€¼ä¹‹å’Œã€‚ æé†’ä¸€ä¸‹ï¼ŒäºŒå‰æœç´¢æ ‘æ»¡è¶³ä¸‹åˆ—çº¦æŸæ¡ä»¶ï¼š èŠ‚ç‚¹çš„å·¦å­æ ‘ä»…åŒ…å«é”® å°äº èŠ‚ç‚¹é”®çš„èŠ‚ç‚¹ã€‚ èŠ‚ç‚¹çš„å³å­æ ‘ä»…åŒ…å«é”® å¤§äº èŠ‚ç‚¹é”®çš„èŠ‚ç‚¹ã€‚ å·¦å³å­æ ‘ä¹Ÿå¿…é¡»æ˜¯äºŒå‰æœç´¢æ ‘ã€‚ class Solution &#123; public: //æ€è·¯ï¼šé¦–å…ˆéå†ä¸€ä¸‹å–å¾—æ‰€æœ‰èŠ‚ç‚¹å’Œï¼Œç„¶åä¸­åºéå†ä¾æ¬¡æŠŠå€¼æ¢æˆæ€»å’Œå‡å»å‰ä¸€ä¸ªèŠ‚ç‚¹å€¼ int getsum(TreeNode* root)&#123; if (root == NULL) return 0; int val1 = getsum(root -> left); int val2 = getsum(root -> right); return root->val + (val1 + val2); &#125; TreeNode* convertBST(TreeNode* root) &#123; int sum = getsum(root); if (root == NULL) return NULL; stack&lt;TreeNode*> st; TreeNode* cur = root; int presum = 0; while (!st.empty() || cur != NULL)&#123; if (cur)&#123; st.push(cur); cur = cur->left; &#125; else &#123; cur = st.top(); st.pop(); //è®¡ç®— presum += cur->val; cur ->val = sum -presum + cur->val; cur = cur ->right; &#125; &#125; return root; &#125; &#125;; &nbsp; 8. å›æº¯8.0 å›æº¯æ³•æ¨¡æ¿å‰ªææ—¶æ³¨æ„é€’å½’å¾ªç¯ä¸­çš„èµ·å§‹ä½ç½® void backtracking(å‚æ•°) &#123; if (ç»ˆæ­¢æ¡ä»¶) &#123; å­˜æ”¾ç»“æœ; return; &#125; for (é€‰æ‹©ï¼šæœ¬å±‚é›†åˆä¸­å…ƒç´ ï¼ˆæ ‘ä¸­èŠ‚ç‚¹å­©å­çš„æ•°é‡å°±æ˜¯é›†åˆçš„å¤§å°ï¼‰) &#123; å¤„ç†èŠ‚ç‚¹; backtracking(è·¯å¾„ï¼Œé€‰æ‹©åˆ—è¡¨); // é€’å½’ å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ &#125; &#125; 8.1 ç»„åˆç»™å®šä¸¤ä¸ªæ•´æ•° n å’Œ kï¼Œè¿”å›èŒƒå›´ [1, n] ä¸­æ‰€æœ‰å¯èƒ½çš„ k ä¸ªæ•°çš„ç»„åˆã€‚ ä½ å¯ä»¥æŒ‰ ä»»ä½•é¡ºåº è¿”å›ç­”æ¡ˆã€‚ class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; void backtraval(int n, int k , int startindex)&#123; // è¿”å›æ¡ä»¶ if (path.size() == k)&#123; result.push_back(path); return; &#125; // é€’å½’è¿‡ç¨‹ for (int i = startindex; i &lt;= n; i++)&#123; path.push_back(i); backtraval(n,k,i+1); // å›æº¯ path.pop_back(); &#125; &#125; vector&lt;vector&lt;int>> combine(int n, int k) &#123; backtraval(n,k,1); return result; &#125; &#125;; 8.2 ç»„åˆæ€»å’Œâ…¢æ‰¾å‡ºæ‰€æœ‰ç›¸åŠ ä¹‹å’Œä¸º n çš„ k ä¸ªæ•°çš„ç»„åˆï¼Œä¸”æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼š åªä½¿ç”¨æ•°å­—1åˆ°9 æ¯ä¸ªæ•°å­— æœ€å¤šä½¿ç”¨ä¸€æ¬¡ è¿”å› æ‰€æœ‰å¯èƒ½çš„æœ‰æ•ˆç»„åˆçš„åˆ—è¡¨ ã€‚è¯¥åˆ—è¡¨ä¸èƒ½åŒ…å«ç›¸åŒçš„ç»„åˆä¸¤æ¬¡ï¼Œç»„åˆå¯ä»¥ä»¥ä»»ä½•é¡ºåºè¿”å›ã€‚ class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; int sum = 0; void backtrack(int n, int k, int startindex)&#123; if (path.size() == k &amp;&amp; sum == n)&#123; result.push_back(path); return; &#125; for (int i = startindex; i &lt;= 9; i++)&#123; path.push_back(i); sum += i; // å‰ªæ if (sum > n) &#123; sum -= i; path.pop_back(); return; &#125; backtrack(n,k,i+1); path.pop_back(); sum -= i; &#125; &#125; vector&lt;vector&lt;int>> combinationSum3(int k, int n) &#123; backtrack(n,k,1); return result; &#125; &#125;; 8.3 ç”µè¯å·ç çš„å­—æ¯ç»„åˆç»™å®šä¸€ä¸ªä»…åŒ…å«æ•°å­— 2-9 çš„å­—ç¬¦ä¸²ï¼Œè¿”å›æ‰€æœ‰å®ƒèƒ½è¡¨ç¤ºçš„å­—æ¯ç»„åˆã€‚ç­”æ¡ˆå¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ã€‚ ç»™å‡ºæ•°å­—åˆ°å­—æ¯çš„æ˜ å°„å¦‚ä¸‹ï¼ˆä¸ç”µè¯æŒ‰é”®ç›¸åŒï¼‰ã€‚æ³¨æ„ 1 ä¸å¯¹åº”ä»»ä½•å­—æ¯ã€‚ class Solution &#123; private: const string letterMap[10] = &#123; \"\", // 0 \"\", // 1 \"abc\", // 2 \"def\", // 3 \"ghi\", // 4 \"jkl\", // 5 \"mno\", // 6 \"pqrs\", // 7 \"tuv\", // 8 \"wxyz\", // 9 &#125;; public: string path; vector&lt;string> result; void backtrack(string digits, int length, int startindex)&#123; if (path.size() == length)&#123; result.push_back(path); return; &#125; for (int j = startindex; j &lt; digits.size() ; j++)&#123; int num = digits[j] - '0'; if (num != 7 &amp;&amp; num!= 9)&#123; for (int i = 0; i &lt;= 2; i++)&#123; path.push_back(letterMap[num][i]); backtrack(digits, length, j+1); path.pop_back(); &#125; &#125; else &#123; for (int i = 0; i &lt;= 3; i++)&#123; path.push_back(letterMap[num][i]); backtrack(digits, length, j+1); path.pop_back(); &#125; &#125; &#125; &#125; vector&lt;string> letterCombinations(string digits) &#123; if (digits == \"\") return result; int length = digits.size(); backtrack(digits,length,0); return result; &#125; &#125;; 8.4 ç»„åˆæ€»å’Œç»™ä½ ä¸€ä¸ª æ— é‡å¤å…ƒç´  çš„æ•´æ•°æ•°ç»„ candidates å’Œä¸€ä¸ªç›®æ ‡æ•´æ•° target ï¼Œæ‰¾å‡º candidates ä¸­å¯ä»¥ä½¿æ•°å­—å’Œä¸ºç›®æ ‡æ•° target çš„ æ‰€æœ‰ ä¸åŒç»„åˆ ï¼Œå¹¶ä»¥åˆ—è¡¨å½¢å¼è¿”å›ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›è¿™äº›ç»„åˆã€‚ candidates ä¸­çš„ åŒä¸€ä¸ª æ•°å­—å¯ä»¥ æ— é™åˆ¶é‡å¤è¢«é€‰å– ã€‚å¦‚æœè‡³å°‘ä¸€ä¸ªæ•°å­—çš„è¢«é€‰æ•°é‡ä¸åŒï¼Œåˆ™ä¸¤ç§ç»„åˆæ˜¯ä¸åŒçš„ã€‚ å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œä¿è¯å’Œä¸º target çš„ä¸åŒç»„åˆæ•°å°‘äº 150 ä¸ªã€‚ class Solution &#123; public: vector&lt;int> path; vector&lt;vector&lt;int>> result; int sum = 0; void backtrack(vector&lt;int> &amp;candidates, int target, int startindex)&#123; if (sum == target)&#123; result.push_back(path); return; &#125; // å¿…è¦å‰ªæï¼Œé¿å…æ— é™é€’å½’å¯¼è‡´æ ˆæº¢å‡º if (sum > target)&#123; return; &#125; for (int i = startindex; i &lt;candidates.size(); i++)&#123; path.push_back(candidates[i]); sum+= candidates[i]; backtrack(candidates, target, i); sum-= candidates[i]; path.pop_back(); &#125; &#125; vector&lt;vector&lt;int>> combinationSum(vector&lt;int>&amp; candidates, int target) &#123; backtrack(candidates,target,0); return result; &#125; &#125;; 8.5 ç»„åˆæ€»å’Œâ…¡ç»™å®šä¸€ä¸ªå€™é€‰äººç¼–å·çš„é›†åˆ candidates å’Œä¸€ä¸ªç›®æ ‡æ•° target ï¼Œæ‰¾å‡º candidates ä¸­æ‰€æœ‰å¯ä»¥ä½¿æ•°å­—å’Œä¸º target çš„ç»„åˆã€‚ candidates ä¸­çš„æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ ä¸€æ¬¡ ã€‚ æ³¨æ„ï¼šè§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„ç»„åˆã€‚ // æ­¤å†™æ³•å¿…é¡»å…ˆè¿›è¡Œæ’åº class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; void backtrack(vector&lt;int> &amp;candidates, int target, int startindex, int sum)&#123; if (sum == target)&#123; result.push_back(path); return; &#125; if (sum > target) return; for (int i = startindex; i &lt; candidates.size(); i++)&#123; // ä¸ä½¿ç”¨é‡å¤å€¼ï¼ˆæ’åºåï¼‰ if (i > startindex &amp;&amp; candidates[i] == candidates[i-1]) continue; path.push_back(candidates[i]); sum += candidates[i]; backtrack(candidates, target, i + 1 , sum); path.pop_back(); sum -= candidates[i]; &#125; &#125; vector&lt;vector&lt;int>> combinationSum2(vector&lt;int>&amp; candidates, int target) &#123; sort(candidates.begin(), candidates.end()); backtrack(candidates, target, 0,0); return result; &#125; &#125;; 8.6 åˆ†å‰²å›æ–‡ä¸²ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œè¯·ä½ å°† s åˆ†å‰²æˆä¸€äº› å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯ å›æ–‡ä¸² ã€‚è¿”å› s æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²æ–¹æ¡ˆã€‚ class Solution &#123; public: vector&lt;vector&lt;string>> result; vector&lt;string> path; int stringcheck(string &amp;s)&#123; for (int i = 0, j = s.size() - 1; i &lt; j; i++, j--)&#123; if (s[i] != s[j])&#123; return 0; &#125; &#125; return 1; &#125; void backtrack(string &amp;s, int startindex)&#123; if (startindex >= s.size())&#123; result.push_back(path); return ; &#125; for (int i = startindex; i &lt; s.size(); i++)&#123; string substr = s.substr(startindex, i - startindex + 1); if ( stringcheck(substr) )// ä¸ºå›æ–‡ä¸² &#123; path.push_back(substr); &#125; else&#123; continue; &#125; backtrack(s, i+1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;string>> partition(string s) &#123; backtrack(s,0); return result; &#125; &#125;; 8.7 å¤åŸIPåœ°å€æœ‰æ•ˆ IP åœ°å€ æ­£å¥½ç”±å››ä¸ªæ•´æ•°ï¼ˆæ¯ä¸ªæ•´æ•°ä½äº 0 åˆ° 255 ä¹‹é—´ç»„æˆï¼Œä¸”ä¸èƒ½å«æœ‰å‰å¯¼ 0ï¼‰ï¼Œæ•´æ•°ä¹‹é—´ç”¨ &#39;.&#39; åˆ†éš”ã€‚ ä¾‹å¦‚ï¼š&quot;0.1.2.201&quot; å’Œ&quot;192.168.1.1&quot; æ˜¯ æœ‰æ•ˆ IP åœ°å€ï¼Œä½†æ˜¯ &quot;0.011.255.245&quot;ã€&quot;192.168.1.312&quot; å’Œ &quot;192.168@1.1&quot; æ˜¯ æ— æ•ˆ IP åœ°å€ã€‚ ç»™å®šä¸€ä¸ªåªåŒ…å«æ•°å­—çš„å­—ç¬¦ä¸² s ï¼Œç”¨ä»¥è¡¨ç¤ºä¸€ä¸ª IP åœ°å€ï¼Œè¿”å›æ‰€æœ‰å¯èƒ½çš„æœ‰æ•ˆ IP åœ°å€ï¼Œè¿™äº›åœ°å€å¯ä»¥é€šè¿‡åœ¨ s ä¸­æ’å…¥ &#39;.&#39; æ¥å½¢æˆã€‚ä½  ä¸èƒ½ é‡æ–°æ’åºæˆ–åˆ é™¤ s ä¸­çš„ä»»ä½•æ•°å­—ã€‚ä½ å¯ä»¥æŒ‰ ä»»ä½• é¡ºåºè¿”å›ç­”æ¡ˆã€‚ // æœ‰ç‚¹éš¾åº¦ class Solution &#123; public: vector&lt;string> result; string path; void backtrack(string &amp;s, int startindex, int dotCount) &#123; if (startindex == s.size() &amp;&amp; dotCount == 4) &#123; // å»é™¤æœ«å°¾çš„'.' path.pop_back(); result.push_back(path); return; &#125; // å‰ªæï¼šæå‰ç»ˆæ­¢æ¡ä»¶ï¼šå‰©ä½™å­—ç¬¦å¤ªå¤šæˆ–å¤ªå°‘ if (s.size() - startindex > (4 - dotCount) * 3 || s.size() - startindex &lt; (4 - dotCount)) &#123; return; &#125; for (int i = startindex; i &lt; s.size() &amp;&amp; i &lt; startindex + 3; i++) &#123; string substr = s.substr(startindex, i - startindex + 1); if (isValid(substr)) &#123; int originalSize = path.size(); path += substr + \".\"; backtrack(s, i + 1, dotCount + 1); // å›æº¯ path.erase(originalSize); &#125; &#125; &#125; bool isValid(string &amp;substr) &#123; if (substr.size() > 1 &amp;&amp; substr[0] == '0') &#123; return false; &#125; int num = stoi(substr); return num >= 0 &amp;&amp; num &lt;= 255; &#125; vector&lt;string> restoreIpAddresses(string s) &#123; if (s.size() &lt; 4 || s.size() > 12) return result; backtrack(s, 0, 0); return result; &#125; &#125;; 8.8 å­é›†ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ•°ç»„ä¸­çš„å…ƒç´  äº’ä¸ç›¸åŒ ã€‚è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚ è§£é›† ä¸èƒ½ åŒ…å«é‡å¤çš„å­é›†ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›è§£é›†ã€‚ // æƒ³å¤æ‚äº†ï¼Œæœ¬è´¨ä¸Šä¸éœ€è¦æ¡ä»¶ç›´æ¥è¿”å›å°±è¡Œ class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; void backtrack(vector&lt;int> &amp;nums, int startindex , int length)&#123; // condition if (path.size() == length)&#123; result.push_back(path); return; &#125; for (int i = startindex; i &lt; nums.size(); i++ )&#123; path.push_back(nums[i]); backtrack(nums, i+1, length); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int>> subsets(vector&lt;int>&amp; nums) &#123; for (int i = 0; i &lt;= nums.size(); i++)&#123; backtrack(nums,0,i); &#125; return result; &#125; &#125;; 8.9 å­é›†â…¡ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå…¶ä¸­å¯èƒ½åŒ…å«é‡å¤å…ƒç´ ï¼Œè¯·ä½ è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„ å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚ è§£é›† ä¸èƒ½ åŒ…å«é‡å¤çš„å­é›†ã€‚è¿”å›çš„è§£é›†ä¸­ï¼Œå­é›†å¯ä»¥æŒ‰ ä»»æ„é¡ºåº æ’åˆ—ã€‚ // å»é‡ä¹Ÿå¯ä»¥ç”¨set class Solution &#123; public: vector&lt;int> path; vector&lt;vector&lt;int>> result; void backtrack(vector&lt;int> &amp;nums, int startindex)&#123; //add to result result.push_back(path); for (int i = startindex; i &lt; nums.size(); i++)&#123; //å»é‡ if (i > startindex &amp;&amp; nums[i] == nums[i-1])&#123; continue; &#125; path.push_back(nums[i]); backtrack(nums,i+1); path.pop_back(); &#125; &#125; vector&lt;vector&lt;int>> subsetsWithDup(vector&lt;int>&amp; nums) &#123; sort(nums.begin(), nums.end()); backtrack(nums, 0); return result; &#125; &#125;; 8.10 éé€’å‡å­åºåˆ—ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾å‡ºå¹¶è¿”å›æ‰€æœ‰è¯¥æ•°ç»„ä¸­ä¸åŒçš„é€’å¢å­åºåˆ—ï¼Œé€’å¢å­åºåˆ—ä¸­ è‡³å°‘æœ‰ä¸¤ä¸ªå…ƒç´  ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚ æ•°ç»„ä¸­å¯èƒ½å«æœ‰é‡å¤å…ƒç´ ï¼Œå¦‚å‡ºç°ä¸¤ä¸ªæ•´æ•°ç›¸ç­‰ï¼Œä¹Ÿå¯ä»¥è§†ä½œé€’å¢åºåˆ—çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µã€‚ // è¿™é¢˜ä¸èƒ½ç”¨sortï¼Œå› æ­¤é€‰æ‹©ç”¨å“ˆå¸Œè¡¨å»é‡ class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; void backtrack(vector&lt;int>&amp; nums, int startindex)&#123; if (path.size() >= 2 )&#123; result.push_back(path); // return; &#125; unordered_set&lt;int> used; for (int i = startindex; i &lt; nums.size(); i++)&#123; if (used.find(nums[i]) != used.end()) continue; if (path.size() != 0)&#123; if (nums[i] >= path.back())&#123; used.insert(nums[i]); path.push_back(nums[i]); backtrack(nums, i+1); path.pop_back(); &#125; &#125; else&#123; used.insert(nums[i]); path.push_back(nums[i]); backtrack(nums, i+1); path.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int>> findSubsequences(vector&lt;int>&amp; nums) &#123; backtrack(nums, 0); return result; &#125; &#125;; 8.11 å…¨æ’åˆ—ç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ nums ï¼Œè¿”å›å…¶ æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ— ã€‚ä½ å¯ä»¥ æŒ‰ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚ // ç»å…¸é—®é¢˜ class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; void backtrack(vector&lt;int> &amp;nums, vector&lt;bool> &amp;used)&#123; if (path.size() == nums.size())&#123; result.push_back(path); return; &#125; // æ¯æ¬¡å›æº¯å‡è¦ä»0ç´¢å¼•å¼€å§‹ for (int i = 0; i &lt; nums.size(); i++)&#123; if (used[i] == true) continue; path.push_back(nums[i]); used[i] = true; backtrack(nums,used); path.pop_back(); used[i] = false; &#125; &#125; vector&lt;vector&lt;int>> permute(vector&lt;int>&amp; nums) &#123; vector&lt;bool> used(nums.size(), false); backtrack(nums,used); return result; &#125; &#125;; 8.12 å…¨æ’åˆ—â…¡ç»™å®šä¸€ä¸ªå¯åŒ…å«é‡å¤æ•°å­—çš„åºåˆ— nums ï¼ŒæŒ‰ä»»æ„é¡ºåº è¿”å›æ‰€æœ‰ä¸é‡å¤çš„å…¨æ’åˆ—ã€‚ class Solution &#123; public: vector&lt;vector&lt;int>> result; vector&lt;int> path; void backtrack(vector&lt;int> &amp;nums, vector&lt;bool> &amp;used)&#123; if (path.size() == nums.size())&#123; result.push_back(path); return; &#125; // repeat setè®°å½•åŒä¸€å±‚çº§(æ·±åº¦)çš„å·²ä½¿ç”¨è¿‡çš„å…ƒç´ é›†ï¼Œå»é‡ // ç¡®ä¿åœ¨åŒä¸€å±‚çº§å»é‡ï¼Œä¸å½±å“ä¸åŒå±‚çº§é€‰æ‹©ç›¸åŒå€¼çš„å…ƒç´ ï¼ŒåŒä¸€å±‚çº§çš„å»é‡é usedå®ç° unordered_set&lt;int> repeat; for (int i = 0; i &lt; nums.size(); i++)&#123; if (repeat.find(nums[i]) != repeat.end()) continue; if (used[i] == true) continue; used[i] = true; path.push_back(nums[i]); backtrack(nums, used); path.pop_back(); used[i] = false; repeat.insert(nums[i]); &#125; &#125; vector&lt;vector&lt;int>> permuteUnique(vector&lt;int>&amp; nums) &#123; vector&lt;bool> used(nums.size(), false); backtrack(nums, used); return result; &#125; &#125;; 8.13 Nçš‡åæŒ‰ç…§å›½é™…è±¡æ£‹çš„è§„åˆ™ï¼Œçš‡åå¯ä»¥æ”»å‡»ä¸ä¹‹å¤„åœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—æˆ–åŒä¸€æ–œçº¿ä¸Šçš„æ£‹å­ã€‚ n çš‡åé—®é¢˜ ç ”ç©¶çš„æ˜¯å¦‚ä½•å°† n ä¸ªçš‡åæ”¾ç½®åœ¨ nÃ—n çš„æ£‹ç›˜ä¸Šï¼Œå¹¶ä¸”ä½¿çš‡åå½¼æ­¤ä¹‹é—´ä¸èƒ½ç›¸äº’æ”»å‡»ã€‚ ç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¿”å›æ‰€æœ‰ä¸åŒçš„ n çš‡åé—®é¢˜ çš„è§£å†³æ–¹æ¡ˆã€‚ æ¯ä¸€ç§è§£æ³•åŒ…å«ä¸€ä¸ªä¸åŒçš„ n çš‡åé—®é¢˜ çš„æ£‹å­æ”¾ç½®æ–¹æ¡ˆï¼Œè¯¥æ–¹æ¡ˆä¸­ &#39;Q&#39; å’Œ &#39;.&#39; åˆ†åˆ«ä»£è¡¨äº†çš‡åå’Œç©ºä½ã€‚ // ä¸€å¼€å§‹å†™æœ‰ä¸¤ä¸ªé—®é¢˜ï¼Œä¸€æ˜¯å­—ç¬¦ä¸²çš„å¤„ç†è¿˜ä¸å¤Ÿç†Ÿç»ƒï¼ŒäºŒæ˜¯used3çŠ¶æ€ç´¢å¼•ä¸€å¼€å§‹ç”¨çš„abs(i - j) å…¶å®æ˜¯é”™çš„ class Solution &#123; public: vector&lt;string> path; vector&lt;vector&lt;string>> result; void backtrack(int n, int i, vector&lt;bool> &amp;used1, vector&lt;bool> &amp;used2, vector&lt;bool> &amp;used3)&#123; if (i == n)&#123; result.push_back(path); return; &#125; for (int j = 0; j &lt; n; j++)&#123; if ( used1[j] || used2[i+j] || used3[i - j + n]) continue; string s(n, '.'); s[j] = 'Q'; used1[j] = true; used2[i+j] = true; used3[i - j + n] =true; path.push_back(s); backtrack(n, i + 1, used1, used2, used3); used1[j] = false; used2[i+j] = false; used3[i - j + n] =false; path.pop_back(); &#125; &#125; vector&lt;vector&lt;string>> solveNQueens(int n) &#123; vector&lt;bool> used1(n, false); vector&lt;bool> used2(n*n, false); vector&lt;bool> used3(n*n, false); backtrack(n, 0, used1, used2, used3); return result; &#125; &#125;; 8.14 è§£æ•°ç‹¬ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œé€šè¿‡å¡«å……ç©ºæ ¼æ¥è§£å†³æ•°ç‹¬é—®é¢˜ã€‚ æ•°ç‹¬çš„è§£æ³•éœ€ éµå¾ªå¦‚ä¸‹è§„åˆ™ï¼š æ•°å­— 1-9 åœ¨æ¯ä¸€è¡Œåªèƒ½å‡ºç°ä¸€æ¬¡ã€‚ æ•°å­— 1-9 åœ¨æ¯ä¸€åˆ—åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚ æ•°å­— 1-9 åœ¨æ¯ä¸€ä¸ªä»¥ç²—å®çº¿åˆ†éš”çš„ 3x3 å®«å†…åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚ï¼ˆè¯·å‚è€ƒç¤ºä¾‹å›¾ï¼‰ æ•°ç‹¬éƒ¨åˆ†ç©ºæ ¼å†…å·²å¡«å…¥äº†æ•°å­—ï¼Œç©ºç™½æ ¼ç”¨ &#39;.&#39; è¡¨ç¤ºã€‚ class Solution &#123; public: bool backtrack(vector&lt;vector&lt;char>>&amp; board)&#123; for (int row = 0; row &lt; 9; row++)&#123; for (int col = 0; col &lt; 9; col++)&#123; if (board[row][col] == '.')&#123; for (char k = '1'; k &lt;= '9'; k++)&#123; if (isValid(board, row, col, k)) &#123; board[row][col] = k; if (backtrack(board)) return true; board[row][col] = '.'; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; bool isValid(vector&lt;vector&lt;char>>&amp; board, int row, int col, char k)&#123; for (int i = 0; i &lt; 9; i++)&#123; if (board[row][i] == k) return false; &#125; for (int i = 0; i &lt; 9; i++)&#123; if (board[i][col] == k) return false; &#125; int startrow = (row / 3) * 3; int startcol = (col / 3) * 3; for (int i = startrow; i &lt; startrow + 3; i++)&#123; for (int j = startcol; j &lt; startcol + 3; j++)&#123; if (board[i][j] == k) return false; &#125; &#125; return true; &#125; void solveSudoku(vector&lt;vector&lt;char>>&amp; board) &#123; backtrack(board); &#125; &#125;; &nbsp; 9. è´ªå¿ƒè´ªå¿ƒçš„æœ¬è´¨æ˜¯é€‰æ‹©æ¯ä¸€é˜¶æ®µçš„å±€éƒ¨æœ€ä¼˜ï¼Œä»è€Œè¾¾åˆ°å…¨å±€æœ€ä¼˜ã€‚ 9.1 åˆ†å‘é¥¼å¹²å¯¹æ¯ä¸ªå­©å­ iï¼Œéƒ½æœ‰ä¸€ä¸ªèƒƒå£å€¼ g[i]ï¼Œè¿™æ˜¯èƒ½è®©å­©å­ä»¬æ»¡è¶³èƒƒå£çš„é¥¼å¹²çš„æœ€å°å°ºå¯¸ï¼›å¹¶ä¸”æ¯å—é¥¼å¹² jï¼Œéƒ½æœ‰ä¸€ä¸ªå°ºå¯¸ s[j] ã€‚å¦‚æœ s[j] &gt;= g[i]ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªé¥¼å¹² j åˆ†é…ç»™å­©å­ i ï¼Œè¿™ä¸ªå­©å­ä¼šå¾—åˆ°æ»¡è¶³ã€‚ä½ çš„ç›®æ ‡æ˜¯æ»¡è¶³å°½å¯èƒ½å¤šçš„å­©å­ï¼Œå¹¶è¾“å‡ºè¿™ä¸ªæœ€å¤§æ•°å€¼ã€‚ class Solution &#123; public: int findContentChildren(vector&lt;int>&amp; g, vector&lt;int>&amp; s) &#123; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int count = 0; int backindex = s.size() - 1; for (int i = g.size() - 1; i >= 0; i--) &#123; if (backindex >= 0 &amp;&amp; s[backindex] >= g[i] ) &#123; backindex--; count++; &#125; if(backindex &lt; 0) break; &#125; return count; &#125; &#125;; 9.2 æ‘†åŠ¨åºåˆ—å¦‚æœè¿ç»­æ•°å­—ä¹‹é—´çš„å·®ä¸¥æ ¼åœ°åœ¨æ­£æ•°å’Œè´Ÿæ•°ä¹‹é—´äº¤æ›¿ï¼Œåˆ™æ•°å­—åºåˆ—ç§°ä¸º æ‘†åŠ¨åºåˆ— ã€‚ç¬¬ä¸€ä¸ªå·®ï¼ˆå¦‚æœå­˜åœ¨çš„è¯ï¼‰å¯èƒ½æ˜¯æ­£æ•°æˆ–è´Ÿæ•°ã€‚ä»…æœ‰ä¸€ä¸ªå…ƒç´ æˆ–è€…å«ä¸¤ä¸ªä¸ç­‰å…ƒç´ çš„åºåˆ—ä¹Ÿè§†ä½œæ‘†åŠ¨åºåˆ—ã€‚ //æ³¨æ„è¿ç»­æ•°æ®ç›¸ç­‰çš„æƒ…å†µ class Solution &#123; public: int wiggleMaxLength(vector&lt;int>&amp; nums) &#123; if (nums.size() == 1) return 1; int count = 1; int prevDiff = 0; for (int i = 1; i &lt; nums.size(); i++) &#123; int currDiff = nums[i] - nums[i-1]; if (currDiff == 0) continue; if (prevDiff == 0 || (prevDiff > 0 &amp;&amp; currDiff &lt; 0) || (prevDiff &lt; 0 &amp;&amp; currDiff > 0)) &#123; count++; prevDiff = currDiff; &#125; &#125; return count; &#125; &#125;; 9.3 æœ€å¤§å­æ•°ç»„å’Œç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œè¯·ä½ æ‰¾å‡ºä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚ å­æ•°ç»„æ˜¯æ•°ç»„ä¸­çš„ä¸€ä¸ªè¿ç»­éƒ¨åˆ†ã€‚ class Solution &#123; public: int maxSubArray(vector&lt;int>&amp; nums) &#123; int count = 0; int maxsum = INT_MIN; for (int i = 0; i &lt; nums.size(); i++)&#123; count += nums[i]; if (count > maxsum) maxsum = count; if (count &lt; 0) count = 0; &#125; return maxsum; &#125; &#125;; 9.4 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºâ…¡ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ prices ï¼Œå…¶ä¸­ prices[i] è¡¨ç¤ºæŸæ”¯è‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚ åœ¨æ¯ä¸€å¤©ï¼Œä½ å¯ä»¥å†³å®šæ˜¯å¦è´­ä¹°å’Œ/æˆ–å‡ºå”®è‚¡ç¥¨ã€‚ä½ åœ¨ä»»ä½•æ—¶å€™ æœ€å¤š åªèƒ½æŒæœ‰ ä¸€è‚¡ è‚¡ç¥¨ã€‚ä½ ä¹Ÿå¯ä»¥å…ˆè´­ä¹°ï¼Œç„¶ååœ¨ åŒä¸€å¤© å‡ºå”®ã€‚ è¿”å› ä½ èƒ½è·å¾—çš„ æœ€å¤§ åˆ©æ¶¦ ã€‚ class Solution &#123; public: int maxProfit(vector&lt;int>&amp; prices) &#123; int profits = 0; for (int i = 1; i &lt; prices.size(); i++)&#123; int curdiff = prices[i] - prices[i - 1]; if (curdiff > 0)&#123; profits += curdiff; &#125; &#125; return profits; &#125; &#125;; 9.5 è·³è·ƒæ¸¸æˆç»™ä½ ä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ nums ï¼Œä½ æœ€åˆä½äºæ•°ç»„çš„ ç¬¬ä¸€ä¸ªä¸‹æ ‡ ã€‚æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»£è¡¨ä½ åœ¨è¯¥ä½ç½®å¯ä»¥è·³è·ƒçš„æœ€å¤§é•¿åº¦ã€‚ åˆ¤æ–­ä½ æ˜¯å¦èƒ½å¤Ÿåˆ°è¾¾æœ€åä¸€ä¸ªä¸‹æ ‡ï¼Œå¦‚æœå¯ä»¥ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚ //å†™çš„å¤ªå¤æ‚äº†ï¼Œæ€è·¯å¯¹çš„ï¼Œä½†ä¸éœ€è¦ è·³è½¬ è¿™ä¸ªæ“ä½œ class Solution &#123; public: bool canJump(vector&lt;int>&amp; nums) &#123; int length = nums.size(); int startindex = 0; if (nums.size() == 0) return false; while (startindex &lt; nums.size() - 1)&#123; int nextrange = nums[startindex]; if (nextrange == 0) return false; int nextmax = INT_MIN; if (startindex + nextrange >= nums.size() - 1) return true; int recordindex = startindex; for (int i = startindex + 1; i &lt;= startindex + nextrange; i++)&#123; int opt = i + nums[i]; if (opt > nextmax)&#123; nextmax = opt; recordindex = i; &#125; &#125; startindex = recordindex; &#125; return true; &#125; &#125;; // ç®€å•è§£æ³• class Solution &#123; public: bool canJump(vector&lt;int>&amp; nums) &#123; int cover = 0; if (nums.size() == 1) return true; for (int i = 0; i &lt;= cover; i++) &#123; cover = max(i + nums[i], cover); if (cover >= nums.size() - 1) return true; &#125; return false; &#125; &#125;; 9.6 è·³è·ƒæ¸¸æˆâ…¡ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n çš„ 0 ç´¢å¼•æ•´æ•°æ•°ç»„ numsã€‚åˆå§‹ä½ç½®åœ¨ä¸‹æ ‡ 0ã€‚ æ¯ä¸ªå…ƒç´  nums[i] è¡¨ç¤ºä»ç´¢å¼• i å‘åè·³è½¬çš„æœ€å¤§é•¿åº¦ã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœä½ åœ¨ç´¢å¼• i å¤„ï¼Œä½ å¯ä»¥è·³è½¬åˆ°ä»»æ„ (i + j) å¤„ï¼š 0 &lt;= j &lt;= nums[i] ä¸” i + j &lt; n è¿”å›åˆ°è¾¾ n - 1 çš„æœ€å°è·³è·ƒæ¬¡æ•°ã€‚æµ‹è¯•ç”¨ä¾‹ä¿è¯å¯ä»¥åˆ°è¾¾ n - 1ã€‚ class Solution &#123; public: int jump(vector&lt;int>&amp; nums) &#123; int startindex = 0; int count = 0; if (nums.size() == 1) return 0; while (startindex &lt; nums.size() - 1)&#123; int nextrange = nums[startindex]; if (nextrange == 0) &#123; return 0; &#125; int nextmax = INT_MIN; if (startindex + nextrange >= nums.size() - 1)&#123; break; &#125; int recordindex = startindex; for (int i = startindex + 1; i &lt;= startindex + nextrange; i++)&#123; int opt = i + nums[i]; if (opt > nextmax)&#123; nextmax = opt; recordindex = i; &#125; &#125; startindex = recordindex; count ++; &#125; count += 1; return count; &#125; &#125;; 9.7 Kæ¬¡å–ååæœ€å¤§åŒ–çš„æ•°ç»„å’Œç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° k ï¼ŒæŒ‰ä»¥ä¸‹æ–¹æ³•ä¿®æ”¹è¯¥æ•°ç»„ï¼š é€‰æ‹©æŸä¸ªä¸‹æ ‡ i å¹¶å°† nums[i] æ›¿æ¢ä¸º -nums[i] ã€‚ é‡å¤è¿™ä¸ªè¿‡ç¨‹æ°å¥½ k æ¬¡ã€‚å¯ä»¥å¤šæ¬¡é€‰æ‹©åŒä¸€ä¸ªä¸‹æ ‡ i ã€‚ ä»¥è¿™ç§æ–¹å¼ä¿®æ”¹æ•°ç»„åï¼Œè¿”å›æ•°ç»„ å¯èƒ½çš„æœ€å¤§å’Œ ã€‚ class Solution &#123; public: int largestSumAfterKNegations(vector&lt;int>&amp; nums, int k) &#123; // ä¸éœ€è¦æŒ‰ç»å¯¹å€¼æ’åº for (int i = 0; i &lt; k; i++) &#123; sort(nums.begin(), nums.end()); nums[0] = -nums[0]; &#125; int sum = 0; for (auto&amp; num : nums) &#123; sum += num; &#125; return sum; &#125; &#125;; 9.8 åŠ æ²¹ç«™ åœ¨ä¸€æ¡ç¯è·¯ä¸Šæœ‰ n ä¸ªåŠ æ²¹ç«™ï¼Œå…¶ä¸­ç¬¬ i ä¸ªåŠ æ²¹ç«™æœ‰æ±½æ²¹ gas[i] å‡ã€‚ ä½ æœ‰ä¸€è¾†æ²¹ç®±å®¹é‡æ— é™çš„çš„æ±½è½¦ï¼Œä»ç¬¬ i ä¸ªåŠ æ²¹ç«™å¼€å¾€ç¬¬ i+1 ä¸ªåŠ æ²¹ç«™éœ€è¦æ¶ˆè€—æ±½æ²¹ cost[i] å‡ã€‚ä½ ä»å…¶ä¸­çš„ä¸€ä¸ªåŠ æ²¹ç«™å‡ºå‘ï¼Œå¼€å§‹æ—¶æ²¹ç®±ä¸ºç©ºã€‚ ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ gas å’Œ cost ï¼Œå¦‚æœä½ å¯ä»¥æŒ‰é¡ºåºç»•ç¯è·¯è¡Œé©¶ä¸€å‘¨ï¼Œåˆ™è¿”å›å‡ºå‘æ—¶åŠ æ²¹ç«™çš„ç¼–å·ï¼Œå¦åˆ™è¿”å› -1 ã€‚å¦‚æœå­˜åœ¨è§£ï¼Œåˆ™ ä¿è¯ å®ƒæ˜¯ å”¯ä¸€ çš„ã€‚ class Solution &#123; public: int canCompleteCircuit(vector&lt;int>&amp; gas, vector&lt;int>&amp; cost) &#123; vector&lt;int> diff(gas.size(), 0); for (int i = 0; i &lt; gas.size(); i++)&#123; diff[i] = gas[i] - cost[i]; &#125; int count = 0; int totalsum = 0; int possum = 0; int negasum = 0; for (int i = 0; i &lt; diff.size(); i++)&#123; if (diff[i] &lt; 0) negasum += diff[i]; if (diff[i] > 0) possum += diff[i]; totalsum += diff[i]; // è¿™é‡Œæ˜¯ç²¾é«“ if (totalsum &lt; 0)&#123; count = i + 1; totalsum = 0; &#125; &#125; if ((negasum + possum) &lt; 0) return -1; else return count; &#125; &#125;; 9.9 åˆ†å‘ç³–æœn ä¸ªå­©å­ç«™æˆä¸€æ’ã€‚ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ ratings è¡¨ç¤ºæ¯ä¸ªå­©å­çš„è¯„åˆ†ã€‚ ä½ éœ€è¦æŒ‰ç…§ä»¥ä¸‹è¦æ±‚ï¼Œç»™è¿™äº›å­©å­åˆ†å‘ç³–æœï¼š æ¯ä¸ªå­©å­è‡³å°‘åˆ†é…åˆ° 1 ä¸ªç³–æœã€‚ ç›¸é‚»ä¸¤ä¸ªå­©å­ä¸­ï¼Œè¯„åˆ†æ›´é«˜çš„é‚£ä¸ªä¼šè·å¾—æ›´å¤šçš„ç³–æœã€‚ è¯·ä½ ç»™æ¯ä¸ªå­©å­åˆ†å‘ç³–æœï¼Œè®¡ç®—å¹¶è¿”å›éœ€è¦å‡†å¤‡çš„ æœ€å°‘ç³–æœæ•°ç›® ã€‚ //æ²¡æƒ³å‡ºæ¥ class Solution &#123; public: int candy(vector&lt;int>&amp; ratings) &#123; int sum = 0; vector&lt;int> candycount(ratings.size(), 1); for (int i = 0; i &lt; ratings.size()-1; i++)&#123; if (ratings[i+1] > ratings[i]) candycount[i+1] = candycount[i] + 1; &#125; for (int i = ratings.size() - 2; i >= 0; i--)&#123; if (ratings[i+1] &lt; ratings[i]) &#123; //è´ªå¿ƒæ€æƒ³åœ¨è¿™é‡Œ candycount[i] = max(candycount[i+1] + 1, candycount[i]); &#125; &#125; for (int i = 0; i &lt; candycount.size(); i++)&#123; sum += candycount[i]; &#125; return sum; &#125; &#125;; 9.10 æŸ æª¬æ°´æ‰¾é›¶åœ¨æŸ æª¬æ°´æ‘Šä¸Šï¼Œæ¯ä¸€æ¯æŸ æª¬æ°´çš„å”®ä»·ä¸º 5 ç¾å…ƒã€‚é¡¾å®¢æ’é˜Ÿè´­ä¹°ä½ çš„äº§å“ï¼Œï¼ˆæŒ‰è´¦å• bills æ”¯ä»˜çš„é¡ºåºï¼‰ä¸€æ¬¡è´­ä¹°ä¸€æ¯ã€‚ æ¯ä½é¡¾å®¢åªä¹°ä¸€æ¯æŸ æª¬æ°´ï¼Œç„¶åå‘ä½ ä»˜ 5 ç¾å…ƒã€10 ç¾å…ƒæˆ– 20 ç¾å…ƒã€‚ä½ å¿…é¡»ç»™æ¯ä¸ªé¡¾å®¢æ­£ç¡®æ‰¾é›¶ï¼Œä¹Ÿå°±æ˜¯è¯´å‡€äº¤æ˜“æ˜¯æ¯ä½é¡¾å®¢å‘ä½ æ”¯ä»˜ 5 ç¾å…ƒã€‚ æ³¨æ„ï¼Œä¸€å¼€å§‹ä½ æ‰‹å¤´æ²¡æœ‰ä»»ä½•é›¶é’±ã€‚ ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ bills ï¼Œå…¶ä¸­ bills[i] æ˜¯ç¬¬ i ä½é¡¾å®¢ä»˜çš„è´¦ã€‚å¦‚æœä½ èƒ½ç»™æ¯ä½é¡¾å®¢æ­£ç¡®æ‰¾é›¶ï¼Œè¿”å› true ï¼Œå¦åˆ™è¿”å› false ã€‚ class Solution &#123; public: bool lemonadeChange(vector&lt;int>&amp; bills) &#123; unordered_map&lt;int,int> cash; for (int i = 0; i &lt; bills.size(); i++)&#123; if(bills[i] == 5) cash[5]++; else if (bills[i] == 10) &#123; cash[10]++; if (cash[5]>0) cash[5]--; else return false; &#125; else&#123; cash[20]++; //ä¼˜å…ˆæ‰¾10å—é’±çš„ if (cash[5]>0 &amp;&amp; cash[10]>0)&#123; cash[5]--; cash[10]--; &#125; else if (cash[5]>=3)&#123; cash[5] -= 3; &#125; else return false; &#125; &#125; return true; &#125; &#125;; 9.11 æ ¹æ®èº«é«˜é‡å»ºé˜Ÿåˆ—å‡è®¾æœ‰æ‰“ä¹±é¡ºåºçš„ä¸€ç¾¤äººç«™æˆä¸€ä¸ªé˜Ÿåˆ—ï¼Œæ•°ç»„ people è¡¨ç¤ºé˜Ÿåˆ—ä¸­ä¸€äº›äººçš„å±æ€§ï¼ˆä¸ä¸€å®šæŒ‰é¡ºåºï¼‰ã€‚æ¯ä¸ª people[i] = [hi, ki] è¡¨ç¤ºç¬¬ i ä¸ªäººçš„èº«é«˜ä¸º hi ï¼Œå‰é¢ æ­£å¥½ æœ‰ ki ä¸ªèº«é«˜å¤§äºæˆ–ç­‰äº hi çš„äººã€‚ è¯·ä½ é‡æ–°æ„é€ å¹¶è¿”å›è¾“å…¥æ•°ç»„ people æ‰€è¡¨ç¤ºçš„é˜Ÿåˆ—ã€‚è¿”å›çš„é˜Ÿåˆ—åº”è¯¥æ ¼å¼åŒ–ä¸ºæ•°ç»„ queue ï¼Œå…¶ä¸­ queue[j] = [hj, kj] æ˜¯é˜Ÿåˆ—ä¸­ç¬¬ j ä¸ªäººçš„å±æ€§ï¼ˆqueue[0] æ˜¯æ’åœ¨é˜Ÿåˆ—å‰é¢çš„äººï¼‰ã€‚ //ä¸¤ä¸ªåˆ¤æ–­æ¡ä»¶ï¼Œå…ˆæ¢³ç†å¥½ä¸€ä¸ªå†è€ƒè™‘å¦å¤–ä¸€ä¸ª class Solution &#123; public: //ç±»å†…å®šä¹‰cmpéœ€è¦ä½¿ç”¨é™æ€æˆå‘˜å‡½æ•°ï¼Œé˜²æ­¢thisæŒ‡é’ˆå‡ºç° static bool cmp(const vector&lt;int>&amp; a, const vector&lt;int>&amp;b)&#123; if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] > b[0]; &#125; vector&lt;vector&lt;int>> reconstructQueue(vector&lt;vector&lt;int>>&amp; people) &#123; vector&lt;vector&lt;int>> queue; sort(people.begin(), people.end(), cmp); for (int i = 0; i &lt; people.size(); i++)&#123; int index = people[i][1]; queue.insert(queue.begin() + index, people[i]); &#125; return queue; &#125; &#125;; 9.12 ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒæœ‰ä¸€äº›çƒå½¢æ°”çƒè´´åœ¨ä¸€å µç”¨ XY å¹³é¢è¡¨ç¤ºçš„å¢™é¢ä¸Šã€‚å¢™é¢ä¸Šçš„æ°”çƒè®°å½•åœ¨æ•´æ•°æ•°ç»„ points ï¼Œå…¶ä¸­points[i] = [xstart, xend] è¡¨ç¤ºæ°´å¹³ç›´å¾„åœ¨ xstart å’Œ xendä¹‹é—´çš„æ°”çƒã€‚ä½ ä¸çŸ¥é“æ°”çƒçš„ç¡®åˆ‡ y åæ ‡ã€‚ ä¸€æ”¯å¼“ç®­å¯ä»¥æ²¿ç€ x è½´ä»ä¸åŒç‚¹ å®Œå…¨å‚ç›´ åœ°å°„å‡ºã€‚åœ¨åæ ‡ x å¤„å°„å‡ºä¸€æ”¯ç®­ï¼Œè‹¥æœ‰ä¸€ä¸ªæ°”çƒçš„ç›´å¾„çš„å¼€å§‹å’Œç»“æŸåæ ‡ä¸º x``startï¼Œx``endï¼Œ ä¸”æ»¡è¶³ xstart â‰¤ x â‰¤ x``endï¼Œåˆ™è¯¥æ°”çƒä¼šè¢« å¼•çˆ† ã€‚å¯ä»¥å°„å‡ºçš„å¼“ç®­çš„æ•°é‡ æ²¡æœ‰é™åˆ¶ ã€‚ å¼“ç®­ä¸€æ—¦è¢«å°„å‡ºä¹‹åï¼Œå¯ä»¥æ— é™åœ°å‰è¿›ã€‚ ç»™ä½ ä¸€ä¸ªæ•°ç»„ points ï¼Œè¿”å›å¼•çˆ†æ‰€æœ‰æ°”çƒæ‰€å¿…é¡»å°„å‡ºçš„ æœ€å° å¼“ç®­æ•° ã€‚ //ç§’äº† class Solution &#123; public: static bool cmp(const vector&lt;int> &amp;a, const vector&lt;int> &amp;b)&#123; if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] &lt; b[0]; &#125; int findMinArrowShots(vector&lt;vector&lt;int>>&amp; points) &#123; sort(points.begin(), points.end(), cmp); int count = points.size(); int rightboundary = points[0][1]; for (int i = 0; i &lt; points.size() - 1; i++)&#123; if (points[i+1][0] &lt;= rightboundary)&#123; rightboundary = min(rightboundary, points[i+1][1]); count--; &#125; else rightboundary = points[i+1][1]; &#125; return count; &#125; &#125;; 9.13 æ— é‡å åŒºé—´ç»™å®šä¸€ä¸ªåŒºé—´çš„é›†åˆ intervals ï¼Œå…¶ä¸­ intervals[i] = [starti, endi] ã€‚è¿”å› éœ€è¦ç§»é™¤åŒºé—´çš„æœ€å°æ•°é‡ï¼Œä½¿å‰©ä½™åŒºé—´äº’ä¸é‡å  ã€‚ æ³¨æ„ åªåœ¨ä¸€ç‚¹ä¸Šæ¥è§¦çš„åŒºé—´æ˜¯ ä¸é‡å çš„ã€‚ä¾‹å¦‚ [1, 2] å’Œ [2, 3] æ˜¯ä¸é‡å çš„ã€‚ //æ€æƒ³åŒä¸Šï¼Œè¾¹ç•Œå¤„ç†æ–¹å¼ä¸åŒ class Solution &#123; public: static bool cmp(const vector&lt;int> &amp;a, const vector&lt;int> &amp;b)&#123; if (a[0] == b[0]) return a[1] &lt; b[1]; return a[0] &lt; b[0]; &#125; int eraseOverlapIntervals(vector&lt;vector&lt;int>>&amp; intervals) &#123; int result = 0; sort(intervals.begin(), intervals.end(), cmp); int right = intervals[0][1]; for (int i = 0; i &lt; intervals.size()-1; i++)&#123; if(intervals[i+1][0] &lt; right)&#123; result++; right = min(intervals[i+1][1], right); &#125; else &#123; right = intervals[i+1][1]; &#125; &#125; return result; &#125; &#125;; 9.14 åˆ’åˆ†å­—æ¯åŒºé—´ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ã€‚æˆ‘ä»¬è¦æŠŠè¿™ä¸ªå­—ç¬¦ä¸²åˆ’åˆ†ä¸ºå°½å¯èƒ½å¤šçš„ç‰‡æ®µï¼ŒåŒä¸€å­—æ¯æœ€å¤šå‡ºç°åœ¨ä¸€ä¸ªç‰‡æ®µä¸­ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸² &quot;ababcc&quot; èƒ½å¤Ÿè¢«åˆ†ä¸º [&quot;abab&quot;, &quot;cc&quot;]ï¼Œä½†ç±»ä¼¼ [&quot;aba&quot;, &quot;bcc&quot;] æˆ– [&quot;ab&quot;, &quot;ab&quot;, &quot;cc&quot;] çš„åˆ’åˆ†æ˜¯éæ³•çš„ã€‚ æ³¨æ„ï¼Œåˆ’åˆ†ç»“æœéœ€è¦æ»¡è¶³ï¼šå°†æ‰€æœ‰åˆ’åˆ†ç»“æœæŒ‰é¡ºåºè¿æ¥ï¼Œå¾—åˆ°çš„å­—ç¬¦ä¸²ä»ç„¶æ˜¯ s ã€‚ è¿”å›ä¸€ä¸ªè¡¨ç¤ºæ¯ä¸ªå­—ç¬¦ä¸²ç‰‡æ®µçš„é•¿åº¦çš„åˆ—è¡¨ã€‚ // ç”¨å“ˆå¸Œè¡¨è®°å½•æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æœ€åä½ç½® // ç»Ÿè®¡æ¯ä¸€ä¸ªå­—ç¬¦æœ€åå‡ºç°çš„ä½ç½® // ä»å¤´éå†å­—ç¬¦ï¼Œå¹¶æ›´æ–°å­—ç¬¦çš„æœ€è¿œå‡ºç°ä¸‹æ ‡ï¼Œå¦‚æœæ‰¾åˆ°å­—ç¬¦æœ€è¿œå‡ºç°ä½ç½®ä¸‹æ ‡å’Œå½“å‰ä¸‹æ ‡ç›¸ç­‰äº†ï¼Œåˆ™æ‰¾åˆ°äº†åˆ†å‰²ç‚¹ class Solution &#123; public: vector&lt;int> partitionLabels(string s) &#123; vector&lt;int> hash(27,0); for (int i = 0; i &lt; s.size(); i++)&#123; hash[s[i] - 'a'] = i; &#125; int maxindex = 0; vector&lt;int> result; int left = 0; for (int right = 0; right &lt; s.size(); right++)&#123; maxindex = max(maxindex, hash[s[right] - 'a']); if (right == maxindex)&#123; result.push_back(right - left + 1); left = right + 1; &#125; &#125; return result; &#125; &#125;; 9.15 åˆå¹¶åŒºé—´ä»¥æ•°ç»„ intervals è¡¨ç¤ºè‹¥å¹²ä¸ªåŒºé—´çš„é›†åˆï¼Œå…¶ä¸­å•ä¸ªåŒºé—´ä¸º intervals[i] = [starti, endi] ã€‚è¯·ä½ åˆå¹¶æ‰€æœ‰é‡å çš„åŒºé—´ï¼Œå¹¶è¿”å› ä¸€ä¸ªä¸é‡å çš„åŒºé—´æ•°ç»„ï¼Œè¯¥æ•°ç»„éœ€æ°å¥½è¦†ç›–è¾“å…¥ä¸­çš„æ‰€æœ‰åŒºé—´ ã€‚ class Solution &#123; public: static bool cmp(const vector&lt;int> &amp;a, const vector&lt;int> &amp;b)&#123; if (a[0] == b[0] ) return a[1] &lt; b[1]; return a[0] &lt; b[0]; &#125; vector&lt;vector&lt;int>> merge(vector&lt;vector&lt;int>>&amp; intervals) &#123; vector&lt;vector&lt;int>> result; vector&lt;int> ele(2,0); sort(intervals.begin(), intervals.end(), cmp); int right = intervals[0][1]; int left = intervals[0][0]; for (int i = 0; i &lt; intervals.size() - 1; i++)&#123; if (intervals[i+1][0] &lt;= right)&#123; right = max(intervals[i+1][1], right); &#125; else&#123; ele[0] = left; ele[1] = right; result.push_back(ele); left = intervals[i+1][0]; right = intervals[i+1][1]; &#125; &#125; //æœ€åä¸€é¡¹ä¹Ÿæ”¾è¿›å» ele[0] = left; ele[1] = right; result.push_back(ele); return result; &#125; &#125;; 9.16 å•è°ƒé€’å¢çš„æ•°å­—å½“ä¸”ä»…å½“æ¯ä¸ªç›¸é‚»ä½æ•°ä¸Šçš„æ•°å­— x å’Œ y æ»¡è¶³ x &lt;= y æ—¶ï¼Œæˆ‘ä»¬ç§°è¿™ä¸ªæ•´æ•°æ˜¯å•è°ƒé€’å¢çš„ã€‚ ç»™å®šä¸€ä¸ªæ•´æ•° n ï¼Œè¿”å› å°äºæˆ–ç­‰äº n çš„æœ€å¤§æ•°å­—ï¼Œä¸”æ•°å­—å‘ˆ å•è°ƒé€’å¢ ã€‚ //æœ¬é¢˜ç”¨å­—ç¬¦ä¸²å°±ä¸éœ€è¦è€ƒè™‘æ•°æ®å¤§å°çš„é—®é¢˜äº† class Solution &#123; public: int monotoneIncreasingDigits(int n) &#123; if (n == 0) return 0; vector&lt;int> nums; while (n > 0)&#123; int num = n % 10; n = n / 10; nums.push_back(num); &#125; for (int i = 0; i &lt; nums.size()-1; i++)&#123; if (nums[i] &lt; nums[i+1])&#123; for (int j = 0; j &lt;= i; j++) nums[j] = 9; nums[i+1] = nums[i+1] - 1; &#125; &#125; int sum = 0; //æµ‹è¯•ä¾‹æœ‰è¾ƒå¤§æ•°æ®ï¼Œç”¨long long weight = 1; for (int i = 0; i &lt; nums.size(); i++)&#123; sum += nums[i] * weight; weight *= 10; &#125; return sum; &#125; &#125;; 9.17 ç›‘æ§äºŒå‰æ ‘ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæˆ‘ä»¬åœ¨æ ‘çš„èŠ‚ç‚¹ä¸Šå®‰è£…æ‘„åƒå¤´ã€‚ èŠ‚ç‚¹ä¸Šçš„æ¯ä¸ªæ‘„å½±å¤´éƒ½å¯ä»¥ç›‘è§†å…¶çˆ¶å¯¹è±¡ã€è‡ªèº«åŠå…¶ç›´æ¥å­å¯¹è±¡ã€‚ è®¡ç®—ç›‘æ§æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹æ‰€éœ€çš„æœ€å°æ‘„åƒå¤´æ•°é‡ã€‚ //éš¾åº¦é«˜ //è´ªå¿ƒæ€æƒ³ï¼šä»å¶å­èŠ‚ç‚¹å‘ä¸Šæœç´¢ï¼Œå¶å­èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹éœ€è¦å®‰è£…ï¼Œå†å¾€ä¸Šæ¯éš”2ä¸ªèŠ‚ç‚¹æ”¾ä¸€ä¸ª //0ï¼šè¯¥èŠ‚ç‚¹æ— è¦†ç›– //1ï¼šæœ¬èŠ‚ç‚¹æœ‰æ‘„åƒå¤´ //2ï¼šæœ¬èŠ‚ç‚¹æœ‰è¦†ç›– class Solution &#123; private: int result; int traversal(TreeNode* cur) &#123; // ç©ºèŠ‚ç‚¹ï¼Œè¯¥èŠ‚ç‚¹æœ‰è¦†ç›– if (cur == NULL) return 2; int left = traversal(cur->left); // å·¦ int right = traversal(cur->right); // å³ // æƒ…å†µ1 // å·¦å³èŠ‚ç‚¹éƒ½æœ‰è¦†ç›– if (left == 2 &amp;&amp; right == 2) return 0; // æƒ…å†µ2 // left == 0 &amp;&amp; right == 0 å·¦å³èŠ‚ç‚¹æ— è¦†ç›– // left == 1 &amp;&amp; right == 0 å·¦èŠ‚ç‚¹æœ‰æ‘„åƒå¤´ï¼Œå³èŠ‚ç‚¹æ— è¦†ç›– // left == 0 &amp;&amp; right == 1 å·¦èŠ‚ç‚¹æœ‰æ— è¦†ç›–ï¼Œå³èŠ‚ç‚¹æ‘„åƒå¤´ // left == 0 &amp;&amp; right == 2 å·¦èŠ‚ç‚¹æ— è¦†ç›–ï¼Œå³èŠ‚ç‚¹è¦†ç›– // left == 2 &amp;&amp; right == 0 å·¦èŠ‚ç‚¹è¦†ç›–ï¼Œå³èŠ‚ç‚¹æ— è¦†ç›– if (left == 0 || right == 0) &#123; result++; return 1; &#125; // æƒ…å†µ3 // left == 1 &amp;&amp; right == 2 å·¦èŠ‚ç‚¹æœ‰æ‘„åƒå¤´ï¼Œå³èŠ‚ç‚¹æœ‰è¦†ç›– // left == 2 &amp;&amp; right == 1 å·¦èŠ‚ç‚¹æœ‰è¦†ç›–ï¼Œå³èŠ‚ç‚¹æœ‰æ‘„åƒå¤´ // left == 1 &amp;&amp; right == 1 å·¦å³èŠ‚ç‚¹éƒ½æœ‰æ‘„åƒå¤´ // å…¶ä»–æƒ…å†µå‰æ®µä»£ç å‡å·²è¦†ç›– if (left == 1 || right == 1) return 2; // è¿™ä¸ª return -1 é€»è¾‘ä¸ä¼šèµ°åˆ°è¿™é‡Œã€‚ return -1; &#125; public: int minCameraCover(TreeNode* root) &#123; result = 0; // æƒ…å†µ4 if (traversal(root) == 0) &#123; // root æ— è¦†ç›– result++; &#125; return result; &#125; &#125;; 10. åŠ¨æ€è§„åˆ’åŠ¨æ€è§„åˆ’ä¸­æ¯ä¸€ä¸ªçŠ¶æ€ä¸€å®šæ˜¯ç”±ä¸Šä¸€ä¸ªçŠ¶æ€æ¨å¯¼å‡ºæ¥çš„ï¼Œè¿™ä¸€ç‚¹åŒºåˆ†äºè´ªå¿ƒï¼Œè´ªå¿ƒæ²¡æœ‰çŠ¶æ€æ¨å¯¼ï¼Œè€Œæ˜¯ä»å±€éƒ¨ç›´æ¥é€‰æœ€ä¼˜çš„ã€‚ 10.1 æ–æ³¢é‚£å¥‘æ•°æ–æ³¢é‚£å¥‘æ•° ï¼ˆé€šå¸¸ç”¨ F(n) è¡¨ç¤ºï¼‰å½¢æˆçš„åºåˆ—ç§°ä¸º æ–æ³¢é‚£å¥‘æ•°åˆ— ã€‚è¯¥æ•°åˆ—ç”± 0 å’Œ 1 å¼€å§‹ï¼Œåé¢çš„æ¯ä¸€é¡¹æ•°å­—éƒ½æ˜¯å‰é¢ä¸¤é¡¹æ•°å­—çš„å’Œã€‚ä¹Ÿå°±æ˜¯ï¼š F(0) &#x3D; 0ï¼ŒF(1) &#x3D; 1 F(n) &#x3D; F(n - 1) + F(n - 2)ï¼Œå…¶ä¸­ n &gt; 1 ç»™å®š n ï¼Œè¯·è®¡ç®— F(n) ã€‚ class Solution &#123; public: int fib(int n) &#123; if (n == 0 ) return 0; if (n == 1 ) return 1; return (fib(n-1) + fib(n-2)); &#125; &#125;; //dp å½¢å¼ class Solution &#123; public: int fib(int n) &#123; if (n == 0 ) return 0; if (n == 1 ) return 1; vector&lt;int> dp(n+1,0); dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= n; i++)&#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n]; &#125; &#125;; // é€’å½’æ¯”dpæ•ˆç‡ä½ï¼Œå› ä¸ºå¾ˆå¤šå€¼è¢«é‡å¤è®¡ç®—äº†å¤šæ¬¡ 10.2 çˆ¬æ¥¼æ¢¯å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ n é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚ æ¯æ¬¡ä½ å¯ä»¥çˆ¬ 1 æˆ– 2 ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ class Solution &#123; public: int climbStairs(int n) &#123; if (n &lt;= 1) return n; // å› ä¸ºä¸‹é¢ç›´æ¥å¯¹dp[2]æ“ä½œäº†ï¼Œé˜²æ­¢ç©ºæŒ‡é’ˆ vector&lt;int> dp(n+1,0); dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++)&#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n]; &#125; &#125;; 10.3 ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ cost ï¼Œå…¶ä¸­ cost[i] æ˜¯ä»æ¥¼æ¢¯ç¬¬ i ä¸ªå°é˜¶å‘ä¸Šçˆ¬éœ€è¦æ”¯ä»˜çš„è´¹ç”¨ã€‚ä¸€æ—¦ä½ æ”¯ä»˜æ­¤è´¹ç”¨ï¼Œå³å¯é€‰æ‹©å‘ä¸Šçˆ¬ä¸€ä¸ªæˆ–è€…ä¸¤ä¸ªå°é˜¶ã€‚ ä½ å¯ä»¥é€‰æ‹©ä»ä¸‹æ ‡ä¸º 0 æˆ–ä¸‹æ ‡ä¸º 1 çš„å°é˜¶å¼€å§‹çˆ¬æ¥¼æ¢¯ã€‚ è¯·ä½ è®¡ç®—å¹¶è¿”å›è¾¾åˆ°æ¥¼æ¢¯é¡¶éƒ¨çš„æœ€ä½èŠ±è´¹ã€‚ class Solution &#123; public: int minCostClimbingStairs(vector&lt;int>&amp; cost) &#123; vector&lt;int> dp(cost.size()+2,0); dp[0] = 0; dp[1] = 0; for (int i = 2; i &lt;= cost.size(); i++)&#123; dp[i] = min(dp[i-1] + cost[i-1] , dp[i-2] + cost[i-2]); &#125; return dp[cost.size()]; &#125; &#125;; 10.4 ä¸åŒè·¯å¾„ä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ ï¼ˆèµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸º â€œStartâ€ ï¼‰ã€‚ æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼ˆåœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸º â€œFinishâ€ ï¼‰ã€‚ é—®æ€»å…±æœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ class Solution &#123; public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int>> dp(m,vector&lt;int> (n,0)); for (int i = 0; i &lt; n; i++)&#123; dp[0][i] = 1; &#125; for (int i = 0; i &lt; m; i++)&#123; dp[i][0] = 1; &#125; for (int i = 1; i &lt; m ; i++)&#123; for (int j = 1; j &lt; n; j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125; &#125;; 10.5 ä¸åŒè·¯å¾„â…¡ç»™å®šä¸€ä¸ª m x n çš„æ•´æ•°æ•°ç»„ gridã€‚ä¸€ä¸ªæœºå™¨äººåˆå§‹ä½äº å·¦ä¸Šè§’ï¼ˆå³ grid[0][0]ï¼‰ã€‚æœºå™¨äººå°è¯•ç§»åŠ¨åˆ° å³ä¸‹è§’ï¼ˆå³ grid[m - 1][n - 1]ï¼‰ã€‚æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚ ç½‘æ ¼ä¸­çš„éšœç¢ç‰©å’Œç©ºä½ç½®åˆ†åˆ«ç”¨ 1 å’Œ 0 æ¥è¡¨ç¤ºã€‚æœºå™¨äººçš„ç§»åŠ¨è·¯å¾„ä¸­ä¸èƒ½åŒ…å« ä»»ä½• æœ‰éšœç¢ç‰©çš„æ–¹æ ¼ã€‚ è¿”å›æœºå™¨äººèƒ½å¤Ÿåˆ°è¾¾å³ä¸‹è§’çš„ä¸åŒè·¯å¾„æ•°é‡ã€‚ æµ‹è¯•ç”¨ä¾‹ä¿è¯ç­”æ¡ˆå°äºç­‰äº 2 * 109ã€‚ class Solution &#123; public: int uniquePathsWithObstacles(vector&lt;vector&lt;int>>&amp; obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector&lt;vector&lt;int>> dp(m, vector&lt;int>(n,0)); for (int i = 0; i &lt; m; i++) &#123; if (obstacleGrid[i][0] == 0) dp[i][0] = 1; if (obstacleGrid[i][0] == 1) &#123; for (int j = i; j &lt; m; j++) dp[j][0] = 0; break; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (obstacleGrid[0][i] == 0) dp[0][i] = 1; if (obstacleGrid[0][i] == 1) &#123; for (int j = i; j &lt; n; j++) dp[0][j] = 0; break; &#125; &#125; for (int i = 1; i &lt; m; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; if (obstacleGrid[i][j])&#123; dp[i][j] = 0; &#125; else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125; &#125;; 10.6 æ•´æ•°æ‹†åˆ†ç»™å®šä¸€ä¸ªæ­£æ•´æ•° n ï¼Œå°†å…¶æ‹†åˆ†ä¸º k ä¸ª æ­£æ•´æ•° çš„å’Œï¼ˆ k &gt;= 2 ï¼‰ï¼Œå¹¶ä½¿è¿™äº›æ•´æ•°çš„ä¹˜ç§¯æœ€å¤§åŒ–ã€‚ è¿”å› ä½ å¯ä»¥è·å¾—çš„æœ€å¤§ä¹˜ç§¯ ã€‚ // æ‹†åˆ†æˆ2ä¸ªæ•°å’Œ3ä¸ªæ•°åŠä»¥ä¸Šçš„æƒ…å†µ class Solution &#123; public: int integerBreak(int n) &#123; vector&lt;int> dp(n+1,0); dp[2] = 1; dp[1] = 1; for (int i = 3; i &lt;= n; i++)&#123; for (int j = 1; j &lt; i ; j++)&#123; //é¦–ä¸ªmax():å†…å±‚éå† ç¬¬äºŒä¸ªmax():æ¯”è¾ƒ2ä¸ªæ•°å’Œå¤šä¸ªæ•°å¤§å° dp[i] = max( dp[i] , max(j*(i-j), j*dp[i-j])); &#125; &#125; return dp[n]; &#125; &#125;; 10.7 ä¸åŒçš„äºŒå‰æœç´¢æ ‘ç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œæ±‚æ°ç”± n ä¸ªèŠ‚ç‚¹ç»„æˆä¸”èŠ‚ç‚¹å€¼ä» 1 åˆ° n äº’ä¸ç›¸åŒçš„ äºŒå‰æœç´¢æ ‘ æœ‰å¤šå°‘ç§ï¼Ÿè¿”å›æ»¡è¶³é¢˜æ„çš„äºŒå‰æœç´¢æ ‘çš„ç§æ•°ã€‚ class Solution &#123; public: int numTrees(int n) &#123; vector&lt;int> dp(n+1, 0); if (n &lt;= 2) return n; dp[0] = 1; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++)&#123; for (int j = 0; j &lt; i; j++)&#123; dp[i] += dp[j] * dp[i - j - 1]; &#125; &#125; return dp[n]; &#125; &#125;; 10.8 01èƒŒåŒ…é—®é¢˜å°æ˜éœ€è¦å¸¦ä¸€äº›ç ”ç©¶ææ–™ï¼Œä½†æ˜¯ä»–çš„è¡Œæç®±ç©ºé—´æœ‰é™ã€‚è¿™äº›ç ”ç©¶ææ–™åŒ…æ‹¬å®éªŒè®¾å¤‡ã€æ–‡çŒ®èµ„æ–™å’Œå®éªŒæ ·æœ¬ç­‰ç­‰ï¼Œå®ƒä»¬å„è‡ªå æ®ä¸åŒçš„ç©ºé—´ï¼Œå¹¶ä¸”å…·æœ‰ä¸åŒçš„ä»·å€¼ã€‚ å°æ˜çš„è¡Œæç©ºé—´ä¸º Nï¼Œé—®å°æ˜åº”è¯¥å¦‚ä½•æŠ‰æ‹©ï¼Œæ‰èƒ½æºå¸¦æœ€å¤§ä»·å€¼çš„ç ”ç©¶ææ–™ï¼Œæ¯ç§ç ”ç©¶ææ–™åªèƒ½é€‰æ‹©ä¸€æ¬¡ï¼Œå¹¶ä¸”åªæœ‰é€‰ä¸ä¸é€‰ä¸¤ç§é€‰æ‹©ï¼Œä¸èƒ½è¿›è¡Œåˆ‡å‰²ã€‚ è¾“å…¥æè¿°ï¼š ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•°ï¼Œç¬¬ä¸€ä¸ªæ•´æ•° M ä»£è¡¨ç ”ç©¶ææ–™çš„ç§ç±»ï¼Œç¬¬äºŒä¸ªæ­£æ•´æ•° Nï¼Œä»£è¡¨å°æ˜çš„è¡Œæç©ºé—´ã€‚ ç¬¬äºŒè¡ŒåŒ…å« M ä¸ªæ­£æ•´æ•°ï¼Œä»£è¡¨æ¯ç§ç ”ç©¶ææ–™çš„æ‰€å ç©ºé—´ã€‚ ç¬¬ä¸‰è¡ŒåŒ…å« M ä¸ªæ­£æ•´æ•°ï¼Œä»£è¡¨æ¯ç§ç ”ç©¶ææ–™çš„ä»·å€¼ã€‚ è¾“å‡ºæ•´æ•°ä»£è¡¨å°æ˜èƒ½å¤Ÿæºå¸¦çš„ç ”ç©¶ææ–™çš„æœ€å¤§ä»·å€¼ã€‚ #include &lt;iostream> #include &lt;vector> using namespace std; int main()&#123; int type, luggage; cin >> type >> luggage; vector&lt;int> space(type,0); vector&lt;int> value(type,0); for (int i = 0; i &lt; type; i++)&#123; cin >> space[i]; &#125; for (int i = 0; i &lt; type; i++)&#123; cin >> value[i]; &#125; vector&lt;vector&lt;int>> dp(type, vector&lt;int>(luggage + 1,0)); //åˆå§‹åŒ–dp //1. dp[i][0] for(int i = 0; i &lt; type; i++)&#123; dp[i][0] = 0; &#125; //2. dp[0][j] for (int j = space[0]; j &lt; luggage + 1; j++)&#123; dp[0][j] = value[0]; &#125; //é€’æ¨,dp[i][j] è¡¨ç¤ºåœ¨jçš„ç©ºé—´ä¸‹ï¼Œåœ¨å‰iç§é€‰æ‹©é‡Œèƒ½è¾¾åˆ°çš„æœ€å¤§ä»·å€¼ // æœ‰ä¸¤ç§æƒ…å†µï¼Œ1æ˜¯å–içš„ç‰©å“ï¼Œ2æ˜¯ä¸å– for (int i = 1; i &lt; type; i++)&#123; for (int j = 0; j &lt; luggage+1; j++)&#123; if (j >= space[i]) dp[i][j] = max(dp[i-1][j] , dp[i-1][j-space[i]] + value[i]); else dp[i][j] = dp[i-1][j]; //cout &lt;&lt; dp[i][j]&lt;&lt; ' '; &#125; &#125; cout &lt;&lt; dp[type-1][luggage]; return 0; &#125; // ä¸€ç»´å‹ç¼© è¿™é‡Œä½¿ç”¨é€’å‡çš„åŸå› æ˜¯äºŒç»´çŠ¶æ€è½¬ç§»æ—¶å·¦ä¸Šæ–¹æ•°å€¼éœ€è¦ä¿ç•™ä»¥ç”¨æ¥å‚è€ƒï¼Œåˆ™ä¸€ç»´éœ€è¦ä¿ç•™å·¦ä¾§æ•°å€¼å‚è€ƒ #include &lt;iostream> #include &lt;vector> using namespace std; int main()&#123; int type, luggage; cin >> type >> luggage; vector&lt;int> space(type,0); vector&lt;int> value(type,0); for (int i = 0; i &lt; type; i++)&#123; cin >> space[i]; &#125; for (int i = 0; i &lt; type; i++)&#123; cin >> value[i]; &#125; //åˆå§‹åŒ– vector&lt;int> dp(luggage + 1,0); // æ–°å¢ä¸€å±‚ç‰©å“çŠ¶æ€æ¥æºäºä¸Šä¸€å±‚çŠ¶æ€ for (int i = 0; i &lt; type; i++)&#123; for (int j = luggage; j >= space[i]; j--)&#123; dp[j] = max(dp[j] , dp[j-space[i]] + value[i]); &#125; &#125; cout &lt;&lt; dp[luggage]; return 0; &#125; 10.9 åˆ†å‰²ç­‰å’Œå­é›†ç»™ä½ ä¸€ä¸ª åªåŒ…å«æ­£æ•´æ•° çš„ éç©º æ•°ç»„ nums ã€‚è¯·ä½ åˆ¤æ–­æ˜¯å¦å¯ä»¥å°†è¿™ä¸ªæ•°ç»„åˆ†å‰²æˆä¸¤ä¸ªå­é›†ï¼Œä½¿å¾—ä¸¤ä¸ªå­é›†çš„å…ƒç´ å’Œç›¸ç­‰ã€‚ class Solution &#123; public: bool canPartition(vector&lt;int>&amp; nums) &#123; vector&lt;int> dp(10001,0); int sum = 0; int target = 0; for (int i = 0; i &lt; nums.size(); i++)&#123; sum += nums[i]; &#125; if (sum % 2) return false; else target = sum / 2; for (int i = 0; i &lt; nums.size(); i++)&#123; for (int j = target; j >= nums[i]; j--)&#123; dp[j] = max(dp[j], dp[j-nums[i]] + nums[i]); &#125; &#125; //åˆ¤æ–­èƒ½å¦åˆ†å‰²ï¼Œçœ‹ sumçš„ä¸€åŠ èƒŒåŒ…èƒ½å¦è¢«è£…æ»¡ if (dp[target] == target) return true; return false; &#125; &#125;; 10.10 æœ€åä¸€å—çŸ³å¤´çš„é‡é‡â…¡æœ‰ä¸€å †çŸ³å¤´ï¼Œç”¨æ•´æ•°æ•°ç»„ stones è¡¨ç¤ºã€‚å…¶ä¸­ stones[i] è¡¨ç¤ºç¬¬ i å—çŸ³å¤´çš„é‡é‡ã€‚ æ¯ä¸€å›åˆï¼Œä»ä¸­é€‰å‡ºä»»æ„ä¸¤å—çŸ³å¤´ï¼Œç„¶åå°†å®ƒä»¬ä¸€èµ·ç²‰ç¢ã€‚å‡è®¾çŸ³å¤´çš„é‡é‡åˆ†åˆ«ä¸º x å’Œ yï¼Œä¸” x &lt;= yã€‚é‚£ä¹ˆç²‰ç¢çš„å¯èƒ½ç»“æœå¦‚ä¸‹ï¼š å¦‚æœ x == yï¼Œé‚£ä¹ˆä¸¤å—çŸ³å¤´éƒ½ä¼šè¢«å®Œå…¨ç²‰ç¢ï¼› å¦‚æœ x != yï¼Œé‚£ä¹ˆé‡é‡ä¸º x çš„çŸ³å¤´å°†ä¼šå®Œå…¨ç²‰ç¢ï¼Œè€Œé‡é‡ä¸º y çš„çŸ³å¤´æ–°é‡é‡ä¸º y-xã€‚ æœ€åï¼Œæœ€å¤šåªä¼šå‰©ä¸‹ä¸€å— çŸ³å¤´ã€‚è¿”å›æ­¤çŸ³å¤´ æœ€å°çš„å¯èƒ½é‡é‡ ã€‚å¦‚æœæ²¡æœ‰çŸ³å¤´å‰©ä¸‹ï¼Œå°±è¿”å› 0ã€‚ class Solution &#123; public: int lastStoneWeightII(vector&lt;int>&amp; stones) &#123; vector&lt;int> dp(15001,0); int sum = 0; int target = 0; for (int i = 0; i &lt; stones.size(); i++)&#123; sum += stones[i]; &#125; target = sum / 2; for (int i = 0; i &lt; stones.size(); i++)&#123; for (int j = target; j >= stones[i]; j--)&#123; dp[j] = max(dp[j], dp[j-stones[i]] + stones[i]); &#125; &#125; return (sum - dp[target]) - dp[target]; &#125; &#125;; 10.11 ç›®æ ‡å’Œç»™ä½ ä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° target ã€‚ å‘æ•°ç»„ä¸­çš„æ¯ä¸ªæ•´æ•°å‰æ·»åŠ  &#39;+&#39; æˆ– &#39;-&#39; ï¼Œç„¶åä¸²è”èµ·æ‰€æœ‰æ•´æ•°ï¼Œå¯ä»¥æ„é€ ä¸€ä¸ª è¡¨è¾¾å¼ ï¼š ä¾‹å¦‚ï¼Œnums = [2, 1] ï¼Œå¯ä»¥åœ¨ 2 ä¹‹å‰æ·»åŠ  &#39;+&#39; ï¼Œåœ¨ 1 ä¹‹å‰æ·»åŠ  &#39;-&#39; ï¼Œç„¶åä¸²è”èµ·æ¥å¾—åˆ°è¡¨è¾¾å¼ &quot;+2-1&quot; ã€‚ è¿”å›å¯ä»¥é€šè¿‡ä¸Šè¿°æ–¹æ³•æ„é€ çš„ã€è¿ç®—ç»“æœç­‰äº target çš„ä¸åŒ è¡¨è¾¾å¼ çš„æ•°ç›®ã€‚ class Solution &#123; public: int findTargetSumWays(vector&lt;int>&amp; nums, int target) &#123; int sum = 0; for (int i = 0; i &lt; nums.size(); i++)&#123; sum += nums[i]; &#125; if (abs(target) > sum) return 0; if ((sum + target) % 2) return 0; int bagsize = (sum + target) / 2; vector&lt;int> dp(bagsize+1,0); dp[0] = 1; for (int i = 0; i &lt; nums.size();i++)&#123; for (int j = bagsize; j>=nums[i]; j--)&#123; // ç»„åˆé—®é¢˜ç”¨äºŒç»´çš„æ–¹å¼å…ˆæ€è€ƒä¸€é dp[j] = dp[j] + dp[j-nums[i]]; &#125; &#125; return dp[bagsize]; &#125; &#125;; 10.12 ä¸€å’Œé›¶ç»™ä½ ä¸€ä¸ªäºŒè¿›åˆ¶å­—ç¬¦ä¸²æ•°ç»„ strs å’Œä¸¤ä¸ªæ•´æ•° m å’Œ n ã€‚ è¯·ä½ æ‰¾å‡ºå¹¶è¿”å› strs çš„æœ€å¤§å­é›†çš„é•¿åº¦ï¼Œè¯¥å­é›†ä¸­ æœ€å¤š æœ‰ m ä¸ª 0 å’Œ n ä¸ª 1 ã€‚ å¦‚æœ x çš„æ‰€æœ‰å…ƒç´ ä¹Ÿæ˜¯ y çš„å…ƒç´ ï¼Œé›†åˆ x æ˜¯é›†åˆ y çš„ å­é›† ã€‚ //ç›¸å½“äºç‰©å“æœ‰ä¸¤ä¸ªç»´åº¦çš„é‡é‡ class Solution &#123; public: int findMaxForm(vector&lt;string>&amp; strs, int m, int n) &#123; vector&lt;vector&lt;int>> dp(m+1, vector&lt;int>(n+1,0)); for (auto &amp;s : strs)&#123; int zeronum = 0; int onenum = 0; for (auto &amp;ch : s)&#123; if (ch == '0') zeronum ++; else onenum ++; &#125; //å‘åéå†åŸå› ï¼šå®é™…ä¸Šè¿™ä¸¤å±‚forå¾ªç¯éƒ½æ˜¯åœ¨éå†èƒŒåŒ…ï¼Œåˆæ ¹æ®é€’æ¨å¼å¯çŸ¥åä¸€æ¬¡éå†çš„å€¼éœ€è¦å’Œä¹‹å‰çš„å·¦ä¸Šæ–¹å¯¹æ¯”ï¼Œå› æ­¤éœ€è¦ä»åå‘å‰éå† for (int i = m; i >= zeronum; i--)&#123; for(int j = n; j >= onenum; j--)&#123; dp[i][j] = max(dp[i][j], dp[i-zeronum][j-onenum] + 1); &#125; &#125; &#125; return dp[m][n]; &#125; &#125;; 10.13 å®Œå…¨èƒŒåŒ…å°æ˜éœ€è¦å¸¦ä¸€äº›ç ”ç©¶ææ–™ï¼Œä½†æ˜¯ä»–çš„è¡Œæç®±ç©ºé—´æœ‰é™ã€‚è¿™äº›ç ”ç©¶ææ–™åŒ…æ‹¬å®éªŒè®¾å¤‡ã€æ–‡çŒ®èµ„æ–™å’Œå®éªŒæ ·æœ¬ç­‰ç­‰ï¼Œå®ƒä»¬å„è‡ªå æ®ä¸åŒçš„é‡é‡ï¼Œå¹¶ä¸”å…·æœ‰ä¸åŒçš„ä»·å€¼ã€‚ å°æ˜çš„è¡Œæç®±æ‰€èƒ½æ‰¿æ‹…çš„æ€»é‡é‡æ˜¯æœ‰é™çš„ï¼Œé—®å°æ˜åº”è¯¥å¦‚ä½•æŠ‰æ‹©ï¼Œæ‰èƒ½æºå¸¦æœ€å¤§ä»·å€¼çš„ç ”ç©¶ææ–™ï¼Œæ¯ç§ç ”ç©¶ææ–™å¯ä»¥é€‰æ‹©æ— æ•°æ¬¡ï¼Œå¹¶ä¸”å¯ä»¥é‡å¤é€‰æ‹©ã€‚ è¾“å…¥æè¿° ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•°ï¼Œnï¼Œvï¼Œåˆ†åˆ«è¡¨ç¤ºç ”ç©¶ææ–™çš„ç§ç±»å’Œè¡Œææ‰€èƒ½æ‰¿æ‹…çš„æ€»é‡é‡ æ¥ä¸‹æ¥åŒ…å« n è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ•´æ•° wi å’Œ viï¼Œä»£è¡¨ç¬¬ i ç§ç ”ç©¶ææ–™çš„é‡é‡å’Œä»·å€¼ // ç”±äº å¯ä»¥é‡å¤å– è¿™ä¸€ç‰¹æ€§ï¼Œdpåˆå§‹åŒ–ä¸é€’å½’å¼ä¸01èƒŒåŒ…ä¸åŒ #include &lt;iostream> #include &lt;vector> using namespace std; int main()&#123; int type, bagsize; cin >> type >> bagsize; vector&lt;int> weight(type, 0); vector&lt;int> value(type, 0); for (int i = 0; i &lt; type; i++) cin >> weight[i]>> value[i]; vector&lt;vector&lt;int>> dp(type , vector&lt;int>(bagsize + 1, 0)); // åˆå§‹åŒ– for (int j = weight[0]; j &lt;= bagsize; j++) dp[0][j] = dp[0][j - weight[0]] + value[0]; for (int i = 1; i &lt; type; i++)&#123; for (int j = 0; j &lt;= bagsize; j++)&#123; if (j >= weight[i]) // è¿™é‡Œé€’å½’å¼éœ€è¦æ³¨æ„ä¹Ÿå¯ä»¥å–å½“å‰è¡Œçš„ dp[i][j] = max(dp[i-1][j], dp[i][j - weight[i]] + value[i]); else dp[i][j] = dp[i-1][j]; &#125; &#125; cout &lt;&lt; dp[type - 1][bagsize] &lt;&lt; endl; &#125; 10.14 é›¶é’±å…‘æ¢â…¡ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ coins è¡¨ç¤ºä¸åŒé¢é¢çš„ç¡¬å¸ï¼Œå¦ç»™ä¸€ä¸ªæ•´æ•° amount è¡¨ç¤ºæ€»é‡‘é¢ã€‚ è¯·ä½ è®¡ç®—å¹¶è¿”å›å¯ä»¥å‡‘æˆæ€»é‡‘é¢çš„ç¡¬å¸ç»„åˆæ•°ã€‚å¦‚æœä»»ä½•ç¡¬å¸ç»„åˆéƒ½æ— æ³•å‡‘å‡ºæ€»é‡‘é¢ï¼Œè¿”å› 0 ã€‚ å‡è®¾æ¯ä¸€ç§é¢é¢çš„ç¡¬å¸æœ‰æ— é™ä¸ªã€‚ é¢˜ç›®æ•°æ®ä¿è¯ç»“æœç¬¦åˆ 32 ä½å¸¦ç¬¦å·æ•´æ•°ã€‚ class Solution &#123; public: int change(int amount, vector&lt;int>&amp; coins) &#123; // ç”¨uint64_t åº”å¯¹æœ€åä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ vector&lt;vector&lt;uint64_t>> dp(coins.size(), vector&lt;uint64_t>(amount + 1,0)); // åˆå§‹åŒ– for (int i = 0; i &lt; coins.size(); i++) dp[i][0] = 1; for (int i = 0; i &lt;= amount; i++)&#123; if (i % coins[0] == 0) dp[0][i] =1; &#125; // é€’æ¨ for (int i = 1; i &lt; coins.size(); i++)&#123; for (int j = 0; j &lt;= amount; j++ )&#123; if (j >= coins[i]) dp[i][j] = dp[i-1][j] + dp[i][ j - coins[i]]; else dp[i][j] = dp[i-1][j]; &#125; &#125; return dp[coins.size() - 1][amount]; &#125; &#125;; //ä¸€ç»´dp // å¯å‹ç¼©åŸå› ï¼šå°½ç®¡ä»é€’æ¨å…¬å¼ä¸Šçœ‹ï¼Œdp[i][j]ç”±å‰ä¸€è¡Œå’Œæœ¬è¡Œå…±åŒå†³å®šï¼Œè²Œä¼¼ä¸èƒ½å‹ç¼©ï¼Œä½†æ˜¯å…¶å®ç”±äºå®Œå…¨èƒŒåŒ…çš„ç‰¹æ€§ï¼Œåªè¦ä»å‰å‘åéå†ï¼Œå°±èƒ½ä¿ç•™æœ¬è¡Œçš„ç»“æœ class Solution &#123; public: int change(int amount, vector&lt;int>&amp; coins) &#123; vector&lt;uint64_t> dp(amount + 1,0); // åˆå§‹åŒ– dp[0] = 1; // é€’æ¨ for (int i = 0; i &lt; coins.size(); i++)&#123; for (int j = 0; j &lt;= amount; j++ )&#123; if (j >= coins[i]) dp[j] += dp[j - coins[i]]; else dp[j] = dp[j]; &#125; &#125; return dp[amount]; &#125; &#125;; // ä¸€ç»´å®Œå…¨èƒŒåŒ…dpé€’æ¨ä¸€ä¸ªé‡è¦çš„æ€§è´¨ï¼Œå°†å†…å¤–å¾ªç¯é¡ºåºå¯¹æ¢åï¼Œæ˜¯ç»„åˆä¸æ’åˆ—çš„åŒºåˆ« //ç»„åˆæ•°çš„é€’æ¨ï¼š //dp[j] åªä¾èµ–äºä¹‹å‰å·²ç»è®¡ç®—è¿‡çš„ç»„åˆï¼Œä¸ä¼šäº§ç”Ÿé‡å¤çš„é¡ºåºæ’åˆ— //æ’åˆ—æ•°çš„é€’æ¨ï¼š //å¯¹äºæ¯ä¸ªé‡‘é¢jï¼Œéƒ½ä¼šè€ƒè™‘æ‰€æœ‰å¯èƒ½çš„ç¡¬å¸ä½œä¸ºæœ€åä¸€æ­¥ï¼Œä»è€Œäº§ç”Ÿæ‰€æœ‰å¯èƒ½çš„æ’åˆ— 10.15 ç»„åˆé—®é¢˜â…£ç»™ä½ ä¸€ä¸ªç”± ä¸åŒ æ•´æ•°ç»„æˆçš„æ•°ç»„ nums ï¼Œå’Œä¸€ä¸ªç›®æ ‡æ•´æ•° target ã€‚è¯·ä½ ä» nums ä¸­æ‰¾å‡ºå¹¶è¿”å›æ€»å’Œä¸º target çš„å…ƒç´ ç»„åˆçš„ä¸ªæ•°ã€‚ é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆç¬¦åˆ 32 ä½æ•´æ•°èŒƒå›´ã€‚ // æ±‚æ’åˆ—å°±æ˜¯æ±‚æ’åˆ—ï¼Œè¿˜å«ç»„åˆé—®é¢˜å°±ä¸å¤ªå¯¹äº† class Solution &#123; public: int combinationSum4(vector&lt;int>&amp; nums, int target) &#123; vector&lt;uint64_t> dp(target+1, 0); dp[0] = 1; for (int j = 0; j &lt;= target; j++)&#123; for (int i = 0; i &lt; nums.size(); i++)&#123; if (j >= nums[i]) dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125; &#125;; 10.16 çˆ¬æ¥¼æ¢¯è¿›é˜¶å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ n é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚ æ¯æ¬¡ä½ å¯ä»¥çˆ¬è‡³å¤šm (1 &lt;= m &lt; n)ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ æ³¨æ„ï¼šç»™å®š n æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ã€‚ #include &lt;iostream> #include &lt;vector> using namespace std; int main()&#123; int n , m; cin >> n >> m; vector&lt;int> dp(n + 1, 0); dp[0] = 1; for (int j = 0; j &lt;= n; j++)&#123; for (int i = 1; i &lt;= m; i++)&#123; if (j >= i) dp[j] += dp[j - i]; &#125; &#125; cout &lt;&lt; dp[n]; return 0; &#125; 10.17 é›¶é’±å…‘æ¢ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ coins ï¼Œè¡¨ç¤ºä¸åŒé¢é¢çš„ç¡¬å¸ï¼›ä»¥åŠä¸€ä¸ªæ•´æ•° amount ï¼Œè¡¨ç¤ºæ€»é‡‘é¢ã€‚ è®¡ç®—å¹¶è¿”å›å¯ä»¥å‡‘æˆæ€»é‡‘é¢æ‰€éœ€çš„ æœ€å°‘çš„ç¡¬å¸ä¸ªæ•° ã€‚å¦‚æœæ²¡æœ‰ä»»ä½•ä¸€ç§ç¡¬å¸ç»„åˆèƒ½ç»„æˆæ€»é‡‘é¢ï¼Œè¿”å› -1 ã€‚ ä½ å¯ä»¥è®¤ä¸ºæ¯ç§ç¡¬å¸çš„æ•°é‡æ˜¯æ— é™çš„ã€‚ class Solution &#123; public: int coinChange(vector&lt;int>&amp; coins, int amount) &#123; vector&lt;vector&lt;int>> dp(coins.size(), vector&lt;int>(amount+1 , INT_MAX)); // åˆå§‹åŒ– for (int i = 0; i &lt;= amount; i++)&#123; if (i % coins[0] == 0) dp[0][i] = i / coins[0]; &#125; for (int i = 0; i &lt; coins.size(); i++)&#123; dp[i][0] = 0; &#125; // é€’æ¨ for (int i = 1; i &lt; coins.size(); i++)&#123; for (int j = 0; j &lt;= amount; j++)&#123; if (j >= coins[i]) &#123; if (dp[i][j - coins[i]] == INT_MAX) dp[i][j] = dp[i-1][j]; else dp[i][j] = min(dp[i-1][j], dp[i][j - coins[i]] + 1); &#125; else dp[i][j] = dp[i - 1][j]; &#125; &#125; if (dp[coins.size() - 1][amount] == INT_MAX) return -1; return dp[coins.size() - 1][amount]; &#125; &#125;; 10.18 å®Œå…¨å¹³æ–¹æ•°ç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¿”å› å’Œä¸º n çš„å®Œå…¨å¹³æ–¹æ•°çš„æœ€å°‘æ•°é‡ ã€‚ å®Œå…¨å¹³æ–¹æ•° æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œå…¶å€¼ç­‰äºå¦ä¸€ä¸ªæ•´æ•°çš„å¹³æ–¹ï¼›æ¢å¥è¯è¯´ï¼Œå…¶å€¼ç­‰äºä¸€ä¸ªæ•´æ•°è‡ªä¹˜çš„ç§¯ã€‚ä¾‹å¦‚ï¼Œ1ã€4ã€9 å’Œ 16 éƒ½æ˜¯å®Œå…¨å¹³æ–¹æ•°ï¼Œè€Œ 3 å’Œ 11 ä¸æ˜¯ã€‚ class Solution &#123; public: int numSquares(int n) &#123; vector&lt;int> dp(n+1); dp[0] = 0; for (int i = 1; i &lt;= n; i++) dp[i] = i; for (int i = 2; i &lt;= sqrt(n); i++)&#123; for (int j = 0; j &lt;= n; j++)&#123; if (j >= i*i) dp[j] = min(dp[j], dp[j - i*i] + 1); &#125; &#125; return dp[n]; &#125; &#125;; 10.19 å•è¯æ‹†åˆ†ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ wordDict ä½œä¸ºå­—å…¸ã€‚å¦‚æœå¯ä»¥åˆ©ç”¨å­—å…¸ä¸­å‡ºç°çš„ä¸€ä¸ªæˆ–å¤šä¸ªå•è¯æ‹¼æ¥å‡º s åˆ™è¿”å› trueã€‚ æ³¨æ„ï¼šä¸è¦æ±‚å­—å…¸ä¸­å‡ºç°çš„å•è¯å…¨éƒ¨éƒ½ä½¿ç”¨ï¼Œå¹¶ä¸”å­—å…¸ä¸­çš„å•è¯å¯ä»¥é‡å¤ä½¿ç”¨ã€‚ // æƒ³æ³•æœ‰ç‚¹éš¾åº¦ é€’æ¨å…¬å¼æ¯”è¾ƒç‰¹æ®Š ä¸èƒ½çº ç»“äºâ€œèƒŒåŒ…â€æ¦‚å¿µ class Solution &#123; public: bool wordBreak(string s, vector&lt;string>&amp; wordDict) &#123; unordered_set&lt;string> wordSet(wordDict.begin(), wordDict.end()); vector&lt;bool> dp(s.size() + 1, false); dp[0] = true; for (int i = 1; i &lt;= s.size(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; string word = s.substr(j, i - j); //substr(èµ·å§‹ä½ç½®ï¼Œæˆªå–çš„ä¸ªæ•°) if (wordSet.find(word) != wordSet.end() &amp;&amp; dp[j]) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.size()]; &#125; &#125;; 10.20 æ‰“å®¶åŠ«èˆä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ã€‚æ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ï¼Œå½±å“ä½ å·çªƒçš„å”¯ä¸€åˆ¶çº¦å› ç´ å°±æ˜¯ç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œå¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦ã€‚ ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½  ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹ ï¼Œä¸€å¤œä¹‹å†…èƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚ // dp[i]ï¼šè€ƒè™‘ä¸‹æ ‡iï¼ˆåŒ…æ‹¬iï¼‰ä»¥å†…çš„æˆ¿å±‹ï¼Œæœ€å¤šå¯ä»¥å·çªƒçš„é‡‘é¢ä¸ºdp[i]ã€‚ class Solution &#123; public: int rob(vector&lt;int>&amp; nums) &#123; if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; vector&lt;int> dp(nums.size(), 0); dp[0] = nums[0]; dp[1] = max(nums[0] , nums[1]); for (int i = 2; i &lt; nums.size(); i++)&#123; dp[i] = max(dp[i - 2] + nums[i] , dp[i-1]); &#125; return dp[nums.size() - 1]; &#125; &#125;; 10.21 æ‰“å®¶åŠ«èˆâ…¡ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°å·ï¼Œè®¡åˆ’å·çªƒæ²¿è¡—çš„æˆ¿å±‹ï¼Œæ¯é—´æˆ¿å†…éƒ½è—æœ‰ä¸€å®šçš„ç°é‡‘ã€‚è¿™ä¸ªåœ°æ–¹æ‰€æœ‰çš„æˆ¿å±‹éƒ½ å›´æˆä¸€åœˆ ï¼Œè¿™æ„å‘³ç€ç¬¬ä¸€ä¸ªæˆ¿å±‹å’Œæœ€åä¸€ä¸ªæˆ¿å±‹æ˜¯ç´§æŒ¨ç€çš„ã€‚åŒæ—¶ï¼Œç›¸é‚»çš„æˆ¿å±‹è£…æœ‰ç›¸äº’è¿é€šçš„é˜²ç›—ç³»ç»Ÿï¼Œå¦‚æœä¸¤é—´ç›¸é‚»çš„æˆ¿å±‹åœ¨åŒä¸€æ™šä¸Šè¢«å°å·é—¯å…¥ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŠ¥è­¦ ã€‚ ç»™å®šä¸€ä¸ªä»£è¡¨æ¯ä¸ªæˆ¿å±‹å­˜æ”¾é‡‘é¢çš„éè´Ÿæ•´æ•°æ•°ç»„ï¼Œè®¡ç®—ä½  åœ¨ä¸è§¦åŠ¨è­¦æŠ¥è£…ç½®çš„æƒ…å†µä¸‹ ï¼Œä»Šæ™šèƒ½å¤Ÿå·çªƒåˆ°çš„æœ€é«˜é‡‘é¢ã€‚ //æŒ‰é¦–å°¾åŒ…å«æƒ…å†µåˆ†ä¸¤ç§è®¨è®º class Solution &#123; public: int rob(vector&lt;int>&amp; nums) &#123; if (nums.size() == 0) return 0; if (nums.size() == 1) return nums[0]; if (nums.size() == 2) return max(nums[0], nums[1]); vector&lt;int> dp(nums.size(), 0); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i &lt; nums.size() - 1; i++)&#123; dp[i] = max(dp[i-1] , dp[i-2] + nums[i]); &#125; int result1 = dp[nums.size() - 2]; dp = vector&lt;int>(nums.size(), 0); dp[1] = nums[1]; dp[2] = max(dp[1], nums[2]); for (int i = 3; i &lt; nums.size(); i++)&#123; dp[i] = max(dp[i-1] , dp[i-2] + nums[i]); &#125; int result2 = dp[nums.size() - 1]; return max(result1, result2); &#125; &#125;; 10.22 æ‰“å®¶åŠ«èˆâ…¢å°å·åˆå‘ç°äº†ä¸€ä¸ªæ–°çš„å¯è¡Œçªƒçš„åœ°åŒºã€‚è¿™ä¸ªåœ°åŒºåªæœ‰ä¸€ä¸ªå…¥å£ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º root ã€‚ é™¤äº† root ä¹‹å¤–ï¼Œæ¯æ ‹æˆ¿å­æœ‰ä¸”åªæœ‰ä¸€ä¸ªâ€œçˆ¶â€œæˆ¿å­ä¸ä¹‹ç›¸è¿ã€‚ä¸€ç•ªä¾¦å¯Ÿä¹‹åï¼Œèªæ˜çš„å°å·æ„è¯†åˆ°â€œè¿™ä¸ªåœ°æ–¹çš„æ‰€æœ‰æˆ¿å±‹çš„æ’åˆ—ç±»ä¼¼äºä¸€æ£µäºŒå‰æ ‘â€ã€‚ å¦‚æœ ä¸¤ä¸ªç›´æ¥ç›¸è¿çš„æˆ¿å­åœ¨åŒä¸€å¤©æ™šä¸Šè¢«æ‰“åŠ« ï¼Œæˆ¿å±‹å°†è‡ªåŠ¨æŠ¥è­¦ã€‚ ç»™å®šäºŒå‰æ ‘çš„ root ã€‚è¿”å› *åœ¨ä¸è§¦åŠ¨è­¦æŠ¥çš„æƒ…å†µä¸‹ ï¼Œå°å·èƒ½å¤Ÿç›—å–çš„æœ€é«˜é‡‘é¢* ã€‚ // ä¸€å¼€å§‹çš„é”™è¯¯æ€è·¯ // å±‚åºéå†åæŠŠæ¯å±‚çš„å’Œä½œä¸ºä¸€æ¬¡value // è¿™æ ·å†™çš„é—®é¢˜ï¼Œæ¼äº†ä¸€äº›æƒ…å†µï¼Œæ¯”å¦‚[2,1,3,null,4] class Solution &#123; public: int rob(TreeNode* root) &#123; if (root == NULL) return 0; queue&lt;TreeNode*> que; int layer = 0; que.push(root); vector&lt;int> value; while (!que.empty())&#123; int size = que.size(); int layervalue = 0; for (int i = 0; i &lt; size; i++)&#123; TreeNode* cur = que.front(); que.pop(); layervalue += cur->val; if (cur->left) que.push(cur->left); if (cur->right) que.push(cur->right); &#125; value.push_back(layervalue); layer++; &#125; if (layer == 1) return value[0]; vector&lt;int> dp(layer,0); dp[0] = value[0]; dp[1] = max(value[0], value[1]); for (int i = 2; i &lt; layer; i++)&#123; dp[i] = max(dp[i-2] + value[i], dp[i-1]); &#125; return dp[layer - 1]; &#125; &#125;; // æ€è·¯ï¼šæŠŠdpç”±ä¸€ç»´æ•°ç»„è½¬æ¢æˆæ ‘å½¢ç»“æœ class Solution &#123; public: vector&lt;int> robtree(TreeNode* cur)&#123; // ä¸¤ç§æƒ…å†µï¼Œå¯¹åº”ä¸é€‰æœ¬èŠ‚ç‚¹å’Œé€‰æœ¬èŠ‚ç‚¹ //æ‰€ä»¥dpæ•°ç»„ï¼šä¸‹æ ‡ä¸º0è®°å½•ä¸é€‰è¯¥èŠ‚ç‚¹æ‰€å¾—åˆ°çš„çš„æœ€å¤§é‡‘é’±ï¼Œä¸‹æ ‡ä¸º1è®°å½•é€‰è¯¥èŠ‚ç‚¹æ‰€å¾—åˆ°çš„çš„æœ€å¤§é‡‘é’±ã€‚ vector&lt;int> result(2,0); if (cur == NULL) return result; vector&lt;int> left = robtree(cur->left); vector&lt;int> right = robtree(cur->right); // ä¸é€‰æœ¬èŠ‚ç‚¹ result[0] = max(left[0], left[1]) + max(right[0], right[1]); // é€‰æœ¬èŠ‚ç‚¹ result[1] = cur->val + left[0] + right[0]; return result; &#125; int rob(TreeNode* root) &#123; vector&lt;int> result = robtree(root); return max(result[0], result[1]); &#125; &#125;; 10.23 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºç»™å®šä¸€ä¸ªæ•°ç»„ prices ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´  prices[i] è¡¨ç¤ºä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚ ä½ åªèƒ½é€‰æ‹© æŸä¸€å¤© ä¹°å…¥è¿™åªè‚¡ç¥¨ï¼Œå¹¶é€‰æ‹©åœ¨ æœªæ¥çš„æŸä¸€ä¸ªä¸åŒçš„æ—¥å­ å–å‡ºè¯¥è‚¡ç¥¨ã€‚è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ è¿”å›ä½ å¯ä»¥ä»è¿™ç¬”äº¤æ˜“ä¸­è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚å¦‚æœä½ ä¸èƒ½è·å–ä»»ä½•åˆ©æ¶¦ï¼Œè¿”å› 0 ã€‚ // æƒ³æ³•ï¼šdp[i][0] è¡¨ç¤ºç¬¬iå¤©æŒæœ‰è‚¡ç¥¨æ‰€å¾—æœ€å¤šç°é‡‘ // dp[i][1] è¡¨ç¤ºç¬¬iå¤©ä¸æŒæœ‰è‚¡ç¥¨æ‰€å¾—æœ€å¤šç°é‡‘ /* å¦‚æœç¬¬iå¤©æŒæœ‰è‚¡ç¥¨å³dp[i][0]ï¼Œ é‚£ä¹ˆå¯ä»¥ç”±ä¸¤ä¸ªçŠ¶æ€æ¨å‡ºæ¥ ç¬¬i-1å¤©å°±æŒæœ‰è‚¡ç¥¨ï¼Œé‚£ä¹ˆå°±ä¿æŒç°çŠ¶ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æ˜¨å¤©æŒæœ‰è‚¡ç¥¨çš„æ‰€å¾—ç°é‡‘ å³ï¼šdp[i - 1][0] ç¬¬iå¤©ä¹°å…¥è‚¡ç¥¨ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯ä¹°å…¥ä»Šå¤©çš„è‚¡ç¥¨åæ‰€å¾—ç°é‡‘å³ï¼š-prices[i] é‚£ä¹ˆdp[i][0]åº”è¯¥é€‰æ‰€å¾—ç°é‡‘æœ€å¤§çš„ï¼Œæ‰€ä»¥dp[i][0] = max(dp[i - 1][0], -prices[i]); å¦‚æœç¬¬iå¤©ä¸æŒæœ‰è‚¡ç¥¨å³dp[i][1]ï¼Œ ä¹Ÿå¯ä»¥ç”±ä¸¤ä¸ªçŠ¶æ€æ¨å‡ºæ¥ ç¬¬i-1å¤©å°±ä¸æŒæœ‰è‚¡ç¥¨ï¼Œé‚£ä¹ˆå°±ä¿æŒç°çŠ¶ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æ˜¨å¤©ä¸æŒæœ‰è‚¡ç¥¨çš„æ‰€å¾—ç°é‡‘ å³ï¼šdp[i - 1][1] ç¬¬iå¤©å–å‡ºè‚¡ç¥¨ï¼Œæ‰€å¾—ç°é‡‘å°±æ˜¯æŒ‰ç…§ä»Šå¤©è‚¡ç¥¨ä»·æ ¼å–å‡ºåæ‰€å¾—ç°é‡‘å³ï¼šprices[i] + dp[i - 1][0] åŒæ ·dp[i][1]å–æœ€å¤§çš„ï¼Œdp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]); */ class Solution &#123; public: int maxProfit(vector&lt;int>&amp; prices) &#123; if (prices.size() == 0) return 0; vector&lt;vector&lt;int>> dp(prices.size(), vector&lt;int>(2, 0)); dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; prices.size(); i++)&#123; dp[i][0] = max(dp[i-1][0], -prices[i]); dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0]); &#125; return dp[prices.size() - 1][1]; &#125; &#125;; 10.24 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºâ…¡ï¼ˆdpå†™ï¼‰ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ prices ï¼Œå…¶ä¸­ prices[i] è¡¨ç¤ºæŸæ”¯è‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚ åœ¨æ¯ä¸€å¤©ï¼Œä½ å¯ä»¥å†³å®šæ˜¯å¦è´­ä¹°å’Œ/æˆ–å‡ºå”®è‚¡ç¥¨ã€‚ä½ åœ¨ä»»ä½•æ—¶å€™ æœ€å¤š åªèƒ½æŒæœ‰ ä¸€è‚¡ è‚¡ç¥¨ã€‚ä½ ä¹Ÿå¯ä»¥å…ˆè´­ä¹°ï¼Œç„¶ååœ¨ åŒä¸€å¤© å‡ºå”®ã€‚ è¿”å› ä½ èƒ½è·å¾—çš„ æœ€å¤§ åˆ©æ¶¦ ã€‚ // ä¹‹å‰ç”¨è´ªå¿ƒå†™è¿‡ï¼Œ ç”¨dpæ–¹æ³•å†™ä¸€ä¸‹ class Solution &#123; public: int maxProfit(vector&lt;int>&amp; prices) &#123; if (prices.size() == 0) return 0; vector&lt;vector&lt;int>> dp(prices.size(), vector&lt;int>(2,0)); dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; prices.size(); i++)&#123; // è¿™é‡Œæ˜¯ä¸ä¸Šä¸€é¢˜çš„åŒºåˆ«ä¹‹å¤„: maxä¸­çš„åä¸€é¡¹æŒ‡ç¬¬iå¤©æŒæœ‰è‚¡ç¥¨ï¼Œå¯ä»¥æ˜¯å‰ä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨ï¼Œä»Šå¤©ä¹°å…¥åçš„ç°é‡‘; ä¸Šä¸€é¢˜ç”±äºä¸€å…±åªèƒ½ä¹°ä¸€æ¬¡ï¼Œå› æ­¤ä¹°ä¹‹å‰ä¸€å®šç°é‡‘ä¸º0 dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]); dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]); &#125; return dp[prices.size() - 1][1]; &#125; &#125;; 10.25 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºâ…¢ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´ æ˜¯ä¸€æ”¯ç»™å®šçš„è‚¡ç¥¨åœ¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚ è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ä½ æœ€å¤šå¯ä»¥å®Œæˆ ä¸¤ç¬” äº¤æ˜“ã€‚ æ³¨æ„ï¼šä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚ class Solution &#123; public: int maxProfit(vector&lt;int>&amp; prices) &#123; if (prices.size() == 0) return 0; vector&lt;vector&lt;int>> dp(prices.size(), vector&lt;int>(4,0)); dp[0][0] = -prices[0]; dp[0][1] = 0; dp[0][2] = -prices[0]; dp[0][3] = 0; for (int i = 1; i &lt; prices.size(); i++)&#123; // first hold dp[i][0] = max(dp[i-1][0], -prices[i]); // first unhold dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]); // second hold dp[i][2] = max(dp[i-1][2], dp[i-1][1] - prices[i]); // second unhold dp[i][3] = max(dp[i-1][3], dp[i-1][2] + prices[i]); &#125; // return dp[prices.size() - 1][3]; è¿™ä¸ªåŒ…å«ä¸‹é¢çš„æƒ…å†µ return max(dp[prices.size() - 1][1], dp[prices.size() - 1][3]); &#125; &#125;; 10.26 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºâ…£ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ prices å’Œä¸€ä¸ªæ•´æ•° k ï¼Œå…¶ä¸­ prices[i] æ˜¯æŸæ”¯ç»™å®šçš„è‚¡ç¥¨åœ¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚ è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ä½ æœ€å¤šå¯ä»¥å®Œæˆ k ç¬”äº¤æ˜“ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä½ æœ€å¤šå¯ä»¥ä¹° k æ¬¡ï¼Œå– k æ¬¡ã€‚ æ³¨æ„ï¼šä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚ // ä»ä¸Šä¸€é¢˜å½’çº³è€Œæ¥ class Solution &#123; public: int maxProfit(int k, vector&lt;int>&amp; prices) &#123; if (prices.size() == 0) return 0; vector&lt;vector&lt;int>> dp(prices.size(), vector&lt;int>(k*2,0)); for (int j = 0; j &lt; 2*k; j++)&#123; if ( j % 2 == 0) dp[0][j] = -prices[0]; else dp[0][j] = 0; &#125; for (int i = 1; i &lt; prices.size(); i++)&#123; dp[i][0] = max(dp[i-1][0], -prices[i]); for (int j = 1; j &lt; 2 * k; j++)&#123; if (j % 2) // unhold dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i]); else // hold dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] - prices[i]); &#125; &#125; return dp[prices.size() - 1][2*k-1]; &#125; &#125;; 10.27 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«å†·å†»æœŸç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„pricesï¼Œå…¶ä¸­ç¬¬ prices[i] è¡¨ç¤ºç¬¬ *i* å¤©çš„è‚¡ç¥¨ä»·æ ¼ ã€‚ è®¾è®¡ä¸€ä¸ªç®—æ³•è®¡ç®—å‡ºæœ€å¤§åˆ©æ¶¦ã€‚åœ¨æ»¡è¶³ä»¥ä¸‹çº¦æŸæ¡ä»¶ä¸‹ï¼Œä½ å¯ä»¥å°½å¯èƒ½åœ°å®Œæˆæ›´å¤šçš„äº¤æ˜“ï¼ˆå¤šæ¬¡ä¹°å–ä¸€æ”¯è‚¡ç¥¨ï¼‰: å–å‡ºè‚¡ç¥¨åï¼Œä½ æ— æ³•åœ¨ç¬¬äºŒå¤©ä¹°å…¥è‚¡ç¥¨ (å³å†·å†»æœŸä¸º 1 å¤©)ã€‚ æ³¨æ„ï¼šä½ ä¸èƒ½åŒæ—¶å‚ä¸å¤šç¬”äº¤æ˜“ï¼ˆä½ å¿…é¡»åœ¨å†æ¬¡è´­ä¹°å‰å‡ºå”®æ‰ä¹‹å‰çš„è‚¡ç¥¨ï¼‰ã€‚ // é™¤äº†åŸºç¡€çš„çŠ¶æ€å¤–å¢åŠ å†·å†»æœŸçŠ¶æ€å’Œå½“å¤©å–å‡ºçŠ¶æ€ /* æŒæœ‰è‚¡ç¥¨çŠ¶æ€ï¼ˆçŠ¶æ€ä¸€ï¼‰å³ï¼šdp[i][0]ï¼Œæœ‰ä¸¤ä¸ªæ“ä½œï¼š 1ï¼šå‰ä¸€å¤©å°±æ˜¯æŒæœ‰è‚¡ç¥¨çŠ¶æ€ï¼ˆçŠ¶æ€ä¸€ï¼‰ï¼Œdp[i][0] = dp[i - 1][0] 2ï¼šä»Šå¤©ä¹°å…¥äº†ï¼Œæœ‰ä¸¤ç§æƒ…å†µ å‰ä¸€å¤©æ˜¯å†·å†»æœŸï¼ˆçŠ¶æ€å››ï¼‰ï¼Œdp[i - 1][3] - prices[i] å‰ä¸€å¤©æ˜¯ä¿æŒå–å‡ºè‚¡ç¥¨çš„çŠ¶æ€ï¼ˆçŠ¶æ€äºŒï¼‰ï¼Œdp[i - 1][1] - prices[i] é‚£ä¹ˆdp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]); æ— è‚¡ç¥¨ä¸”ä¸è¿›å…¥å†·å†»æœŸï¼ˆå½“å¤©ä¸å–å‡ºï¼‰çŠ¶æ€ï¼ˆçŠ¶æ€äºŒï¼‰å³ï¼šdp[i][1]ï¼Œæœ‰ä¸¤ä¸ªå…·ä½“æ“ä½œï¼š æ“ä½œä¸€ï¼šå‰ä¸€å¤©å°±æ˜¯çŠ¶æ€äºŒ æ“ä½œäºŒï¼šå‰ä¸€å¤©æ˜¯å†·å†»æœŸï¼ˆçŠ¶æ€å››ï¼‰ dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]); æ— è‚¡ç¥¨ä¸”è¿›å…¥å†·å†»æœŸï¼ˆå½“å¤©å–å‡ºè‚¡ç¥¨ï¼‰çŠ¶æ€ï¼ˆçŠ¶æ€ä¸‰ï¼‰ï¼Œå³ï¼šdp[i][2] ï¼Œåªæœ‰ä¸€ä¸ªæ“ä½œï¼š æ˜¨å¤©ä¸€å®šæ˜¯æŒæœ‰è‚¡ç¥¨çŠ¶æ€ï¼ˆçŠ¶æ€ä¸€ï¼‰ï¼Œä»Šå¤©å–å‡º å³ï¼šdp[i][2] = dp[i - 1][0] + prices[i]; å†·å†»æœŸçŠ¶æ€ï¼ˆçŠ¶æ€å››ï¼‰ï¼Œå³ï¼šdp[i][3]ï¼Œåªæœ‰ä¸€ä¸ªæ“ä½œï¼š æ˜¨å¤©å–å‡ºäº†è‚¡ç¥¨ï¼ˆçŠ¶æ€ä¸‰ï¼‰ dp[i][3] = dp[i - 1][2]; */ class Solution &#123; public: int maxProfit(vector&lt;int>&amp; prices) &#123; int n = prices.size(); if (n == 0) return 0; vector&lt;vector&lt;int>> dp(n, vector&lt;int>(4, 0)); dp[0][0] = -prices[0]; for (int i = 1; i &lt; n; i++) &#123; dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i])); dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]); dp[i][2] = dp[i - 1][0] + prices[i]; dp[i][3] = dp[i - 1][2]; &#125; return max(dp[n - 1][3], max(dp[n - 1][1], dp[n - 1][2])); &#125; &#125;; 10.28 ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœºå«æ‰‹ç»­è´¹ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ pricesï¼Œå…¶ä¸­ prices[i]è¡¨ç¤ºç¬¬ i å¤©çš„è‚¡ç¥¨ä»·æ ¼ ï¼›æ•´æ•° fee ä»£è¡¨äº†äº¤æ˜“è‚¡ç¥¨çš„æ‰‹ç»­è´¹ç”¨ã€‚ ä½ å¯ä»¥æ— é™æ¬¡åœ°å®Œæˆäº¤æ˜“ï¼Œä½†æ˜¯ä½ æ¯ç¬”äº¤æ˜“éƒ½éœ€è¦ä»˜æ‰‹ç»­è´¹ã€‚å¦‚æœä½ å·²ç»è´­ä¹°äº†ä¸€ä¸ªè‚¡ç¥¨ï¼Œåœ¨å–å‡ºå®ƒä¹‹å‰ä½ å°±ä¸èƒ½å†ç»§ç»­è´­ä¹°è‚¡ç¥¨äº†ã€‚ è¿”å›è·å¾—åˆ©æ¶¦çš„æœ€å¤§å€¼ã€‚ æ³¨æ„ï¼šè¿™é‡Œçš„ä¸€ç¬”äº¤æ˜“æŒ‡ä¹°å…¥æŒæœ‰å¹¶å–å‡ºè‚¡ç¥¨çš„æ•´ä¸ªè¿‡ç¨‹ï¼Œæ¯ç¬”äº¤æ˜“ä½ åªéœ€è¦ä¸ºæ”¯ä»˜ä¸€æ¬¡æ‰‹ç»­è´¹ã€‚ class Solution &#123; public: int maxProfit(vector&lt;int>&amp; prices, int fee) &#123; if (prices.size() == 0) return 0; vector&lt;vector&lt;int>> dp(prices.size(), vector&lt;int>(2,0)); dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i &lt; prices.size(); i++)&#123; dp[i][0] = max(dp[i-1][0] , dp[i-1][1] - prices[i]); dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee); &#125; return dp[prices.size() - 1][1]; &#125; &#125;; 10.30 æœ€é•¿é€’å¢å­åºåˆ—ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾åˆ°å…¶ä¸­æœ€é•¿ä¸¥æ ¼é€’å¢å­åºåˆ—çš„é•¿åº¦ã€‚ å­åºåˆ— æ˜¯ç”±æ•°ç»„æ´¾ç”Ÿè€Œæ¥çš„åºåˆ—ï¼Œåˆ é™¤ï¼ˆæˆ–ä¸åˆ é™¤ï¼‰æ•°ç»„ä¸­çš„å…ƒç´ è€Œä¸æ”¹å˜å…¶ä½™å…ƒç´ çš„é¡ºåºã€‚ä¾‹å¦‚ï¼Œ[3,6,2,7] æ˜¯æ•°ç»„ [0,3,1,6,2,2,7] çš„å­åºåˆ—ã€‚ class Solution &#123; public: int lengthOfLIS(vector&lt;int>&amp; nums) &#123; if (nums.size() &lt;= 1) return nums.size(); // dp[i] : longest subarray end by num[i] vector&lt;int> dp(nums.size() , 1); int result = 0; for (int i = 1; i &lt; nums.size(); i++)&#123; // search the longest subarray end by element before num[i] for (int j = 0; j &lt; i; j++)&#123; if (nums[i] > nums[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; if (dp[i] > result) result = dp[i]; &#125; return result; &#125; &#125;; 10.31 æœ€é•¿è¿ç»­é€’å¢åºåˆ—ç»™å®šä¸€ä¸ªæœªç»æ’åºçš„æ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°æœ€é•¿ä¸” è¿ç»­é€’å¢çš„å­åºåˆ—ï¼Œå¹¶è¿”å›è¯¥åºåˆ—çš„é•¿åº¦ã€‚ è¿ç»­é€’å¢çš„å­åºåˆ— å¯ä»¥ç”±ä¸¤ä¸ªä¸‹æ ‡ l å’Œ rï¼ˆl &lt; rï¼‰ç¡®å®šï¼Œå¦‚æœå¯¹äºæ¯ä¸ª l &lt;= i &lt; rï¼Œéƒ½æœ‰ nums[i] &lt; nums[i + 1] ï¼Œé‚£ä¹ˆå­åºåˆ— [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] å°±æ˜¯è¿ç»­é€’å¢å­åºåˆ—ã€‚ class Solution &#123; public: int findLengthOfLCIS(vector&lt;int>&amp; nums) &#123; if (nums.size() &lt;= 1) return nums.size(); vector&lt;int> dp(nums.size(), 1); int result = 0; for (int i = 1; i &lt; nums.size(); i++)&#123; if (nums[i] > nums[i-1]) dp[i] = dp[i-1] + 1; if (dp[i] > result) result = dp[i]; &#125; return result; &#125; &#125;; 10.32 æœ€é•¿é‡å¤å­æ•°ç»„ç»™ä¸¤ä¸ªæ•´æ•°æ•°ç»„ nums1 å’Œ nums2 ï¼Œè¿”å› ä¸¤ä¸ªæ•°ç»„ä¸­ å…¬å…±çš„ ã€é•¿åº¦æœ€é•¿çš„å­æ•°ç»„çš„é•¿åº¦ ã€‚ // æƒ³æ³•æœ‰ç‚¹éš¾ // dp[i][j] ï¼šä»¥ä¸‹æ ‡i - 1ä¸ºç»“å°¾çš„Aï¼Œå’Œä»¥ä¸‹æ ‡j - 1ä¸ºç»“å°¾çš„Bï¼Œæœ€é•¿é‡å¤å­æ•°ç»„é•¿åº¦ä¸ºdp[i][j]ã€‚ class Solution &#123; public: int findLength(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2) &#123; if (nums1.size() == 0 || nums2.size() == 0) return 0; vector&lt;vector&lt;int>> dp(nums1.size() + 1, vector&lt;int>(nums2.size() + 1, 0)); int result = 0; for (int i = 1; i &lt;= nums1.size(); i++)&#123; for (int j = 1; j &lt;= nums2.size(); j++)&#123; if (nums1[i -1] == nums2[j-1]) dp[i][j] = dp[i-1][j-1] + 1; if ( dp[i][j] > result ) result = dp[i][j]; &#125; &#125; return result; &#125; &#125;; 10.32 æœ€é•¿å…¬å…±å­åºåˆ—ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² text1 å’Œ text2ï¼Œè¿”å›è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿ å…¬å…±å­åºåˆ— çš„é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨ å…¬å…±å­åºåˆ— ï¼Œè¿”å› 0 ã€‚ ä¸€ä¸ªå­—ç¬¦ä¸²çš„ å­åºåˆ— æ˜¯æŒ‡è¿™æ ·ä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ï¼šå®ƒæ˜¯ç”±åŸå­—ç¬¦ä¸²åœ¨ä¸æ”¹å˜å­—ç¬¦çš„ç›¸å¯¹é¡ºåºçš„æƒ…å†µä¸‹åˆ é™¤æŸäº›å­—ç¬¦ï¼ˆä¹Ÿå¯ä»¥ä¸åˆ é™¤ä»»ä½•å­—ç¬¦ï¼‰åç»„æˆçš„æ–°å­—ç¬¦ä¸²ã€‚ ä¾‹å¦‚ï¼Œ&quot;ace&quot; æ˜¯ &quot;abcde&quot; çš„å­åºåˆ—ï¼Œä½† &quot;aec&quot; ä¸æ˜¯ &quot;abcde&quot; çš„å­åºåˆ—ã€‚ ä¸¤ä¸ªå­—ç¬¦ä¸²çš„ å…¬å…±å­åºåˆ— æ˜¯è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²æ‰€å…±åŒæ‹¥æœ‰çš„å­åºåˆ—ã€‚ class Solution &#123; public: int longestCommonSubsequence(string text1, string text2) &#123; if (text1.size() == 0 || text2.size() == 0) return 0; vector&lt;vector&lt;int>> dp(text1.size()+1, vector&lt;int>(text2.size()+1,0)); for (int i = 1; i &lt;= text1.size(); i++)&#123; for (int j = 1; j &lt;= text2.size(); j++)&#123; if (text1[i-1] == text2[j-1]) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = max(dp[i][j-1], dp[i-1][j]); &#125; &#125; return dp[text1.size()][text2.size()]; &#125; &#125;; 10.33 ä¸ç›¸äº¤çš„çº¿åœ¨ä¸¤æ¡ç‹¬ç«‹çš„æ°´å¹³çº¿ä¸ŠæŒ‰ç»™å®šçš„é¡ºåºå†™ä¸‹ nums1 å’Œ nums2 ä¸­çš„æ•´æ•°ã€‚ ç°åœ¨ï¼Œå¯ä»¥ç»˜åˆ¶ä¸€äº›è¿æ¥ä¸¤ä¸ªæ•°å­— nums1[i] å’Œ nums2[j] çš„ç›´çº¿ï¼Œè¿™äº›ç›´çº¿éœ€è¦åŒæ—¶æ»¡è¶³ï¼š nums1[i] == nums2[j] ä¸”ç»˜åˆ¶çš„ç›´çº¿ä¸ä¸ä»»ä½•å…¶ä»–è¿çº¿ï¼ˆéæ°´å¹³çº¿ï¼‰ç›¸äº¤ã€‚ è¯·æ³¨æ„ï¼Œè¿çº¿å³ä½¿åœ¨ç«¯ç‚¹ä¹Ÿä¸èƒ½ç›¸äº¤ï¼šæ¯ä¸ªæ•°å­—åªèƒ½å±äºä¸€æ¡è¿çº¿ã€‚ ä»¥è¿™ç§æ–¹æ³•ç»˜åˆ¶çº¿æ¡ï¼Œå¹¶è¿”å›å¯ä»¥ç»˜åˆ¶çš„æœ€å¤§è¿çº¿æ•°ã€‚ // æ€è·¯æœ€æ¸…æ™°çš„ä¸€é›† class Solution &#123; public: int maxUncrossedLines(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2) &#123; if (nums1.size() == 0 || nums2.size() == 0) return 0; vector&lt;vector&lt;int>> dp(nums1.size() + 1, vector&lt;int>(nums2.size() + 1, 0)); for (int i = 1; i &lt;= nums1.size(); i++)&#123; for (int j = 1; j &lt;= nums2.size(); j++)&#123; if (nums1[i-1] == nums2[j-1])&#123; dp[i][j] = max(dp[i-1][j-1] + 1, max(dp[i-1][j], dp[i][j-1])); &#125; else dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; return dp[nums1.size()][nums2.size()]; &#125; &#125;; 10.34 æœ€å¤§å­æ•°ç»„å’Œç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œè¯·ä½ æ‰¾å‡ºä¸€ä¸ªå…·æœ‰æœ€å¤§å’Œçš„è¿ç»­å­æ•°ç»„ï¼ˆå­æ•°ç»„æœ€å°‘åŒ…å«ä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œè¿”å›å…¶æœ€å¤§å’Œã€‚ å­æ•°ç»„æ˜¯æ•°ç»„ä¸­çš„ä¸€ä¸ªè¿ç»­éƒ¨åˆ†ã€‚ // é…åˆå‰é¢çš„è´ªå¿ƒç®—æ³•é£Ÿç”¨ class Solution &#123; public: int maxSubArray(vector&lt;int>&amp; nums) &#123; if (nums.size() == 0) return 0; // dp: subarray's maxsum ended by nums[i] vector&lt;int> dp(nums.size(), 0); dp[0] = nums[0]; int result = nums[0]; for (int i = 1; i &lt; nums.size(); i++)&#123; dp[i] = max(dp[i-1] + nums[i], nums[i]); if (dp[i] > result) result = dp[i]; &#125; return result; &#125; &#125;; 10.35 åˆ¤æ–­å­åºåˆ—ç»™å®šå­—ç¬¦ä¸² s å’Œ t ï¼Œåˆ¤æ–­ s æ˜¯å¦ä¸º t çš„å­åºåˆ—ã€‚ å­—ç¬¦ä¸²çš„ä¸€ä¸ªå­åºåˆ—æ˜¯åŸå§‹å­—ç¬¦ä¸²åˆ é™¤ä¸€äº›ï¼ˆä¹Ÿå¯ä»¥ä¸åˆ é™¤ï¼‰å­—ç¬¦è€Œä¸æ”¹å˜å‰©ä½™å­—ç¬¦ç›¸å¯¹ä½ç½®å½¢æˆçš„æ–°å­—ç¬¦ä¸²ã€‚ï¼ˆä¾‹å¦‚ï¼Œ&quot;ace&quot;æ˜¯&quot;abcde&quot;çš„ä¸€ä¸ªå­åºåˆ—ï¼Œè€Œ&quot;aec&quot;ä¸æ˜¯ï¼‰ã€‚ // æŒ‰10.33å†™æ³•å¯ä»¥ç›´æ¥è¿‡ class Solution &#123; public: bool isSubsequence(string s, string t) &#123; if (s.size() > t.size() || t.size() == 0 &amp;&amp; s.size()) return false; if (s.size() == 0) return true; vector&lt;vector&lt;int>> dp(s.size() + 1, vector&lt;int>(t.size() + 1, 0)); for (int i = 1; i &lt;= s.size(); i++)&#123; for (int j = 1; j &lt;= t.size(); j++)&#123; if (s[i-1] == t[j-1])&#123; dp[i][j] = max(dp[i-1][j-1] + 1, max(dp[i-1][j], dp[i][j-1])); &#125; else dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; return (dp[s.size()][t.size()] == s.size()); &#125; &#125;; 10.36 ä¸åŒçš„å­åºåˆ—ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸² s å’Œ t ï¼Œç»Ÿè®¡å¹¶è¿”å›åœ¨ s çš„ å­åºåˆ— ä¸­ t å‡ºç°çš„ä¸ªæ•°ã€‚ æµ‹è¯•ç”¨ä¾‹ä¿è¯ç»“æœåœ¨ 32 ä½æœ‰ç¬¦å·æ•´æ•°èŒƒå›´å†…ã€‚ class Solution &#123; public: int numDistinct(string s, string t) &#123; if (s.size() &lt; t.size()) return 0; vector&lt;vector&lt;uint64_t>> dp(s.size()+1, vector&lt;uint64_t>(t.size() + 1,0)); for (int i = 0; i &lt;= s.size(); i++) dp[i][0] = 1; for (int i = 1; i &lt;= s.size(); i++)&#123; for (int j = 1; j &lt;= t.size(); j++)&#123; if (s[i-1] == t[j-1]) dp[i][j] = dp[i-1][j-1] + dp[i-1][j]; else dp[i][j] = dp[i-1][j]; &#125; &#125; return dp[s.size()][t.size()]; &#125; &#125;; 10.37 ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ é™¤æ“ä½œç»™å®šä¸¤ä¸ªå•è¯ word1 å’Œ word2 ï¼Œè¿”å›ä½¿å¾— word1 å’Œ word2 ç›¸åŒæ‰€éœ€çš„æœ€å°æ­¥æ•°ã€‚ æ¯æ­¥ å¯ä»¥åˆ é™¤ä»»æ„ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„ä¸€ä¸ªå­—ç¬¦ã€‚ class Solution &#123; public: int minDistance(string word1, string word2) &#123; vector&lt;vector&lt;int>> dp(word1.size()+1, vector&lt;int>(word2.size()+1,0)); for (int i = 0; i &lt;= word1.size(); i++) dp[i][0] = i; for (int i = 0; i &lt;= word2.size(); i++) dp[0][i] = i; for (int i = 1; i &lt;= word1.size(); i++)&#123; for (int j = 1; j &lt;= word2.size(); j++)&#123; if (word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + 1; &#125; &#125; return dp[word1.size()][word2.size()]; &#125; &#125;; 10.38 ç¼–è¾‘è·ç¦»ç»™ä½ ä¸¤ä¸ªå•è¯ word1 å’Œ word2ï¼Œ è¯·è¿”å›å°† word1 è½¬æ¢æˆ word2 æ‰€ä½¿ç”¨çš„æœ€å°‘æ“ä½œæ•° ã€‚ ä½ å¯ä»¥å¯¹ä¸€ä¸ªå•è¯è¿›è¡Œå¦‚ä¸‹ä¸‰ç§æ“ä½œï¼š æ’å…¥ä¸€ä¸ªå­—ç¬¦ åˆ é™¤ä¸€ä¸ªå­—ç¬¦ æ›¿æ¢ä¸€ä¸ªå­—ç¬¦ class Solution &#123; public: int minDistance(string word1, string word2) &#123; vector&lt;vector&lt;int>> dp(word1.size() + 1, vector&lt;int>(word2.size() + 1, 0)); for (int i = 0; i &lt;= word1.size(); i++) dp[i][0] = i; for (int i = 0; i &lt;= word2.size(); i++) dp[0][i] = i; for (int i = 1; i &lt;= word1.size(); i++)&#123; for (int j = 1; j &lt;= word2.size(); j++)&#123; if (word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]; else // ä¸»è¦è¦äº†è§£æ›¿æ¢æ’å…¥å’Œåˆ é™¤æ˜¯ç­‰ä»·çš„ dp[i][j] = min(dp[i-1][j-1] + 1, min(dp[i][j-1]+1, dp[i-1][j] + 1)); &#125; &#125; return dp[word1.size()][word2.size()]; &#125; &#125;; 10.39 å›æ–‡å­ä¸²ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œè¯·ä½ ç»Ÿè®¡å¹¶è¿”å›è¿™ä¸ªå­—ç¬¦ä¸²ä¸­ å›æ–‡å­ä¸² çš„æ•°ç›®ã€‚ å›æ–‡å­—ç¬¦ä¸² æ˜¯æ­£ç€è¯»å’Œå€’è¿‡æ¥è¯»ä¸€æ ·çš„å­—ç¬¦ä¸²ã€‚ å­å­—ç¬¦ä¸² æ˜¯å­—ç¬¦ä¸²ä¸­çš„ç”±è¿ç»­å­—ç¬¦ç»„æˆçš„ä¸€ä¸ªåºåˆ—ã€‚ // å¯ä»¥ä¸¤å±‚forå¾ªç¯å†reverseåˆ¤æ–­ // dpå†™æ³• è¿™é‡Œçš„é€’æ¨å…³ç³»å’Œéå†é¡ºåºéƒ½æ¯”è¾ƒç‰¹æ®Šï¼Œdp[i][j] æ˜¯sçš„i~jé¡¹èƒ½å¦ç»„æˆå›æ–‡å­ä¸²ï¼Œéœ€è¦é å†…å±‚åˆ¤æ–­ class Solution &#123; public: int countSubstrings(string s) &#123; vector&lt;vector&lt;bool>> dp(s.size(), vector&lt;bool>(s.size(), false)); int result = 0; for (int i = s.size() - 1; i >= 0; i--)&#123; for (int j = i; j &lt; s.size(); j++)&#123; if (s[i] == s[j]) &#123; if (j - i &lt;= 1)&#123; dp[i][j] = true; result++; &#125; else&#123; if (dp[i][j] = dp[i+1][j-1] &amp; true)&#123; dp[i][j] = true; result++; &#125; &#125; &#125; &#125; &#125; return result; &#125; &#125;; 10.40 æœ€é•¿å›æ–‡å­åºåˆ—ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œæ‰¾å‡ºå…¶ä¸­æœ€é•¿çš„å›æ–‡å­åºåˆ—ï¼Œå¹¶è¿”å›è¯¥åºåˆ—çš„é•¿åº¦ã€‚ å­åºåˆ—å®šä¹‰ä¸ºï¼šä¸æ”¹å˜å‰©ä½™å­—ç¬¦é¡ºåºçš„æƒ…å†µä¸‹ï¼Œåˆ é™¤æŸäº›å­—ç¬¦æˆ–è€…ä¸åˆ é™¤ä»»ä½•å­—ç¬¦å½¢æˆçš„ä¸€ä¸ªåºåˆ—ã€‚ class Solution &#123; public: int longestPalindromeSubseq(string s) &#123; vector&lt;vector&lt;int>> dp(s.size(), vector&lt;int>(s.size(), 0)); int result = 0; for (int i = s.size() - 1; i >= 0; i--)&#123; for (int j = i; j &lt; s.size(); j++)&#123; if (s[i] == s[j]) &#123; if (j - i == 0)&#123; dp[i][j] += 1; &#125; else dp[i][j] = dp[i+1][j-1] + 2; &#125; else dp[i][j] = max(dp[i+1][j], dp[i][j-1]); &#125; &#125; return dp[0][s.size() - 1]; &#125; &#125;; &nbsp; 11. å•è°ƒæ ˆå•è°ƒæ ˆä½¿ç”¨åœºæ™¯ï¼šé€šå¸¸æ˜¯ä¸€ç»´æ•°ç»„ï¼Œè¦å¯»æ‰¾ä»»ä¸€ä¸ªå…ƒç´ çš„å³è¾¹æˆ–è€…å·¦è¾¹ç¬¬ä¸€ä¸ªæ¯”è‡ªå·±å¤§æˆ–è€…å°çš„å…ƒç´ çš„ä½ç½®ã€‚æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚ 11.1 æ¯æ—¥æ¸©åº¦ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ temperatures ï¼Œè¡¨ç¤ºæ¯å¤©çš„æ¸©åº¦ï¼Œè¿”å›ä¸€ä¸ªæ•°ç»„ answer ï¼Œå…¶ä¸­ answer[i] æ˜¯æŒ‡å¯¹äºç¬¬ i å¤©ï¼Œä¸‹ä¸€ä¸ªæ›´é«˜æ¸©åº¦å‡ºç°åœ¨å‡ å¤©åã€‚å¦‚æœæ°”æ¸©åœ¨è¿™ä¹‹åéƒ½ä¸ä¼šå‡é«˜ï¼Œè¯·åœ¨è¯¥ä½ç½®ç”¨ 0 æ¥ä»£æ›¿ã€‚ // ä¸¤å±‚forå¾ªç¯æš´åŠ›ï¼Œæœ€åä¸€ä¸ªç”¨ä¾‹è¶…æ—¶ class Solution &#123; public: vector&lt;int> dailyTemperatures(vector&lt;int>&amp; temperatures) &#123; vector&lt;int> days(temperatures.size(), 0); int size = temperatures.size(); for (int i = 0; i &lt; size; i++)&#123; int value = 1; int flag = 0; // æ²¡é‡åˆ°æ›´é«˜çš„ä¸º0 for (int j = i + 1; j &lt; size; j++)&#123; if (temperatures[j] &lt;= temperatures[i]) value++; else &#123; flag = 1; break; &#125; &#125; if(flag == 1) days[i] = value; else days[i] = 0; &#125; return days; &#125; &#125;; //å•è°ƒæ ˆå†™æ³•ï¼Œä»æ ˆé¡¶åˆ°æ ˆåº•é€’å¢ class Solution &#123; public: vector&lt;int> dailyTemperatures(vector&lt;int>&amp; temperatures) &#123; vector&lt;int> days(temperatures.size(), 0); int size = temperatures.size(); stack&lt;int> st; st.push(0); for (int i = 1; i &lt; size; i++)&#123; // æƒ…å†µä¸€ if (temperatures[i] &lt;= temperatures[st.top()]) st.push(i); // æƒ…å†µäºŒ else &#123; while (!st.empty() &amp;&amp; temperatures[i] > temperatures[st.top()])&#123; days[st.top()] = i - st.top(); st.pop(); &#125; st.push(i); &#125; &#125; return days; &#125; &#125;; 11.2 ä¸‹ä¸€ä¸ªæœ€å¤§å…ƒç´ â… nums1 ä¸­æ•°å­— x çš„ ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  æ˜¯æŒ‡ x åœ¨ nums2 ä¸­å¯¹åº”ä½ç½® å³ä¾§ çš„ ç¬¬ä¸€ä¸ª æ¯” x å¤§çš„å…ƒç´ ã€‚ ç»™ä½ ä¸¤ä¸ª æ²¡æœ‰é‡å¤å…ƒç´  çš„æ•°ç»„ nums1 å’Œ nums2 ï¼Œä¸‹æ ‡ä» 0 å¼€å§‹è®¡æ•°ï¼Œå…¶ä¸­nums1 æ˜¯ nums2 çš„å­é›†ã€‚ å¯¹äºæ¯ä¸ª 0 &lt;= i &lt; nums1.length ï¼Œæ‰¾å‡ºæ»¡è¶³ nums1[i] == nums2[j] çš„ä¸‹æ ‡ j ï¼Œå¹¶ä¸”åœ¨ nums2 ç¡®å®š nums2[j] çš„ ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  ã€‚å¦‚æœä¸å­˜åœ¨ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ ï¼Œé‚£ä¹ˆæœ¬æ¬¡æŸ¥è¯¢çš„ç­”æ¡ˆæ˜¯ -1 ã€‚ è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º nums1.length çš„æ•°ç»„ ans ä½œä¸ºç­”æ¡ˆï¼Œæ»¡è¶³ ans[i] æ˜¯å¦‚ä¸Šæ‰€è¿°çš„ ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  ã€‚ // æš´åŠ› class Solution &#123; public: vector&lt;int> nextGreaterElement(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2) &#123; vector&lt;int> result(nums1.size(), -1); for (int i = 0; i &lt; nums1.size(); i++)&#123; for (int j = 0; j &lt; nums2.size(); j++)&#123; if (nums2[j] == nums1[i])&#123; for (int k = j + 1; k &lt; nums2.size(); k++)&#123; if (nums2[k] > nums1[i])&#123; result[i] = nums2[k]; break; &#125; &#125; &#125; &#125; &#125; return result; &#125; &#125;; //å•è°ƒæ ˆ class Solution &#123; public: vector&lt;int> nextGreaterElement(vector&lt;int>&amp; nums1, vector&lt;int>&amp; nums2) &#123; vector&lt;int> result(nums1.size(), -1); stack&lt;int> st; st.push(0); unordered_map&lt;int, int> value; // &lt;value, index> for (int i = 0; i &lt; nums1.size(); i++)&#123; value[nums1[i]] = i; &#125; for (int i = 0; i &lt; nums2.size(); i++)&#123; if (nums2[i] &lt;= nums2[st.top()]) st.push(i); else &#123; while (!st.empty() &amp;&amp; nums2[i] > nums2[st.top()])&#123; if (value.count(nums2[st.top()]) > 0)&#123; int index = value[nums2[st.top()]]; result[index] = nums2[i]; &#125; st.pop(); &#125; st.push(i); &#125; &#125; return result; &#125; &#125;; 11.3 ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ â…¡ç»™å®šä¸€ä¸ªå¾ªç¯æ•°ç»„ nums ï¼ˆ nums[nums.length - 1] çš„ä¸‹ä¸€ä¸ªå…ƒç´ æ˜¯ nums[0] ï¼‰ï¼Œè¿”å› nums ä¸­æ¯ä¸ªå…ƒç´ çš„ ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  ã€‚ æ•°å­— x çš„ ä¸‹ä¸€ä¸ªæ›´å¤§çš„å…ƒç´  æ˜¯æŒ‰æ•°ç»„éå†é¡ºåºï¼Œè¿™ä¸ªæ•°å­—ä¹‹åçš„ç¬¬ä¸€ä¸ªæ¯”å®ƒæ›´å¤§çš„æ•°ï¼Œè¿™æ„å‘³ç€ä½ åº”è¯¥å¾ªç¯åœ°æœç´¢å®ƒçš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º -1 ã€‚ // ç¬¬ä¸€æ¬¡å°è¯•ï¼Œå‘ç°æœ‰è´Ÿæ•°çš„æƒ…å†µä¸‹æˆ‘çš„åå‘éå†ä¼šå‡ºé—®é¢˜ class Solution &#123; public: vector&lt;int> nextGreaterElements(vector&lt;int>&amp; nums) &#123; vector&lt;int> result(nums.size(), -1); stack&lt;int> st; st.push(0); // ç¬¬ä¸€æ¬¡ï¼šæ­£å‘éå† for (int i = 1; i &lt; nums.size(); i++)&#123; if (nums[i] &lt;= nums[st.top()]) st.push(i); else &#123; while (!st.empty() &amp;&amp; nums[i] > nums[st.top()])&#123; result[st.top()] = nums[i]; st.pop(); &#125; st.push(i); &#125; &#125; // ç¬¬äºŒæ¬¡ï¼šåå‘ for (int i = nums.size() -1; i >= 0; i--)&#123; if (result[i] == -1)&#123; for (int j = 0; j &lt; i; j++)&#123; if (nums[j] > nums[i]) &#123; result[i] = nums[j]; break; &#125; &#125; &#125; &#125; return result; &#125; &#125;; // æ‹¼æ¥æˆä¸¤å€æ•°ç»„å°±å¯ä»¥äº†ï¼Œæ›´ç²¾ç®€å¯ä»¥ç”¨i % nums.size() class Solution &#123; public: vector&lt;int> nextGreaterElements(vector&lt;int>&amp; nums) &#123; vector&lt;int> result(nums.size(), -1); stack&lt;int> st; st.push(0); for (int i = 1; i &lt; nums.size() * 2; i++)&#123; // å‰åŠæ®µ if (i &lt; nums.size())&#123; if (nums[i] &lt;= nums[st.top()]) st.push(i); else &#123; while (!st.empty() &amp;&amp; nums[i] > nums[st.top()])&#123; result[st.top()] = nums[i]; st.pop(); &#125; st.push(i); &#125; &#125; // ååŠæ®µ else&#123; int index = i - nums.size(); if (nums[index] &lt;= nums[st.top()]) st.push(index); else &#123; while (!st.empty() &amp;&amp; nums[index] > nums[st.top()])&#123; result[st.top()] = nums[index]; st.pop(); &#125; st.push(index); &#125; &#125; &#125; return result; &#125; &#125;; 11.4 æ¥é›¨æ°´ç»™å®š n ä¸ªéè´Ÿæ•´æ•°è¡¨ç¤ºæ¯ä¸ªå®½åº¦ä¸º 1 çš„æŸ±å­çš„é«˜åº¦å›¾ï¼Œè®¡ç®—æŒ‰æ­¤æ’åˆ—çš„æŸ±å­ï¼Œä¸‹é›¨ä¹‹åèƒ½æ¥å¤šå°‘é›¨æ°´ã€‚ class Solution &#123; public: int trap(vector&lt;int>&amp; height) &#123; if (height.size() == 1) return 0; int result = 0; stack&lt;int> st; st.push(0); for (int i = 1; i &lt; height.size(); i++)&#123; if (height[i] &lt; height[st.top()]) st.push(i); else if (height[i] == height[st.top()])&#123; // st.pop()å¯ä»¥ä¸åŠ  st.pop(); st.push(i); &#125; else&#123; while (!st.empty() &amp;&amp; height[i] > height[st.top()])&#123; int mid = height[st.top()]; st.pop(); if (!st.empty())&#123; int w = i - st.top() - 1; int h = min(height[st.top()], height[i]) - mid; result += w * h; &#125; &#125; st.push(i); &#125; &#125; return result; &#125; &#125;; 11.5 æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢ç»™å®š n ä¸ªéè´Ÿæ•´æ•°ï¼Œç”¨æ¥è¡¨ç¤ºæŸ±çŠ¶å›¾ä¸­å„ä¸ªæŸ±å­çš„é«˜åº¦ã€‚æ¯ä¸ªæŸ±å­å½¼æ­¤ç›¸é‚»ï¼Œä¸”å®½åº¦ä¸º 1 ã€‚ æ±‚åœ¨è¯¥æŸ±çŠ¶å›¾ä¸­ï¼Œèƒ½å¤Ÿå‹¾å‹’å‡ºæ¥çš„çŸ©å½¢çš„æœ€å¤§é¢ç§¯ã€‚ class Solution &#123; public: int largestRectangleArea(vector&lt;int>&amp; heights) &#123; int result = 0; stack&lt;int> st; st.push(0); // å’Œæ¥é›¨æ°´ä¸åŒï¼Œè¿™é‡Œå¼€å¤´å’Œç»“å°¾éƒ½éœ€è¦è¡¥é›¶ï¼Œå¼€å¤´ä¸ºäº†è®¡ç®—å¼€å¤´å€¼ï¼Œç»“å°¾ä¸ºäº†é˜²æ­¢ä¸€ç›´ä¸è¿›å¾ªç¯ heights.insert(heights.begin(), 0); heights.push_back(0); for (int i = 1; i &lt; heights.size(); i++)&#123; if (heights[i] > heights[st.top()]) st.push(i); else if (heights[i] == heights[st.top()]) &#123; st.pop(); st.push(i); &#125; else&#123; while (!st.empty() &amp;&amp; (heights[i] &lt; heights[st.top()]) )&#123; int mid = st.top(); st.pop(); if (!st.empty())&#123; int h = i - st.top() - 1; int w = heights[mid]; result = max(h * w, result); &#125; &#125; st.push(i); &#125; &#125; return result; &#125; &#125;; 12. å›¾è®º12.1 ç†è®ºåŸºç¡€å›¾çš„ç§ç±» æœ‰å‘å›¾ æ— å‘å›¾ åŠ æƒå›¾ åº¦ æ— å‘å›¾ä¸­æœ‰å‡ æ¡è¾¹è¿æ¥è¯¥èŠ‚ç‚¹ï¼Œè¯¥èŠ‚ç‚¹å°±æœ‰å‡ åº¦ æœ‰å‘å›¾ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ‰å‡ºåº¦å’Œå…¥åº¦ï¼Œå‡ºåº¦æ˜¯ä»è¯¥èŠ‚ç‚¹å‡ºå‘çš„è¾¹çš„ä¸ªæ•°ï¼Œ å…¥åº¦æ˜¯æŒ‡å‘è¯¥èŠ‚ç‚¹çš„è¾¹çš„ä¸ªæ•° è¿é€šæ€§ æ— å‘å›¾ä¸­ï¼Œä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹éƒ½æ˜¯å¯ä»¥åˆ°è¾¾çš„ï¼Œå¯ç§°ä¹‹ä¸ºè¿é€šå›¾ï¼Œå¦‚æœæœ‰èŠ‚ç‚¹ä¸èƒ½åˆ°è¾¾å…¶ä»–èŠ‚ç‚¹ï¼Œåˆ™ä¸ºéè¿é€šå›¾ æ— å‘å›¾ä¸­çš„æå¤§è¿é€šå­å›¾ç§°ä¹‹ä¸ºè¯¥å›¾çš„ä¸€ä¸ªè¿é€šåˆ†é‡ æœ‰å‘å›¾ä¸­ï¼Œä¸¤ä¸ªèŠ‚ç‚¹å¯ä»¥ç›¸äº’åˆ°è¾¾ï¼Œåˆ™è¿™ä¸¤ä¸ªèŠ‚ç‚¹ä¸ºå¼ºè¿é€šå›¾ æœ‰å‘å›¾ä¸­ï¼Œæå¤§å¼ºè¿é€šå­å›¾ç§°ä¹‹ä¸ºè¯¥å›¾çš„å¼ºè¿é€šåˆ†é‡ å›¾çš„æ„é€  å•ç»´å­˜å‚¨ æœ‰næ¡è¾¹å°±å®šä¹‰n*2çš„æ•°ç»„ï¼Œæˆ–è€…mapæˆ–è€…ç±»ï¼Œæ¯è¡Œå­˜å‚¨è¾¹ä¸¤è¾¹çš„èŠ‚ç‚¹ï¼Œç”±èŠ‚ç‚¹0æŒ‡å‘èŠ‚ç‚¹1 ä¼˜ç‚¹ï¼šç›´è§‚ï¼Œè¡¨ç¤ºèŠ‚ç‚¹ä¹‹é—´çš„å…³ç³» ç¼ºç‚¹ï¼š æŸ¥æ‰¾æ—¶éœ€è¦éå† é‚»æ¥çŸ©é˜µ ä½¿ç”¨äºŒç»´æ•°ç»„æ¥è¡¨ç¤ºå›¾ç»“æ„ã€‚é‚»æ¥çŸ©é˜µä»èŠ‚ç‚¹çš„è§’åº¦è¡¨ç¤ºå›¾ï¼Œæœ‰nä¸ªèŠ‚ç‚¹å°±å®šä¹‰n*nçš„äºŒç»´æ•°ç»„çš„å€¼è¡¨ç¤ºnæŒ‡å‘mçš„æƒé‡ ä¼˜ç‚¹ï¼š æŸ¥æ‰¾æ¯”è¾ƒå¿«ï¼Œè¡¨è¾¾æ¯”è¾ƒç®€å• ç¼ºç‚¹ï¼š ç¨€ç–å›¾æµªè´¹ç©ºé—´ é‚»æ¥è¡¨ ä½¿ç”¨æ•°ç»„ + é“¾è¡¨çš„æ–¹å¼æ¥è¡¨ç¤ºï¼Œæ•°ç»„å¤§å°ä¸ºèŠ‚ç‚¹æ•°ï¼Œé“¾è¡¨å¤§å°ä¸ºè¾¹çš„æ•°é‡ 12.2 æ·±åº¦ä¼˜å…ˆæœç´¢ç†è®ºåŸºç¡€ dfsï¼šä¸€ä¸ªæ–¹å‘æœç´¢åˆ°åº• + å›æº¯æ€æƒ³ void dfs(å‚æ•°) &#123; if (ç»ˆæ­¢æ¡ä»¶) &#123; å­˜æ”¾ç»“æœ; return; &#125; for (é€‰æ‹©ï¼šæœ¬èŠ‚ç‚¹æ‰€è¿æ¥çš„å…¶ä»–èŠ‚ç‚¹) &#123; å¤„ç†èŠ‚ç‚¹; dfs(å›¾ï¼Œé€‰æ‹©çš„èŠ‚ç‚¹); // é€’å½’ å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ &#125; &#125; 12.3 å¹¿åº¦ä¼˜å…ˆæœç´¢ç†è®ºåŸºç¡€bfsï¼šä¸€åœˆä¸€åœˆåœ°æœç´¢ï¼Œå‘å¤–æ‰©å±• æ”¾ç½®å®¹å™¨é€‰æ‹©é˜Ÿåˆ—ï¼Œå’ŒäºŒå‰æ ‘çš„å±‚åºéå†ä¿æŒä¸€è‡´ å¯¹äºå››æ–¹æ ¼çš„æ¨¡æ¿ï¼š int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; // è¡¨ç¤ºå››ä¸ªæ–¹å‘ // grid æ˜¯åœ°å›¾ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªäºŒç»´æ•°ç»„ // visitedæ ‡è®°è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œä¸è¦é‡å¤è®¿é—® // x,y è¡¨ç¤ºå¼€å§‹æœç´¢èŠ‚ç‚¹çš„ä¸‹æ ‡ void bfs(vector&lt;vector&lt;char>>&amp; grid, vector&lt;vector&lt;bool>>&amp; visited, int x, int y) &#123; queue&lt;pair&lt;int, int>> que; // å®šä¹‰é˜Ÿåˆ— que.push(&#123;x, y&#125;); // èµ·å§‹èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ— visited[x][y] = true; // åªè¦åŠ å…¥é˜Ÿåˆ—ï¼Œç«‹åˆ»æ ‡è®°ä¸ºè®¿é—®è¿‡çš„èŠ‚ç‚¹ while(!que.empty()) &#123; // å¼€å§‹éå†é˜Ÿåˆ—é‡Œçš„å…ƒç´  pair&lt;int ,int> cur = que.front(); que.pop(); // ä»é˜Ÿåˆ—å–å…ƒç´  int curx = cur.first; int cury = cur.second; // å½“å‰èŠ‚ç‚¹åæ ‡ for (int i = 0; i &lt; 4; i++) &#123; // å¼€å§‹æƒ³å½“å‰èŠ‚ç‚¹çš„å››ä¸ªæ–¹å‘å·¦å³ä¸Šä¸‹å»éå† int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; // è·å–å‘¨è¾¹å››ä¸ªæ–¹å‘çš„åæ ‡ if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; // åæ ‡è¶Šç•Œäº†ï¼Œç›´æ¥è·³è¿‡ if (!visited[nextx][nexty]) &#123; // å¦‚æœèŠ‚ç‚¹æ²¡è¢«è®¿é—®è¿‡ que.push(&#123;nextx, nexty&#125;); // é˜Ÿåˆ—æ·»åŠ è¯¥èŠ‚ç‚¹ä¸ºä¸‹ä¸€è½®è¦éå†çš„èŠ‚ç‚¹ visited[nextx][nexty] = true; // åªè¦åŠ å…¥é˜Ÿåˆ—ç«‹åˆ»æ ‡è®°ï¼Œé¿å…é‡å¤è®¿é—® &#125; &#125; &#125; &#125; 12.4 å¹¶æŸ¥é›†ç†è®ºåŸºç¡€å¹¶æŸ¥é›†å¸¸ç”¨æ¥è§£å†³è¿é€šæ€§é—®é¢˜ã€‚ å¹¶æŸ¥é›†ä¸»è¦æœ‰ä¸¤ä¸ªåŠŸèƒ½ï¼š å°†ä¸¤ä¸ªå…ƒç´ æ·»åŠ åˆ°ä¸€ä¸ªé›†åˆä¸­ã€‚ åˆ¤æ–­ä¸¤ä¸ªå…ƒç´ åœ¨ä¸åœ¨åŒä¸€ä¸ªé›†åˆ int n = 1005; // næ ¹æ®é¢˜ç›®ä¸­èŠ‚ç‚¹æ•°é‡è€Œå®šï¼Œä¸€èˆ¬æ¯”èŠ‚ç‚¹æ•°é‡å¤§ä¸€ç‚¹å°±å¥½ vector&lt;int> father = vector&lt;int> (n, 0); // C++é‡Œçš„ä¸€ç§æ•°ç»„ç»“æ„ // å¹¶æŸ¥é›†åˆå§‹åŒ– void init() &#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; &#125; &#125; // å¹¶æŸ¥é›†é‡Œå¯»æ ¹çš„è¿‡ç¨‹ int find(int u) &#123; if (u == father[u]) return u; // å¦‚æœæ ¹å°±æ˜¯è‡ªå·±ï¼Œç›´æ¥è¿”å› else return find(father[u]); // å¦‚æœæ ¹ä¸æ˜¯è‡ªå·±ï¼Œå°±æ ¹æ®æ•°ç»„ä¸‹æ ‡ä¸€å±‚ä¸€å±‚å‘ä¸‹æ‰¾ &#125; // å¹¶æŸ¥é›†é‡Œå¯»æ ¹çš„è¿‡ç¨‹ è·¯å¾„å‹ç¼© int find(int u) &#123; if (u == father[u]) return u; else return father[u] = find(father[u]); // è·¯å¾„å‹ç¼© &#125; // åˆ¤æ–­ u å’Œ væ˜¯å¦æ‰¾åˆ°åŒä¸€ä¸ªæ ¹ bool isSame(int u, int v) &#123; u = find(u); v = find(v); return u == v; &#125; // å°†v->u è¿™æ¡è¾¹åŠ å…¥å¹¶æŸ¥é›† void join(int u, int v) &#123; u = find(u); // å¯»æ‰¾uçš„æ ¹ v = find(v); // å¯»æ‰¾vçš„æ ¹ if (u == v) return ; // å¦‚æœå‘ç°æ ¹ç›¸åŒï¼Œåˆ™è¯´æ˜åœ¨ä¸€ä¸ªé›†åˆï¼Œä¸ç”¨ä¸¤ä¸ªèŠ‚ç‚¹ç›¸è¿ç›´æ¥è¿”å› father[v] = u; &#125; 12.5 æ¡ˆä¾‹Problem 1 æ‰€æœ‰å¯è¾¾è·¯å¾„ ç»™å®šä¸€ä¸ªæœ‰ n ä¸ªèŠ‚ç‚¹çš„æœ‰å‘æ— ç¯å›¾ï¼ŒèŠ‚ç‚¹ç¼–å·ä» 1 åˆ° nã€‚è¯·ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œæ‰¾å‡ºå¹¶è¿”å›æ‰€æœ‰ä»èŠ‚ç‚¹ 1 åˆ°èŠ‚ç‚¹ n çš„è·¯å¾„ã€‚æ¯æ¡è·¯å¾„åº”ä»¥èŠ‚ç‚¹ç¼–å·çš„åˆ—è¡¨å½¢å¼è¡¨ç¤ºã€‚ #include &lt;iostream> #include &lt;vector> using namespace std; vector&lt;int> path; vector&lt;vector&lt;int>> result; void dfs(vector&lt;vector&lt;int>> &amp;graph, int x, int n); int main()&#123; int n, m; cin >> n >> m; // store path - array vector&lt;vector&lt;int>> graph(n + 1, vector&lt;int>(n + 1, 0)); while (m--)&#123; int s, t; cin >> s >> t; graph[s][t] = 1; &#125; // pre path.push_back(1); // execute dfs(graph, 1 ,n); // print - delete the last space if (result.size() == 0) cout &lt;&lt; -1 &lt;&lt; endl; for (const vector&lt;int> &amp;pa : result) &#123; for (int i = 0; i &lt; pa.size() - 1; i++) &#123; cout &lt;&lt; pa[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; pa[pa.size() - 1] &lt;&lt; endl; &#125; return 0; &#125; // dfs void dfs(vector&lt;vector&lt;int>> &amp;graph, int x, int n)&#123; if (x == n)&#123; result.push_back(path); return; &#125; for (int i = 1; i &lt;= n; i++)&#123; if (graph[x][i] == 1)&#123; path.push_back(i); dfs(graph, i, n); path.pop_back(); &#125; &#125; &#125; Problem 2 å²›å±¿æ•°é‡é¢˜ç›®æè¿°ï¼š ç»™å®šä¸€ä¸ªç”± 1ï¼ˆé™†åœ°ï¼‰å’Œ 0ï¼ˆæ°´ï¼‰ç»„æˆçš„çŸ©é˜µï¼Œä½ éœ€è¦è®¡ç®—å²›å±¿çš„æ•°é‡ã€‚å²›å±¿ç”±æ°´å¹³æ–¹å‘æˆ–å‚ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥è€Œæˆï¼Œå¹¶ä¸”å››å‘¨éƒ½æ˜¯æ°´åŸŸã€‚ä½ å¯ä»¥å‡è®¾çŸ©é˜µå¤–å‡è¢«æ°´åŒ…å›´ã€‚ è¾“å…¥æè¿°ï¼š ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° N, Mï¼Œè¡¨ç¤ºçŸ©é˜µçš„è¡Œæ•°å’Œåˆ—æ•°ã€‚ åç»­ N è¡Œï¼Œæ¯è¡ŒåŒ…å« M ä¸ªæ•°å­—ï¼Œæ•°å­—ä¸º 1 æˆ–è€… 0ã€‚ è¾“å‡ºæè¿°ï¼š è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºå²›å±¿çš„æ•°é‡ã€‚å¦‚æœä¸å­˜åœ¨å²›å±¿ï¼Œåˆ™è¾“å‡º 0ã€‚ /*dfs*/ #include &lt;iostream> #include &lt;vector> using namespace std; int dir[4][2] = &#123;0,1,1,0,0,-1,-1,0&#125;; void dfs(const vector&lt;vector&lt;int>> &amp;grid, vector&lt;vector&lt;bool>> &amp;visited, int i, int j)&#123; if (grid[i][j] == 0 || visited[i][j] == true) return; visited[i][j] = true; for (int k = 0; k &lt; 4; k++)&#123; int nextx = i; int nexty = j; nextx += dir[k][0]; nexty += dir[k][1]; if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; dfs(grid, visited, nextx, nexty); &#125; &#125; int main()&#123; int n,m; cin >> n >> m; vector&lt;vector&lt;int>> grid(n, vector&lt;int>(m,0)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin >> grid[i][j]; &#125; &#125; int result = 0; vector&lt;vector&lt;bool>> visited(n, vector&lt;bool>(m, false)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (visited[i][j] == false &amp;&amp; grid[i][j] == 1)&#123; result++; dfs(grid, visited, i, j); &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0; &#125; /*bfs*/ #include &lt;iostream> #include &lt;vector> #include &lt;queue> using namespace std; int dir[4][2] = &#123;0,1,1,0,0,-1,-1,0&#125;; void bfs(const vector&lt;vector&lt;int>> &amp;grid, vector&lt;vector&lt;bool>> &amp;visited, int i, int j)&#123; queue &lt;pair&lt;int,int>> que; que.push(&#123;i,j&#125;); visited[i][j] = true; while (!que.empty())&#123; pair&lt;int, int> cur = que.front(); que.pop(); for (int k = 0; k &lt; 4; k++)&#123; int nextx = cur.first; int nexty = cur.second; nextx += dir[k][0]; nexty += dir[k][1]; if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; if (visited[nextx][nexty] == false &amp;&amp; grid[nextx][nexty] == 1)&#123; que.push(&#123;nextx, nexty&#125;); visited[nextx][nexty] = true; &#125; &#125; &#125; &#125; int main()&#123; int n,m; cin >> n >> m; vector&lt;vector&lt;int>> grid(n, vector&lt;int>(m,0)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin >> grid[i][j]; &#125; &#125; int result = 0; vector&lt;vector&lt;bool>> visited(n, vector&lt;bool>(m, false)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (visited[i][j] == false &amp;&amp; grid[i][j] == 1)&#123; result++; bfs(grid, visited, i, j); &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0; &#125; Problem 3 å²›å±¿çš„æœ€å¤§é¢ç§¯é¢˜ç›®æè¿° ç»™å®šä¸€ä¸ªç”± 1ï¼ˆé™†åœ°ï¼‰å’Œ 0ï¼ˆæ°´ï¼‰ç»„æˆçš„çŸ©é˜µï¼Œè®¡ç®—å²›å±¿çš„æœ€å¤§é¢ç§¯ã€‚å²›å±¿é¢ç§¯çš„è®¡ç®—æ–¹å¼ä¸ºç»„æˆå²›å±¿çš„é™†åœ°çš„æ€»æ•°ã€‚å²›å±¿ç”±æ°´å¹³æ–¹å‘æˆ–å‚ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥è€Œæˆï¼Œå¹¶ä¸”å››å‘¨éƒ½æ˜¯æ°´åŸŸã€‚ä½ å¯ä»¥å‡è®¾çŸ©é˜µå¤–å‡è¢«æ°´åŒ…å›´ã€‚ è¾“å…¥æè¿° ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° N, Mï¼Œè¡¨ç¤ºçŸ©é˜µçš„è¡Œæ•°å’Œåˆ—æ•°ã€‚åç»­ N è¡Œï¼Œæ¯è¡ŒåŒ…å« M ä¸ªæ•°å­—ï¼Œæ•°å­—ä¸º 1 æˆ–è€… 0ï¼Œè¡¨ç¤ºå²›å±¿çš„å•å…ƒæ ¼ã€‚ è¾“å‡ºæè¿° è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºå²›å±¿çš„æœ€å¤§é¢ç§¯ã€‚å¦‚æœä¸å­˜åœ¨å²›å±¿ï¼Œåˆ™è¾“å‡º 0ã€‚ #include &lt;iostream> #include &lt;vector> using namespace std; int dir[4][2] = &#123;0,1,1,0,0,-1,-1,0&#125;; void dfs(const vector&lt;vector&lt;int>> &amp;grid, vector&lt;vector&lt;bool>> &amp;visited, int x, int y, int &amp;area)&#123; if (visited[x][y] || grid[x][y] == 0) return; // é€»è¾‘åœ¨åŠ å…¥æ–°èŠ‚ç‚¹æ—¶è€ƒè™‘ï¼Œè€Œä¸æ˜¯åœ¨ä¸‹é¢çš„éå†ä¸­è€ƒè™‘ visited[x][y] = true; area ++; for (int i = 0; i &lt; 4; i++)&#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; dfs(grid, visited, nextx, nexty, area); &#125; &#125; int main()&#123; int result = 0; int n, m; int area = 0; cin >> n >> m; vector&lt;vector&lt;int>> grid(n , vector&lt;int>(m, 0)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin >> grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool>> visited(n, vector&lt;bool>(m,false)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (!visited[i][j] &amp;&amp; grid[i][j])&#123; area = 0; dfs(grid,visited,i, j, area); result = max(result, area); &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0; &#125; Problem 4 å²›å±¿çš„æ€»é¢ç§¯é¢˜ç›®æè¿° ç»™å®šä¸€ä¸ªç”± 1ï¼ˆé™†åœ°ï¼‰å’Œ 0ï¼ˆæ°´ï¼‰ç»„æˆçš„çŸ©é˜µï¼Œå²›å±¿æŒ‡çš„æ˜¯ç”±æ°´å¹³æˆ–å‚ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°å•å…ƒæ ¼ç»„æˆçš„åŒºåŸŸï¼Œä¸”å®Œå…¨è¢«æ°´åŸŸå•å…ƒæ ¼åŒ…å›´ã€‚å­¤å²›æ˜¯é‚£äº›ä½äºçŸ©é˜µå†…éƒ¨ã€æ‰€æœ‰å•å…ƒæ ¼éƒ½ä¸æ¥è§¦è¾¹ç¼˜çš„å²›å±¿ã€‚ ç°åœ¨ä½ éœ€è¦è®¡ç®—æ‰€æœ‰å­¤å²›çš„æ€»é¢ç§¯ï¼Œå²›å±¿é¢ç§¯çš„è®¡ç®—æ–¹å¼ä¸ºç»„æˆå²›å±¿çš„é™†åœ°çš„æ€»æ•°ã€‚ è¾“å…¥æè¿° ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° N, Mï¼Œè¡¨ç¤ºçŸ©é˜µçš„è¡Œæ•°å’Œåˆ—æ•°ã€‚ä¹‹å N è¡Œï¼Œæ¯è¡ŒåŒ…å« M ä¸ªæ•°å­—ï¼Œæ•°å­—ä¸º 1 æˆ–è€… 0ã€‚ è¾“å‡ºæè¿° è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæ‰€æœ‰å­¤å²›çš„æ€»é¢ç§¯ï¼Œå¦‚æœä¸å­˜åœ¨å­¤å²›ï¼Œåˆ™è¾“å‡º 0ã€‚ /* 1. æŠŠå››æ¡è¾¹ä¸Šè¿æ¥çš„å²›å±¿éƒ½æ¸…é›¶ 2. éå†ç½‘æ ¼ */ #include &lt;iostream> #include &lt;vector> using namespace std; int dir[4][2] = &#123;1,0,0,1,0,-1,-1,0&#125;; void dfs(vector&lt;vector&lt;int>> &amp;grid, vector&lt;vector&lt;bool>> &amp;visited, int x, int y) &#123; if (grid[x][y] == 0 || visited[x][y]) return; visited[x][y] = true; grid[x][y] = 0; for (int k = 0; k &lt; 4; k++)&#123; int nextx = x + dir[k][0]; int nexty = y + dir[k][1]; if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; dfs(grid, visited, nextx, nexty); &#125; &#125; int main()&#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> grid(n , vector&lt;int>(m, 0)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin >> grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool>> visited(n, vector&lt;bool>(m, false)); // 0,n-1è¡Œéå† for (int i = 0; i &lt; m; i++) dfs(grid, visited, 0, i); for (int i = 0; i &lt; m; i++) dfs(grid, visited, n-1, i); // 0,m-1åˆ—éå† for (int i = 0; i &lt; n; i++) dfs(grid, visited, i, 0); for (int i = 0; i &lt; n; i++) dfs(grid, visited, i, m-1); // result int result = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (grid[i][j] == 1) result++; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0; &#125; Problem 5 æ²‰æ²¡å­¤å²›é¢˜ç›®æè¿°ï¼š ç»™å®šä¸€ä¸ªç”± 1ï¼ˆé™†åœ°ï¼‰å’Œ 0ï¼ˆæ°´ï¼‰ç»„æˆçš„çŸ©é˜µï¼Œå²›å±¿æŒ‡çš„æ˜¯ç”±æ°´å¹³æˆ–å‚ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°å•å…ƒæ ¼ç»„æˆçš„åŒºåŸŸï¼Œä¸”å®Œå…¨è¢«æ°´åŸŸå•å…ƒæ ¼åŒ…å›´ã€‚å­¤å²›æ˜¯é‚£äº›ä½äºçŸ©é˜µå†…éƒ¨ã€æ‰€æœ‰å•å…ƒæ ¼éƒ½ä¸æ¥è§¦è¾¹ç¼˜çš„å²›å±¿ã€‚ ç°åœ¨ä½ éœ€è¦å°†æ‰€æœ‰å­¤å²›â€œæ²‰æ²¡â€ï¼Œå³å°†å­¤å²›ä¸­çš„æ‰€æœ‰é™†åœ°å•å…ƒæ ¼ï¼ˆ1ï¼‰è½¬å˜ä¸ºæ°´åŸŸå•å…ƒæ ¼ï¼ˆ0ï¼‰ã€‚ è¾“å…¥æè¿°ï¼š ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° N, Mï¼Œè¡¨ç¤ºçŸ©é˜µçš„è¡Œæ•°å’Œåˆ—æ•°ã€‚ ä¹‹å N è¡Œï¼Œæ¯è¡ŒåŒ…å« M ä¸ªæ•°å­—ï¼Œæ•°å­—ä¸º 1 æˆ–è€… 0ï¼Œè¡¨ç¤ºå²›å±¿çš„å•å…ƒæ ¼ã€‚ è¾“å‡ºæè¿° è¾“å‡ºå°†å­¤å²›â€œæ²‰æ²¡â€ä¹‹åçš„å²›å±¿çŸ©é˜µã€‚ /* å’Œä¸Šä¸€é¢˜æœ¬è´¨ä¸Šä¸€æ · */ #include &lt;iostream> #include &lt;vector> using namespace std; int dir[4][2] = &#123;1,0,0,1,0,-1,-1,0&#125;; void dfs(vector&lt;vector&lt;int>> &amp;grid, vector&lt;vector&lt;bool>> &amp;visited, int x, int y) &#123; if (grid[x][y] == 0 || visited[x][y]) return; visited[x][y] = true; grid[x][y] += 1; for (int k = 0; k &lt; 4; k++)&#123; int nextx = x + dir[k][0]; int nexty = y + dir[k][1]; if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; dfs(grid, visited, nextx, nexty); &#125; &#125; int main()&#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> grid(n , vector&lt;int>(m, 0)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin >> grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool>> visited(n, vector&lt;bool>(m, false)); // 0,n-1è¡Œéå† for (int i = 0; i &lt; m; i++) dfs(grid, visited, 0, i); for (int i = 0; i &lt; m; i++) dfs(grid, visited, n-1, i); // 0,m-1åˆ—éå† for (int i = 0; i &lt; n; i++) dfs(grid, visited, i, 0); for (int i = 0; i &lt; n; i++) dfs(grid, visited, i, m-1); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (grid[i][j] > 0) grid[i][j] -= 1; cout &lt;&lt; grid[i][j] &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125; return 0; &#125; Problem 6 æ°´æµé—®é¢˜é¢˜ç›®æè¿°ï¼š ç°æœ‰ä¸€ä¸ª N Ã— M çš„çŸ©é˜µï¼Œæ¯ä¸ªå•å…ƒæ ¼åŒ…å«ä¸€ä¸ªæ•°å€¼ï¼Œè¿™ä¸ªæ•°å€¼ä»£è¡¨è¯¥ä½ç½®çš„ç›¸å¯¹é«˜åº¦ã€‚çŸ©é˜µçš„å·¦è¾¹ç•Œå’Œä¸Šè¾¹ç•Œè¢«è®¤ä¸ºæ˜¯ç¬¬ä¸€ç»„è¾¹ç•Œï¼Œè€ŒçŸ©é˜µçš„å³è¾¹ç•Œå’Œä¸‹è¾¹ç•Œè¢«è§†ä¸ºç¬¬äºŒç»„è¾¹ç•Œã€‚ çŸ©é˜µæ¨¡æ‹Ÿäº†ä¸€ä¸ªåœ°å½¢ï¼Œå½“é›¨æ°´è½åœ¨ä¸Šé¢æ—¶ï¼Œæ°´ä¼šæ ¹æ®åœ°å½¢çš„å€¾æ–œå‘ä½å¤„æµåŠ¨ï¼Œä½†åªèƒ½ä»è¾ƒé«˜æˆ–ç­‰é«˜çš„åœ°ç‚¹æµå‘è¾ƒä½æˆ–ç­‰é«˜å¹¶ä¸”ç›¸é‚»ï¼ˆä¸Šä¸‹å·¦å³æ–¹å‘ï¼‰çš„åœ°ç‚¹ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯ç¡®å®šé‚£äº›å•å…ƒæ ¼ï¼Œä»è¿™äº›å•å…ƒæ ¼å‡ºå‘çš„æ°´å¯ä»¥è¾¾åˆ°ç¬¬ä¸€ç»„è¾¹ç•Œå’Œç¬¬äºŒç»„è¾¹ç•Œã€‚ è¾“å…¥æè¿°ï¼š ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° N å’Œ Mï¼Œåˆ†åˆ«è¡¨ç¤ºçŸ©é˜µçš„è¡Œæ•°å’Œåˆ—æ•°ã€‚ åç»­ N è¡Œï¼Œæ¯è¡ŒåŒ…å« M ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºçŸ©é˜µä¸­çš„æ¯ä¸ªå•å…ƒæ ¼çš„é«˜åº¦ã€‚ è¾“å‡ºæè¿°ï¼š è¾“å‡ºå…±æœ‰å¤šè¡Œï¼Œæ¯è¡Œè¾“å‡ºä¸¤ä¸ªæ•´æ•°ï¼Œç”¨ä¸€ä¸ªç©ºæ ¼éš”å¼€ï¼Œè¡¨ç¤ºå¯è¾¾ç¬¬ä¸€ç»„è¾¹ç•Œå’Œç¬¬äºŒç»„è¾¹ç•Œçš„å•å…ƒæ ¼çš„åæ ‡ï¼Œè¾“å‡ºé¡ºåºä»»æ„ã€‚ /* æ€æƒ³ï¼šä»ä¸¤ä¸ªè¾¹ç•Œå‡ºå‘ï¼Œåå‘éå†ï¼Œä¸¤ä¸ªæ¡ä»¶éƒ½æ»¡è¶³çš„äº¤å‰ç‚¹å³ä¸ºç­”æ¡ˆ */ #include &lt;iostream> #include &lt;vector> using namespace std; int dir[4][2] = &#123;1,0,0,1,0,-1,-1,0&#125;; void dfs(vector&lt;vector&lt;int>> &amp;grid, vector&lt;vector&lt;bool>> &amp;visited, int x, int y)&#123; if (visited[x][y] == true) return; visited[x][y] = true; for (int k = 0; k &lt; 4; k++)&#123; int nextx = x + dir[k][0]; int nexty = y + dir[k][1]; if (nextx &lt; 0 || nextx >= grid.size() || nexty &lt; 0 || nexty >= grid[0].size()) continue; if (grid[x][y] > grid[nextx][nexty]) continue; dfs(grid, visited, nextx, nexty); &#125; &#125; int main()&#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> grid(n , vector&lt;int>(m , 0)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin >> grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool>> firstvisited(n, vector&lt;bool>(m, false)); vector&lt;vector&lt;bool>> secondvisited(n, vector&lt;bool>(m, false)); // è¾¹ç•Œ1 åå‘éå† for (int i = 0; i &lt; n; i++) dfs(grid, firstvisited, i, 0); for (int i = 0; i &lt; m; i++) dfs(grid, firstvisited, 0, i); // è¾¹ç•Œ2 åå‘éå† for (int i = 0; i &lt; n; i++) dfs(grid, secondvisited, i, m-1); for (int i = 0; i &lt; m; i++) dfs(grid, secondvisited, n-1, i); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (firstvisited[i][j] &amp;&amp; secondvisited[i][j]) cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl; &#125; &#125; return 0; &#125; Problem 7 å»ºé€ æœ€å¤§å²›å±¿é¢˜ç›®æè¿°ï¼š ç»™å®šä¸€ä¸ªç”± 1ï¼ˆé™†åœ°ï¼‰å’Œ 0ï¼ˆæ°´ï¼‰ç»„æˆçš„çŸ©é˜µï¼Œä½ æœ€å¤šå¯ä»¥å°†çŸ©é˜µä¸­çš„ä¸€æ ¼æ°´å˜ä¸ºä¸€å—é™†åœ°ï¼Œåœ¨æ‰§è¡Œäº†æ­¤æ“ä½œä¹‹åï¼ŒçŸ©é˜µä¸­æœ€å¤§çš„å²›å±¿é¢ç§¯æ˜¯å¤šå°‘ã€‚ å²›å±¿é¢ç§¯çš„è®¡ç®—æ–¹å¼ä¸ºç»„æˆå²›å±¿çš„é™†åœ°çš„æ€»æ•°ã€‚å²›å±¿æ˜¯è¢«æ°´åŒ…å›´ï¼Œå¹¶ä¸”é€šè¿‡æ°´å¹³æ–¹å‘æˆ–å‚ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥è€Œæˆçš„ã€‚ä½ å¯ä»¥å‡è®¾çŸ©é˜µå¤–å‡è¢«æ°´åŒ…å›´ã€‚ è¾“å…¥æè¿°ï¼š ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° N, Mï¼Œè¡¨ç¤ºçŸ©é˜µçš„è¡Œæ•°å’Œåˆ—æ•°ã€‚ä¹‹å N è¡Œï¼Œæ¯è¡ŒåŒ…å« M ä¸ªæ•°å­—ï¼Œæ•°å­—ä¸º 1 æˆ–è€… 0ï¼Œè¡¨ç¤ºå²›å±¿çš„å•å…ƒæ ¼ã€‚ è¾“å‡ºæè¿°ï¼š è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæœ€å¤§çš„å²›å±¿é¢ç§¯ã€‚ #include &lt;iostream> #include &lt;vector> #include &lt;unordered_set> #include &lt;unordered_map> using namespace std; int n, m; int count; int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;; void dfs(vector&lt;vector&lt;int>>&amp; grid, vector&lt;vector&lt;bool>>&amp; visited, int x, int y, int mark) &#123; if (visited[x][y] || grid[x][y] == 0) return; visited[x][y] = true; grid[x][y] = mark; // ç»™é™†åœ°æ ‡è®°æ–°æ ‡ç­¾ count++; for (int i = 0; i &lt; 4; i++) &#123; int nextx = x + dir[i][0]; int nexty = y + dir[i][1]; if (nextx &lt; 0 || nextx >= n || nexty &lt; 0 || nexty >= m) continue; dfs(grid, visited, nextx, nexty, mark); &#125; &#125; int main() &#123; cin >> n >> m; vector&lt;vector&lt;int>> grid(n, vector&lt;int>(m, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin >> grid[i][j]; &#125; &#125; vector&lt;vector&lt;bool>> visited(n, vector&lt;bool>(m, false)); // æ ‡è®°è®¿é—®è¿‡çš„ç‚¹ unordered_map&lt;int ,int> gridNum; int mark = 1; // è®°å½•æ¯ä¸ªå²›å±¿çš„ç¼–å· bool isAllGrid = true; // æ ‡è®°æ˜¯å¦æ•´ä¸ªåœ°å›¾éƒ½æ˜¯é™†åœ° for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (grid[i][j] == 0) isAllGrid = false; if (!visited[i][j] &amp;&amp; grid[i][j] == 1) &#123; count = 0; dfs(grid, visited, i, j, mark); gridNum[mark] = count; // è®°å½•æ¯ä¸€ä¸ªå²›å±¿çš„é¢ç§¯ mark++; // è®°å½•ä¸‹ä¸€ä¸ªå²›å±¿ç¼–å· &#125; &#125; &#125; if (isAllGrid) &#123; cout &lt;&lt; n * m &lt;&lt; endl; // å¦‚æœéƒ½æ˜¯é™†åœ°ï¼Œè¿”å›å…¨é¢ç§¯ return 0; &#125; // ä»¥ä¸‹é€»è¾‘æ˜¯æ ¹æ®æ·»åŠ é™†åœ°çš„ä½ç½®ï¼Œè®¡ç®—å‘¨è¾¹å²›å±¿é¢ç§¯ä¹‹å’Œ int result = 0; unordered_set&lt;int> visitedGrid; // æ ‡è®°è®¿é—®è¿‡çš„å²›å±¿ for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; count = 1; // è®°å½•è¿æ¥ä¹‹åçš„å²›å±¿æ•°é‡ visitedGrid.clear(); // æ¯æ¬¡ä½¿ç”¨æ—¶ï¼Œæ¸…ç©º if (grid[i][j] == 0) &#123; for (int k = 0; k &lt; 4; k++) &#123; int neari = i + dir[k][1]; // è®¡ç®—ç›¸é‚»åæ ‡ int nearj = j + dir[k][0]; if (neari &lt; 0 || neari >= n || nearj &lt; 0 || nearj >= m) continue; if (visitedGrid.count(grid[neari][nearj])) continue; // æ·»åŠ è¿‡çš„å²›å±¿ä¸è¦é‡å¤æ·»åŠ  count += gridNum[grid[neari][nearj]]; visitedGrid.insert(grid[neari][nearj]); // æ ‡è®°è¯¥å²›å±¿å·²ç»æ·»åŠ è¿‡ &#125; &#125; result = max(result, count); &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; &#125; Problem 8 å²›å±¿çš„å‘¨é•¿é¢˜ç›®æè¿° ç»™å®šä¸€ä¸ªç”± 1ï¼ˆé™†åœ°ï¼‰å’Œ 0ï¼ˆæ°´ï¼‰ç»„æˆçš„çŸ©é˜µï¼Œå²›å±¿æ˜¯è¢«æ°´åŒ…å›´ï¼Œå¹¶ä¸”é€šè¿‡æ°´å¹³æ–¹å‘æˆ–å‚ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥è€Œæˆçš„ã€‚ ä½ å¯ä»¥å‡è®¾çŸ©é˜µå¤–å‡è¢«æ°´åŒ…å›´ã€‚åœ¨çŸ©é˜µä¸­æ°å¥½æ‹¥æœ‰ä¸€ä¸ªå²›å±¿ï¼Œå‡è®¾ç»„æˆå²›å±¿çš„é™†åœ°è¾¹é•¿éƒ½ä¸º 1ï¼Œè¯·è®¡ç®—å²›å±¿çš„å‘¨é•¿ã€‚å²›å±¿å†…éƒ¨æ²¡æœ‰æ°´åŸŸã€‚ è¾“å…¥æè¿° ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° N, Mï¼Œè¡¨ç¤ºçŸ©é˜µçš„è¡Œæ•°å’Œåˆ—æ•°ã€‚ä¹‹å N è¡Œï¼Œæ¯è¡ŒåŒ…å« M ä¸ªæ•°å­—ï¼Œæ•°å­—ä¸º 1 æˆ–è€… 0ï¼Œè¡¨ç¤ºå²›å±¿çš„å•å…ƒæ ¼ã€‚ è¾“å‡ºæè¿° è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºå²›å±¿çš„å‘¨é•¿ã€‚ /* æœ‰ä¸€å¯¹ç›¸é‚»çš„å²›å±¿å°±ä¼šå°‘2æ¡è¾¹ */ #include &lt;iostream> #include &lt;vector> using namespace std; int main() &#123; int n, m; cin >> n >> m; vector&lt;vector&lt;int>> grid(n, vector&lt;int>(m, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin >> grid[i][j]; &#125; &#125; int sum = 0; // é™†åœ°æ•°é‡ int cover = 0; // ç›¸é‚»æ•°é‡ for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (grid[i][j] == 1) &#123; sum++; // ç»Ÿè®¡æ€»çš„é™†åœ°æ•°é‡ // ç»Ÿè®¡ä¸Šè¾¹ç›¸é‚»é™†åœ° if(i - 1 >= 0 &amp;&amp; grid[i - 1][j] == 1) cover++; // ç»Ÿè®¡å·¦è¾¹ç›¸é‚»é™†åœ° if(j - 1 >= 0 &amp;&amp; grid[i][j - 1] == 1) cover++; // ä¸ºä»€ä¹ˆæ²¡ç»Ÿè®¡ä¸‹è¾¹å’Œå³è¾¹ï¼Ÿ å› ä¸ºé¿å…é‡å¤è®¡ç®— &#125; &#125; &#125; cout &lt;&lt; sum * 4 - cover * 2 &lt;&lt; endl; &#125; Problem 9 å­—ç¬¦ä¸²æ¥é¾™é¢˜ç›®æè¿° å­—å…¸ strList ä¸­ä»å­—ç¬¦ä¸² beginStr å’Œ endStr çš„è½¬æ¢åºåˆ—æ˜¯ä¸€ä¸ªæŒ‰ä¸‹è¿°è§„æ ¼å½¢æˆçš„åºåˆ—ï¼š åºåˆ—ä¸­ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯ beginStrã€‚ åºåˆ—ä¸­æœ€åä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯ endStrã€‚ æ¯æ¬¡è½¬æ¢åªèƒ½æ”¹å˜ä¸€ä¸ªä½ç½®çš„å­—ç¬¦ï¼ˆä¾‹å¦‚ ftr å¯ä»¥è½¬åŒ– fty ï¼Œä½† ftr ä¸èƒ½è½¬åŒ– frxï¼‰ã€‚ è½¬æ¢è¿‡ç¨‹ä¸­çš„ä¸­é—´å­—ç¬¦ä¸²å¿…é¡»æ˜¯å­—å…¸ strList ä¸­çš„å­—ç¬¦ä¸²ã€‚ beginStr å’Œ endStr ä¸åœ¨ å­—å…¸ strList ä¸­ å­—ç¬¦ä¸²ä¸­åªæœ‰å°å†™çš„26ä¸ªå­—æ¯ ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸² beginStr å’Œ endStr å’Œä¸€ä¸ªå­—å…¸ strListï¼Œæ‰¾åˆ°ä» beginStr åˆ° endStr çš„æœ€çŸ­è½¬æ¢åºåˆ—ä¸­çš„å­—ç¬¦ä¸²æ•°ç›®ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è½¬æ¢åºåˆ—ï¼Œè¿”å› 0ã€‚ è¾“å…¥æè¿° ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•° Nï¼Œè¡¨ç¤ºå­—å…¸ strList ä¸­çš„å­—ç¬¦ä¸²æ•°é‡ã€‚ ç¬¬äºŒè¡ŒåŒ…å«ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œç”¨ç©ºæ ¼éš”å¼€ï¼Œåˆ†åˆ«ä»£è¡¨ beginStr å’Œ endStrã€‚ åç»­ N è¡Œï¼Œæ¯è¡Œä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä»£è¡¨ strList ä¸­çš„å­—ç¬¦ä¸²ã€‚ è¾“å‡ºæè¿° è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œä»£è¡¨ä» beginStr è½¬æ¢åˆ° endStr éœ€è¦çš„æœ€çŸ­è½¬æ¢åºåˆ—ä¸­çš„å­—ç¬¦ä¸²æ•°é‡ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è½¬æ¢åºåˆ—ï¼Œåˆ™è¾“å‡º 0ã€‚ /* æ— æƒå›¾ä¸­ï¼Œç”¨å¹¿æœæ±‚æœ€çŸ­è·¯å¾„æœ€ä¸ºåˆé€‚ï¼Œå¹¿æœåªè¦æœåˆ°äº†ç»ˆç‚¹ï¼Œå°±ä¸€å®šæ˜¯æœ€çŸ­è·¯å¾„ */ #include &lt;iostream> #include &lt;vector> #include &lt;queue> #include &lt;string> #include &lt;unordered_map> #include &lt;unordered_set> using namespace std; int main()&#123; string beginstr, endstr, str; int n; cin >> n; cin >> beginstr >> endstr; unordered_set&lt;string> strlist; for (int i = 0; i &lt; n; i++)&#123; cin >> str; strlist.insert(str); &#125; // è®°å½•strseté‡Œé¢çš„å­—ç¬¦ä¸²æ˜¯å¦è¢«è®¿é—®è¿‡ï¼ŒåŒæ—¶è®°å½•è·¯å¾„é•¿åº¦ unordered_map&lt;string, int> visitedmap; // init visitedmap.insert(pair&lt;string, int>(beginstr, 1)); queue&lt;string> que; que.push(beginstr); while (!que.empty())&#123; string word = que.front(); que.pop(); int path = visitedmap[word]; for (int i = 0; i &lt; word.size(); i++)&#123; string newword = word; for (int j = 0; j &lt; 26; j++)&#123; newword[i] = j + 'a'; // å­—ç¬¦ä¸²é›†åˆä¸­æœ‰newword, ä¸”newwordæ²¡æœ‰è¢«è®¿é—®è¿‡ if (strlist.find(newword) != strlist.end() &amp;&amp; visitedmap.find(newword) == visitedmap.end()) &#123; visitedmap.insert(pair&lt;string, int>(newword, path + 1)); que.push(newword); &#125; // æœ€ç»ˆç›®æ ‡ if (newword == endstr)&#123; path += 1; cout &lt;&lt; path &lt;&lt; endl; return 0; &#125; &#125; &#125; &#125; // æ²¡æ‰¾åˆ°è¾“å‡º0 cout &lt;&lt; 0 &lt;&lt; endl; &#125; Problem 10 æœ‰å‘å›¾çš„å®Œå…¨è¿é€šã€é¢˜ç›®æè¿°ã€‘ ç»™å®šä¸€ä¸ªæœ‰å‘å›¾ï¼ŒåŒ…å« N ä¸ªèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹ç¼–å·åˆ†åˆ«ä¸º 1ï¼Œ2ï¼Œâ€¦ï¼ŒNã€‚ç°ä» 1 å·èŠ‚ç‚¹å¼€å§‹ï¼Œå¦‚æœå¯ä»¥ä» 1 å·èŠ‚ç‚¹çš„è¾¹å¯ä»¥åˆ°è¾¾ä»»ä½•èŠ‚ç‚¹ï¼Œåˆ™è¾“å‡º 1ï¼Œå¦åˆ™è¾“å‡º -1ã€‚ ã€è¾“å…¥æè¿°ã€‘ ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•°ï¼Œè¡¨ç¤ºèŠ‚ç‚¹æ•°é‡ N å’Œè¾¹çš„æ•°é‡ Kã€‚ åç»­ K è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ­£æ•´æ•° s å’Œ tï¼Œè¡¨ç¤ºä» s èŠ‚ç‚¹æœ‰ä¸€æ¡è¾¹å•å‘è¿æ¥åˆ° t èŠ‚ç‚¹ã€‚ ã€è¾“å‡ºæè¿°ã€‘ å¦‚æœå¯ä»¥ä» 1 å·èŠ‚ç‚¹çš„è¾¹å¯ä»¥åˆ°è¾¾ä»»ä½•èŠ‚ç‚¹ï¼Œåˆ™è¾“å‡º 1ï¼Œå¦åˆ™è¾“å‡º -1ã€‚ /* ç¨€ç–å›¾ç”¨é‚»æ¥è¡¨åšæ•°æ®ç»“æ„ */ #include &lt;iostream> #include &lt;vector> #include &lt;list> using namespace std; int n, m; void dfs(const vector&lt;list&lt;int>> &amp;grid, vector&lt;bool> &amp;visited, int x)&#123; if (visited[x] == true) return; visited[x] = true; list&lt;int> keys = grid[x]; for (auto &amp;key : keys)&#123; dfs(grid, visited, key); &#125; &#125; int main()&#123; // input é‚»æ¥è¡¨ cin >> n >> m; vector&lt;list&lt;int>> grid(n+1); int x, y; for (int i = 0; i &lt; m; i++)&#123; cin >> x >> y; grid[x].push_back(y); &#125; vector&lt;bool> visited(n+1, false); dfs(grid, visited, 1 ); // check æ˜¯å¦éƒ½è®¿é—®åˆ°äº† for (int i = 1; i &lt;= n; i++) &#123; if (visited[i] == false) &#123; cout &lt;&lt; -1 &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; 1 &lt;&lt; endl; return 0; &#125; Problem 11 å¯»æ‰¾å­˜åœ¨çš„è·¯å¾„é¢˜ç›®æè¿° ç»™å®šä¸€ä¸ªåŒ…å« n ä¸ªèŠ‚ç‚¹çš„æ— å‘å›¾ä¸­ï¼ŒèŠ‚ç‚¹ç¼–å·ä» 1 åˆ° n ï¼ˆå« 1 å’Œ n ï¼‰ã€‚ ä½ çš„ä»»åŠ¡æ˜¯åˆ¤æ–­æ˜¯å¦æœ‰ä¸€æ¡ä»èŠ‚ç‚¹ source å‡ºå‘åˆ°èŠ‚ç‚¹ destination çš„è·¯å¾„å­˜åœ¨ã€‚ è¾“å…¥æè¿° ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•° N å’Œ Mï¼ŒN ä»£è¡¨èŠ‚ç‚¹çš„ä¸ªæ•°ï¼ŒM ä»£è¡¨è¾¹çš„ä¸ªæ•°ã€‚ åç»­ M è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ­£æ•´æ•° s å’Œ tï¼Œä»£è¡¨ä»èŠ‚ç‚¹ s ä¸èŠ‚ç‚¹ t ä¹‹é—´æœ‰ä¸€æ¡è¾¹ã€‚ æœ€åä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•°ï¼Œä»£è¡¨èµ·å§‹èŠ‚ç‚¹ source å’Œç›®æ ‡èŠ‚ç‚¹ destinationã€‚ è¾“å‡ºæè¿° è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œä»£è¡¨æ˜¯å¦å­˜åœ¨ä»èŠ‚ç‚¹ source åˆ°èŠ‚ç‚¹ destination çš„è·¯å¾„ã€‚å¦‚æœå­˜åœ¨ï¼Œè¾“å‡º 1ï¼›å¦åˆ™ï¼Œè¾“å‡º 0ã€‚ #include &lt;iostream> #include &lt;vector> using namespace std; int n; // å¹¶æŸ¥é›†ï¼Œæ¯”é¢˜ç›®é™å®šè¾“å…¥é•¿åº¦å¤§å°±è¡Œ vector&lt;int> father = vector&lt;int>(101, 0); void init(void)&#123; for (int i = 1; i &lt;= n; i++) father[i] = i; &#125; int findfather(int a)&#123; if (a == father[a]) return a; /* father[a] = findfather(father[a]); return father[a]; */ else return father[a] = findfather(father[a]); &#125; bool issame(int a, int b)&#123; a = findfather(a); b = findfather(b); if (a == b) return true; else return false; &#125; void join(int a , int b)&#123; if (issame(a,b)) return; a = findfather(a); b = findfather(b); father[a] = b; &#125; int main()&#123; int m; int source, destination; cin >> n >> m; init(); while (m--)&#123; int x, y; cin >> x >> y; join(x, y); &#125; cin >> source >> destination; if (issame(source, destination) == true) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; 0 &lt;&lt; endl; return 0; &#125; Problem 12 å†—ä½™è¿æ¥æœ‰ä¸€ä¸ªå›¾ï¼Œå®ƒæ˜¯ä¸€æ£µæ ‘ï¼Œä»–æ˜¯æ‹¥æœ‰ n ä¸ªèŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹ç¼–å·1åˆ°nï¼‰å’Œ n - 1 æ¡è¾¹çš„è¿é€šæ— ç¯æ— å‘å›¾ï¼ˆå…¶å®å°±æ˜¯ä¸€ä¸ªçº¿å½¢å›¾ï¼‰ï¼Œå¦‚å›¾ï¼š ç°åœ¨åœ¨è¿™æ£µæ ‘ä¸Šçš„åŸºç¡€ä¸Šï¼Œæ·»åŠ ä¸€æ¡è¾¹ï¼ˆä¾ç„¶æ˜¯nä¸ªèŠ‚ç‚¹ï¼Œä½†æœ‰næ¡è¾¹ï¼‰ï¼Œä½¿è¿™ä¸ªå›¾å˜æˆäº†æœ‰ç¯å›¾ï¼Œå¦‚å›¾ å…ˆè¯·ä½ æ‰¾å‡ºå†—ä½™è¾¹ï¼Œåˆ é™¤åï¼Œä½¿è¯¥å›¾å¯ä»¥é‡æ–°å˜æˆä¸€æ£µæ ‘ã€‚ è¾“å…¥æè¿° ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•° Nï¼Œè¡¨ç¤ºå›¾çš„èŠ‚ç‚¹ä¸ªæ•°å’Œè¾¹çš„ä¸ªæ•°ã€‚ åç»­ N è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° s å’Œ tï¼Œè¡¨ç¤ºå›¾ä¸­ s å’Œ t ä¹‹é—´æœ‰ä¸€æ¡è¾¹ã€‚ è¾“å‡ºæè¿° è¾“å‡ºä¸€æ¡å¯ä»¥åˆ é™¤çš„è¾¹ã€‚å¦‚æœæœ‰å¤šä¸ªç­”æ¡ˆï¼Œè¯·åˆ é™¤æ ‡å‡†è¾“å…¥ä¸­æœ€åå‡ºç°çš„é‚£æ¡è¾¹ã€‚ #include &lt;iostream> #include &lt;vector> using namespace std; int n; // å¹¶æŸ¥é›†ï¼Œæ¯”é¢˜ç›®é™å®šè¾“å…¥é•¿åº¦å¤§å°±è¡Œ vector&lt;int> father = vector&lt;int>(101, 0); void init(void)&#123; for (int i = 1; i &lt;= n; i++) father[i] = i; &#125; int findfather(int a)&#123; if (a == father[a]) return a; /* father[a] = findfather(father[a]); return father[a]; */ else return father[a] = findfather(father[a]); &#125; bool issame(int a, int b)&#123; a = findfather(a); b = findfather(b); if (a == b) return true; else return false; &#125; void join(int a , int b)&#123; if (issame(a,b)) return; a = findfather(a); b = findfather(b); father[a] = b; &#125; int main()&#123; cin >> n; init(); int s, t; while (n --)&#123; cin >> s >> t; if (issame(s, t)) &#123; cout &lt;&lt; s &lt;&lt; \" \" &lt;&lt; t &lt;&lt; endl; return 0; &#125; else &#123; join(s, t); &#125; &#125; &#125; Problem 13 å†—ä½™è¿æ¥â…¡é¢˜ç›®æè¿° æœ‰ä¸€ç§æœ‰å‘æ ‘,è¯¥æ ‘åªæœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œæ‰€æœ‰å…¶ä»–èŠ‚ç‚¹éƒ½æ˜¯è¯¥æ ¹èŠ‚ç‚¹çš„åç»§ã€‚è¯¥æ ‘é™¤äº†æ ¹èŠ‚ç‚¹ä¹‹å¤–çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸”åªæœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œè€Œæ ¹èŠ‚ç‚¹æ²¡æœ‰çˆ¶èŠ‚ç‚¹ã€‚æœ‰å‘æ ‘æ‹¥æœ‰ n ä¸ªèŠ‚ç‚¹å’Œ n - 1 æ¡è¾¹ã€‚å¦‚å›¾ï¼š ç°åœ¨æœ‰ä¸€ä¸ªæœ‰å‘å›¾ï¼Œæœ‰å‘å›¾æ˜¯åœ¨æœ‰å‘æ ‘ä¸­çš„ä¸¤ä¸ªæ²¡æœ‰ç›´æ¥é“¾æ¥çš„èŠ‚ç‚¹ä¸­é—´æ·»åŠ ä¸€æ¡æœ‰å‘è¾¹ã€‚å¦‚å›¾ï¼š è¾“å…¥ä¸€ä¸ªæœ‰å‘å›¾ï¼Œè¯¥å›¾ç”±ä¸€ä¸ªæœ‰ç€ n ä¸ªèŠ‚ç‚¹(èŠ‚ç‚¹ç¼–å· ä» 1 åˆ° n)ï¼Œn æ¡è¾¹ï¼Œè¯·è¿”å›ä¸€æ¡å¯ä»¥åˆ é™¤çš„è¾¹ï¼Œä½¿å¾—åˆ é™¤è¯¥æ¡è¾¹ä¹‹åè¯¥æœ‰å‘å›¾å¯ä»¥è¢«å½“ä½œä¸€é¢—æœ‰å‘æ ‘ã€‚ è¾“å…¥æè¿° ç¬¬ä¸€è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•° Nï¼Œè¡¨ç¤ºæœ‰å‘å›¾ä¸­èŠ‚ç‚¹å’Œè¾¹çš„ä¸ªæ•°ã€‚ åç»­ N è¡Œï¼Œæ¯è¡Œè¾“å…¥ä¸¤ä¸ªæ•´æ•° s å’Œ tï¼Œä»£è¡¨è¿™æ˜¯ s èŠ‚ç‚¹è¿æ¥å¹¶æŒ‡å‘ t èŠ‚ç‚¹çš„å•å‘è¾¹ è¾“å‡ºæè¿° è¾“å‡ºä¸€æ¡å¯ä»¥åˆ é™¤çš„è¾¹ï¼Œè‹¥æœ‰å¤šæ¡è¾¹å¯ä»¥åˆ é™¤ï¼Œè¯·è¾“å‡ºæ ‡å‡†è¾“å…¥ä¸­æœ€åå‡ºç°çš„ä¸€æ¡è¾¹ã€‚ /* é¢˜è§£ï¼Œæœ‰äº›éš¾ */ #include &lt;iostream> #include &lt;vector> using namespace std; int n; vector&lt;int> father (1001, 0); // å¹¶æŸ¥é›†åˆå§‹åŒ– void init() &#123; for (int i = 1; i &lt;= n; ++i) &#123; father[i] = i; &#125; &#125; // å¹¶æŸ¥é›†é‡Œå¯»æ ¹çš„è¿‡ç¨‹ int find(int u) &#123; return u == father[u] ? u : father[u] = find(father[u]); &#125; // å°†v->u è¿™æ¡è¾¹åŠ å…¥å¹¶æŸ¥é›† void join(int u, int v) &#123; u = find(u); v = find(v); if (u == v) return ; father[v] = u; &#125; // åˆ¤æ–­ u å’Œ væ˜¯å¦æ‰¾åˆ°åŒä¸€ä¸ªæ ¹ bool same(int u, int v) &#123; u = find(u); v = find(v); return u == v; &#125; // åœ¨æœ‰å‘å›¾é‡Œæ‰¾åˆ°åˆ é™¤çš„é‚£æ¡è¾¹ï¼Œä½¿å…¶å˜æˆæ ‘ void getRemoveEdge(const vector&lt;vector&lt;int>>&amp; edges) &#123; init(); // åˆå§‹åŒ–å¹¶æŸ¥é›† for (int i = 0; i &lt; n; i++) &#123; // éå†æ‰€æœ‰çš„è¾¹ if (same(edges[i][0], edges[i][1])) &#123; // æ„æˆæœ‰å‘ç¯äº†ï¼Œå°±æ˜¯è¦åˆ é™¤çš„è¾¹ cout &lt;&lt; edges[i][0] &lt;&lt; \" \" &lt;&lt; edges[i][1]; return; &#125; else &#123; join(edges[i][0], edges[i][1]); &#125; &#125; &#125; // åˆ ä¸€æ¡è¾¹ä¹‹ååˆ¤æ–­æ˜¯ä¸æ˜¯æ ‘ bool isTreeAfterRemoveEdge(const vector&lt;vector&lt;int>>&amp; edges, int deleteEdge) &#123; init(); // åˆå§‹åŒ–å¹¶æŸ¥é›† for (int i = 0; i &lt; n; i++) &#123; if (i == deleteEdge) continue; if (same(edges[i][0], edges[i][1])) &#123; // æ„æˆæœ‰å‘ç¯äº†ï¼Œä¸€å®šä¸æ˜¯æ ‘ return false; &#125; join(edges[i][0], edges[i][1]); &#125; return true; &#125; int main() &#123; int s, t; vector&lt;vector&lt;int>> edges; cin >> n; vector&lt;int> inDegree(n + 1, 0); // è®°å½•èŠ‚ç‚¹å…¥åº¦ for (int i = 0; i &lt; n; i++) &#123; cin >> s >> t; inDegree[t]++; edges.push_back(&#123;s, t&#125;); &#125; vector&lt;int> vec; // è®°å½•å…¥åº¦ä¸º2çš„è¾¹ï¼ˆå¦‚æœæœ‰çš„è¯å°±ä¸¤æ¡è¾¹ï¼‰ // æ‰¾å…¥åº¦ä¸º2çš„èŠ‚ç‚¹æ‰€å¯¹åº”çš„è¾¹ï¼Œæ³¨æ„è¦å€’åºï¼Œå› ä¸ºä¼˜å…ˆåˆ é™¤æœ€åå‡ºç°çš„ä¸€æ¡è¾¹ for (int i = n - 1; i >= 0; i--) &#123; if (inDegree[edges[i][1]] == 2) &#123; vec.push_back(i); &#125; &#125; // æƒ…å†µä¸€ã€æƒ…å†µäºŒ if (vec.size() > 0) &#123; // æ”¾åœ¨vecé‡Œçš„è¾¹å·²ç»æŒ‰ç…§å€’å™æ”¾çš„ï¼Œæ‰€ä»¥è¿™é‡Œå°±ä¼˜å…ˆåˆ vec[0]è¿™æ¡è¾¹ if (isTreeAfterRemoveEdge(edges, vec[0])) &#123; cout &lt;&lt; edges[vec[0]][0] &lt;&lt; \" \" &lt;&lt; edges[vec[0]][1]; &#125; else &#123; cout &lt;&lt; edges[vec[1]][0] &lt;&lt; \" \" &lt;&lt; edges[vec[1]][1]; &#125; return 0; &#125; // å¤„ç†æƒ…å†µä¸‰ // æ˜ç¡®æ²¡æœ‰å…¥åº¦ä¸º2çš„æƒ…å†µï¼Œé‚£ä¹ˆä¸€å®šæœ‰æœ‰å‘ç¯ï¼Œæ‰¾åˆ°æ„æˆç¯çš„è¾¹è¿”å›å°±å¯ä»¥äº† getRemoveEdge(edges); &#125; &nbsp; ä»£ç éšæƒ³å½•ä¸€åˆ·ç»“æŸäº†ï¼Œçºªå¿µä¸€ä¸‹ã€‚","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://miustannis.github.io/tags/CS/"}]},{"title":"å†ˆè¨é›·æ–¯ã€Šæ•°å­—å›¾åƒå¤„ç†ã€‹Study Log","slug":"250519","date":"2025-05-19T03:38:44.000Z","updated":"2026-02-20T10:43:38.081Z","comments":true,"path":"2025/05/19/250519/","link":"","permalink":"https://miustannis.github.io/2025/05/19/250519/","excerpt":"","text":"ç›®å½•ï¼š Ch0 æ•°å­—å›¾åƒçš„æ¦‚å¿µ å›¾åƒåˆ†ç±»ï¼šæ¨¡æ‹Ÿå›¾åƒä¸æ•°å­—å›¾åƒ æ•°å­—å›¾åƒå¤„ç†çš„åŸºæœ¬ç‰¹ç‚¹ æ•°å­—å›¾åƒå¤„ç†çš„åŸºæœ¬å†…å®¹ Ch1 å›¾åƒæŠ€æœ¯åŸºç¡€ å›¾åƒä¸åƒç´  æ•°å­—åŒ–è¿‡ç¨‹ åƒç´ çš„å±æ€§ åƒç´ é—´çš„åŸºæœ¬å…³ç³» åƒç´ é—´çš„è·ç¦» å°åˆ·å“ä¸­çš„åŠè°ƒè¾“å‡ºæŠ€æœ¯ å›¾åƒåæ ‡å˜æ¢ å›¾åƒçš„è´¨é‡ å›¾åƒå‚¨å­˜çš„æ•°æ®ç»“æ„ å›¾åƒæ–‡ä»¶æ ¼å¼ *å…‰ç›˜è¯»å–åŸç† Ch2 ç©ºé—´åŸŸå›¾åƒå¢å¼º ç°åº¦æ˜ å°„ å›¾åƒæ±‚åï¼ˆè´Ÿç‰‡ï¼‰ å¹‚æ¬¡å˜æ¢ åŠ¨æ€èŒƒå›´å‹ç¼© é˜¶æ¢¯é‡åŒ– ç°åº¦åˆ‡åˆ†/é˜ˆå€¼åˆ‡åˆ† ä½å¹³é¢åˆ‡ç‰‡ å›¾åƒè¿ç®—ï¼ˆé€åƒç´ è¿›è¡Œï¼‰ ç®—æœ¯è¿ç®—ï¼ˆä¸€èˆ¬ç”¨äºç°åº¦å›¾åƒï¼‰ ä»£æ•°è¿ç®— é€»è¾‘è¿ç®— ç›´æ–¹å›¾å˜æ¢ *ç›´æ–¹å›¾å‡è¡¡åŒ–æ–¹æ³•ï¼š *ç›´æ–¹å›¾è§„å®šåŒ–æ–¹æ³•ï¼š é•œå¤´è¾¹ç•Œçš„æ£€æµ‹ å›¾åƒç©ºé—´å¹³æ»‘æ»¤æ³¢å¢å¼º å›¾åƒä¸­çš„å™ªå£° é‚»åŸŸå¹³å‡çº¿æ€§æ»¤æ³¢ï¼ˆå‡å€¼æ»¤æ³¢ï¼‰ ä¸­å€¼æ»¤æ³¢æ³• ç©ºé—´åŸŸæ»¤æ³¢æ¨å¹¿ åŸºæœ¬ä½é€šæ»¤æ³¢å™¨è®¾è®¡åŸåˆ™ï¼š å¾®åˆ†æ»¤æ³¢å™¨æ¨¡æ¿ç³»æ•°è®¾è®¡ é«˜å¢ç›Šæ»¤æ³¢ Ch3 é¢‘åŸŸå›¾åƒå¢å¼º ç†è®ºåŸºç¡€ äºŒç»´å·ç§¯ äºŒç»´ç¦»æ•£å‚…é‡Œå¶å˜æ¢ åŸºæœ¬æ€§è´¨ DFTçš„é—®é¢˜ é¢‘åŸŸå›¾åƒå¢å¼º ä¸€èˆ¬æ­¥éª¤ é¢‘åŸŸå¹³é¢ä¸å›¾åƒç©ºåŸŸç‰¹æ€§çš„å…³ç³» æ»¤æ³¢å™¨ ç†æƒ³ä½é€šæ»¤æ³¢å™¨çš„å®šä¹‰ ç†æƒ³ä½é€šæ»¤æ³¢å™¨çš„åˆ†æ Butterworthä½é€šæ»¤æ³¢å™¨ ç†æƒ³é«˜é€šæ»¤æ³¢å™¨åŠå…¶åˆ†æ Butterworthé«˜é€šæ»¤æ³¢å™¨ åŒå½¢æ»¤æ³¢å™¨ ç©ºé—´åŸŸæ»¤æ³¢å’Œé¢‘åŸŸæ»¤æ³¢ä¹‹é—´çš„å…³ç³» Ch4 å›¾åƒå¤åŸä¸æ¢å¤ å›¾åƒå¤åŸçš„åŸºæœ¬æ¦‚å¿µ å›¾åƒé€€åŒ– å›¾åƒå¤åŸ å›¾åƒé€€åŒ–æ¨¡å‹ å™ªå£°ä»‹ç» å›¾åƒå¤åŸçš„æ–¹æ³• æ— çº¦æŸè¿˜åŸæ³• åå‘æ»¤æ³¢æ³• ç»´çº³æ»¤æ³¢/æœ€å°å‡æ–¹è¯¯å·®æ»¤æ³¢ æœ‰çº¦æŸè¿˜åŸæ³• æœ€å¤§å¹³æ»‘å¤åŸ è¿åŠ¨æ¨¡ç³Šå›¾åƒçš„å¤åŸ æ ¹æ®å…ˆéªŒçŸ¥è¯†ï¼ˆé€€åŒ–çš„åŸå› ä¸ºå·²çŸ¥ï¼‰ å¤§æ°”æ¹æµé€ æˆçš„ä¼ é€’å‡½æ•° å…‰å­¦ç³»ç»Ÿæ•£ç„¦çš„ä¼ é€’å‡½æ•° åŒ€é€Ÿç›´çº¿è¿åŠ¨æ¨¡ç³Šä¸‹çš„ä¼ é€’å‡½æ•° æ ¹æ®å›¾åƒä¸­çš„ç‚¹æˆ–è€…çº¿ä¼°è®¡(åéªŒçŸ¥è¯†) ç”±åŠŸç‡è°±ä¼°è®¡ä¼ é€’å‡½æ•° å™ªå£°çš„ç¡®å®š å›¾åƒçš„å‡ ä½•æ ¡æ­£ ç©ºé—´å˜æ¢ ç°åº¦æ’å€¼ å›¾åƒå¤åŸçš„åº”ç”¨ å›¾åƒå¤åŸçš„ç©ºé—´æ»¤æ³¢å™¨ï¼ˆåªå­˜åœ¨å™ªå£°ï¼‰ è‡ªé€‚åº”å±€éƒ¨å™ªå£°æ¶ˆé™¤æ»¤æ³¢å™¨ è‡ªé€‚åº”ä¸­å€¼æ»¤æ³¢å™¨ å›¾åƒå¤åŸçš„é¢‘ç‡åŸŸæ»¤æ³¢å™¨ å¸¦é€šæ»¤æ³¢å™¨ å¸¦é˜»æ»¤æ³¢å™¨ é™·æ³¢æ»¤æ³¢å™¨ å°ç»“ Ch5 å½©è‰²å›¾åƒå¤„ç† å½©è‰²ç©ºé—´ å½©è‰²ç©ºé—´çš„è½¬æ¢ï¼ˆRGBä¸å…¶ä»–ï¼‰ ä¼ªå½©è‰²å›¾åƒå¤„ç† å¼ºåº¦åˆ†å±‚æŠ€æœ¯ å…¨å½©è‰²å›¾åƒå¤„ç† å½©è‰²å˜æ¢ å½©è‰²å›¾åƒå¹³æ»‘å’Œå°–é”åŒ– Ch6 å½¢æ€å­¦å›¾åƒå¤„ç† åŸºç¡€çŸ¥è¯† äºŒå€¼å›¾åƒçš„åŸºæœ¬é€»è¾‘è¿ç®— è†¨èƒ€ä¸è…èš€ è†¨èƒ€ï¼š è…èš€ å¼€æ“ä½œå’Œé—­æ“ä½œ å‡»ä¸­æˆ–å‡»ä¸ä¸­å˜æ¢ ä¸€äº›åŸºæœ¬çš„å½¢æ€å­¦ç®—æ³• è¾¹ç•Œæå– åŒºåŸŸå¡«å…… å‡¸å£³ ç»†åŒ– ç²—åŒ– éª¨æ¶ è£å‰ªç­‰ äºŒå€¼å½¢æ€å­¦çš„äº”ä¸ªåŸºæœ¬ç»“æ„å…ƒç´ ï¼ˆBï¼‰ ç°åº¦çº§å½¢æ€å­¦ è†¨èƒ€ &amp; è…èš€ å¼€æ“ä½œä¸é—­æ“ä½œ ç°åº¦çº§å½¢æ€å­¦å¤„ç†çš„ä¸€äº›åº”ç”¨ å½¢æ€å­¦å¹³æ»‘å¤„ç† å½¢æ€å­¦å›¾åƒæ¢¯åº¦ï¼ˆè¾¹ç¼˜å¢å¼ºï¼‰ Top-hatå˜æ¢ ç²’åº¦æµ‹å®š çº¹ç†åˆ†å‰² Ch7 å›¾åƒåˆ†å‰² åŸºç¡€çŸ¥è¯† åˆ†ç±»ï¼š é—´æ–­æ£€æµ‹ ç‚¹æ£€æµ‹ çº¿æ£€æµ‹ è¾¹ç¼˜æ£€æµ‹ æ¢¯åº¦ç®—å­ æ‹‰æ™®æ‹‰æ–¯ç®—å­ è¾¹ç¼˜è¿æ¥ å±€éƒ¨å¤„ç† è½®å»“è·Ÿè¸ªå’Œå›¾æœç´¢ å“ˆå¤«å˜æ¢ é˜ˆå€¼åˆ†å‰² å…¨å±€é˜ˆå€¼ åŸºæœ¬è‡ªé€‚åº”é˜ˆå€¼ é€šè¿‡è¾¹ç•Œç‰¹æ€§é€‰æ‹©é˜ˆå€¼ èšç±»åˆ†å‰² åŒºåŸŸåˆ†å‰² åŒºåŸŸç”Ÿé•¿æ³• åŸºäºåŒºåŸŸç°åº¦å·®ï¼ˆå­—é¢æ„æ€ï¼‰ åŸºäºåŒºåŸŸå†…ç°åº¦åˆ†å¸ƒç»Ÿè®¡æ€§è´¨ åŸºäºåŒºåŸŸå½¢çŠ¶ åˆ†è£‚åˆå¹¶ åŸºäºå½¢æ€å­¦åˆ†æ°´å²­çš„åˆ†å‰² &nbsp; &nbsp; Ch0 æ•°å­—å›¾åƒçš„æ¦‚å¿µè§‚å¯Ÿç³»ç»Ÿä½¿ç”¨çš„å…‰æ³¢æ®µï¼šå¯è§å…‰ã€çº¢å¤–ã€å°„çº¿ã€å¾®æ³¢ã€è¶…å£°æ³¢ç­‰ è§†è§‰åœ¨äººç±»è·å–ä¿¡æ¯æ¥æºä¸­å 70% å›¾ï¼šåå°„å…‰æˆ–è€…é€å°„å…‰çš„åˆ†å¸ƒï¼Œæˆ–ç‰©ä½“è‡ªèº«å‘å‡ºçš„èƒ½é‡â€”å®¢è§‚ åƒï¼šäººçš„è§†è§‰ç³»ç»Ÿå¯¹å›¾çš„æ¥æ”¶åœ¨å¤§è„‘ä¸­å½¢æˆçš„å°è±¡æˆ–è®¤è¯†â€”ä¸»è§‚ å›¾åƒå¤„ç†ï¼šæ˜¯å¯¹å›¾åƒä¿¡æ¯è¿›è¡ŒåŠ å·¥å¤„ç†ï¼Œä»¥æ»¡è¶³äººçš„è§†è§‰å¿ƒç†å’Œå®é™…åº”ç”¨çš„éœ€æ±‚ã€‚åŒ…æ‹¬å…‰å­¦å’Œç”µå­å­¦ä¸¤ç§æ–¹æ³• å›¾åƒåˆ†ç±»ï¼šæ¨¡æ‹Ÿå›¾åƒä¸æ•°å­—å›¾åƒ æ¨¡æ‹Ÿå›¾åƒï¼šç†è®ºä¸Šä¸å­˜åœ¨ï¼Œå³ä½¿é«˜å¯†åº¦èƒ¶ç‰‡æˆåƒä¹Ÿæ— æ³•ç§°ä¸ºæ¨¡æ‹Ÿå›¾åƒï¼Œä¸ªäººè®¤ä¸ºå¯å°†äººçœ¼è·å¾—çš„åƒè¿‘ä¼¼ä¸ºæ¨¡æ‹Ÿå›¾åƒ æ•°å­—å›¾åƒï¼š ç”±è¿ç»­çš„æ¨¡æ‹Ÿå›¾åƒé€šè¿‡é‡‡æ ·å’Œé‡åŒ–å¾—åˆ°ã€‚æ•°å­—å›¾åƒçš„åŸºæœ¬å•ä½æ˜¯åƒç´ ï¼Œæ‰€ä»¥æ•°å­—å›¾åƒæ˜¯åƒç´ çš„é›†åˆ æ•°å­—å›¾åƒæ˜¯ä»¥åƒç´ ä¸ºå…ƒç´ çš„çŸ©é˜µï¼Œåƒç´ çš„å€¼ä»£è¡¨å›¾åƒåœ¨è¯¥ä½ç½®çš„äº®åº¦/è‰²åº¦ï¼Œç§°ä¸ºå›¾åƒçš„ç°åº¦å€¼/è‰²åº¦å€¼ æ•°å­—å›¾åƒåƒç´ å…·æœ‰æ•´æ•°åæ ‡ä¸æ•´æ•°ç°åº¦å€¼ æ•°å­—å›¾åƒå¤„ç†çš„åŸºæœ¬ç‰¹ç‚¹ ä¿¡æ¯é‡å¤§ å ç”¨é¢‘å¸¦å®½ï¼šç”µè§†å›¾åƒçš„å¸¦å®½ä¸º5~6MHzï¼ˆç»†èŠ‚è¶Šå¤šï¼Œç”»è´¨è¶Šé«˜å¸¦å®½è¶Šå¤§ï¼Œä¸è¿‡ç°ä»£æ•°å­—ç¼–ç æŠ€æœ¯å¯ä»¥é€šè¿‡å‹ç¼©æ–¹æ³•ï¼Œæ¯”å¦‚MPEG-4ã€H.265ç­‰æ–¹å¼å¤§å¹…å‡å°‘å¸¦å®½éœ€æ±‚ï¼‰ï¼Œè¯­éŸ³çš„å¸¦å®½åªæœ‰4kHzï¼Œé¢‘å¸¦è¶Šå®½ï¼ŒæŠ€æœ¯å®ç°éš¾åº¦å°±è¶Šå¤§ æ•°å­—å›¾åƒå¤„ç†çš„åŸºæœ¬å†…å®¹ï¼ˆéƒ¨åˆ†å†…å®¹ä¸å›¾å½¢å­¦äº’ä¸ºé€†è¿‡ç¨‹ï¼‰ å¢å¼ºï¼šæ”¹å–„è´¨é‡ å‡ ä½•å¤„ç†ï¼šå¹³ç§»ã€ç¼©æ”¾ã€æ—‹è½¬ã€æ‰­æ›² å¤åŸé‡å»ºï¼šå»å™ªã€å»æ¨¡ç³Šã€é‡å»ºåŸå§‹å›¾åƒ ç¼–ç å‹ç¼©ï¼šå‡å°‘å­˜å‚¨é‡å’Œä¼ è¾“é‡ åˆ†å‰²ï¼šåŒºåŸŸåˆ†å‰²å’Œç†è§£ã€ç›®æ ‡è¡¨è¾¾å’Œæè¿° ç†è§£ï¼šå›¾åƒæ„ŸçŸ¥ã€è§£é‡Šã€æ¨ç† åº”ç”¨åœºæ™¯ï¼šå½±è§†å›¾åƒå¤„ç†ã€åŒ»å­¦å½±åƒå¤„ç†ã€åˆ‘ä¾¦è¾…åŠ© &nbsp; &nbsp; Ch1 å›¾åƒæŠ€æœ¯åŸºç¡€å›¾åƒä¸åƒç´ å›¾åƒâ€”äºŒç»´å‡½æ•°f(x,y)ï¼Œå…¶ä¸­x,yæ˜¯ç©ºé—´åæ ‡ã€ç©ºé—´ä¸Šçš„ç¦»æ•£åŒ–ï¼Œå³é‡‡æ ·ã€‘ï¼Œf(x,y)æ˜¯è¯¥ç‚¹çš„å¹…å€¼ã€å³é‡åŒ–ã€‘ å›¾åƒç±»åˆ« ç‰¹å¾ é»‘ç™½å›¾åƒ äºŒå€¼ ç°åº¦å›¾åƒ å•åˆ†é‡ï¼Œf(x,y)è¡¨ç¤ºäº®åº¦ å½©è‰²å›¾åƒ å¤šåˆ†é‡ï¼Œç”±3ä¸ªæˆ–å¤šä¸ªäºŒç»´ç°åº¦å‡½æ•°f(x,y)ç»„æˆï¼ˆå¦‚RGB,HSVï¼‰ æ•°å­—åŒ–è¿‡ç¨‹ æ‰«æï¼šå¯¹ä¸€å¹…å›¾åƒå†…ç»™å®šä½ç½®è¿›è¡Œå¯»å€ï¼Œå°†å›¾åƒåˆ†å‰²ä¸ºçŸ©å½¢ç½‘ç»œï¼Œå³æ …æ ¼åŒ–ï¼Œæ‰«æçš„æœ€å°å•å…ƒä¸ºåƒç´  é‡‡æ ·ï¼šåœ¨ä¸€å¹…å›¾åƒçš„æ¯ä¸ªåƒç´ ä½ç½®ä¸Šæµ‹é‡ç°åº¦å€¼ï¼Œç”±ä¼ æ„Ÿå…ƒä»¶å°†å…‰çš„äº®åº¦è½¬åŒ–ä¸ºç”µå‹å€¼ é‡åŒ–ï¼šå°†æµ‹é‡çš„ç°åº¦å€¼ç”¨æ•´æ•°æ¥è¡¨ç¤ºï¼ˆADCï¼‰ ${f}_{i j}=\\left[\\begin{array}{cccc} f_{00} & f_{01} & \\cdots & f_{0*(N-1)} \\\\ f_{10} & f_{11} & \\cdots & f_{1*(N-1))} \\\\ \\vdots & \\vdots & \\cdots & \\vdots \\\\ f_{(N-1)*0} & f_{(N-1)*1} & \\cdots & f_{(N-1)*(N-1)} \\end{array}\\right] \\approx f(x, y)$ åƒç´ çš„å±æ€§ å¤§å°ï¼šä¸ç©ºé—´åˆ†è¾¨ç‡æœ‰å…³ï¼Œé•¿é‡‡æ ·é—´éš”äº§ç”Ÿä½çš„ç©ºé—´åˆ†è¾¨ç‡ ç°åº¦ï¼šä¸ç°åº¦åˆ†è¾¨ç‡æœ‰å…³ ä½æ·±åº¦ï¼šç”¨æ¥å­˜æ”¾åƒç´ é¢œè‰²å€¼æ‰€ç”¨çš„ä½æ•°ï¼š1/4/8/24ï¼ˆçœŸå½©ï¼‰ ç°åº¦çº§ï¼šå¯¹åº”ä½æ·±åº¦ï¼Œè¡¨ç¤ºåƒç´ æ˜æš—ç¨‹åº¦çš„æ•´æ•°é‡ï¼Œä¸º$2^n$ åƒç´ é—´çš„åŸºæœ¬å…³ç³» neighbor é‚»åŸŸï¼š4-é‚»åŸŸï¼›D-é‚»åŸŸï¼›8-é‚»åŸŸ adjacency è¿æ¥æ€§ â€‹ ä¸¤ä¸ªåƒç´ è¿æ¥çš„ä¸¤ä¸ªå¿…è¦æ¡ä»¶ï¼š ä¸¤ä¸ªåƒç´ çš„ä½ç½®é‚»æ¥ï¼ˆæŒ‰ä¸Šè¿°neighborç§ç±»å¯åˆ’åˆ†ä¸º 4-è¿æ¥ã€8-è¿æ¥ï¼Œä»¥åŠm-è¿æ¥ï¼‰ ä¸¤ä¸ªåƒç´ çš„ç°åº¦å€¼æ»¡è¶³ç‰¹å®šçš„ç›¸ä¼¼æ€§å‡†åˆ™ï¼ˆå€¼è¦åœ¨æŸä¸€èŒƒå›´å†…è¿‘ä¼¼ç›¸ç­‰ï¼‰ ç‰¹æ®Šæƒ…å†µï¼š*m-è¿æ¥ï¼ŒåŒ…æ‹¬ä¸¤ç§æƒ…å†µï¼ˆè§†è§‰ä¸Šçœ‹ä¸å…è®¸æœ‰ä¸‰è§’é˜¶æ¢¯å½¢çš„è¿æ¥å›¾æ¡ˆï¼‰ 4-è¿æ¥ åƒç´ Aâˆˆåƒç´ Bçš„D-é‚»åŸŸï¼Œä¸”ä¸¤ä¸ªåƒç´ çš„4-é‚»åŸŸä¸åŒ…å«åŒæ ·å€¼çš„åƒç´  è·ç¦»ï¼ˆåƒç´ Aåˆ°åƒç´ Bçš„è·¯å¾„ï¼Œæ˜¯ä¸åŒåƒç´ çš„åºåˆ—ï¼‰å¯ç”¨å®šä¹‰è¿æ¥çš„æ–¹æ³•å®šä¹‰è·¯å¾„ï¼Œå…¶ä¸­m-è¿æ¥æ‰€å¾—çš„m-è·¯å¾„æ›´é€‚ç”¨äºè¾¹ç¼˜æå–ã€‚ connection åƒç´ åœ¨å›¾åƒå­é›†ä¸­è¿é€š ä¸¤ä¸ªåƒç´ åœ¨å›¾åƒä¸­èƒ½æœ‰ä¸€æ¡å®Œå…¨ç”±åƒç´ ç»„æˆçš„è·¯å¾„ï¼Œåˆ™ä¸¤ä¸ªåƒç´ è¿é€šï¼Œè¿æ¥æ˜¯è¿é€šçš„ä¸€ç§ç‰¹æ®Šæƒ…å†µ connected component è¿é€šæˆåˆ† å¯¹äºå›¾åƒä¸­çš„ä»»æ„åƒç´ Aï¼Œå›¾åƒä¸­æ‰€æœ‰è¿æ¥åˆ°Açš„åƒç´ çš„é›†åˆè¢«ç§°ä¸ºå›¾åƒçš„è¿é€šæˆåˆ†ï¼ŒåŒæ ·å¯æŒ‰è¿æ¥æ–¹å¼åˆ’åˆ† åƒç´ é—´çš„è·ç¦» æ¬§å‡ é‡Œå¾—è·ç¦» pä¸qä¹‹é—´çš„æ¬§å‡ é‡Œå¾—è·ç¦»å®šä¹‰ä¸ºï¼š $De(p,q) = [(x-s)^2 + (y-t)^2]^{(1/2)}$ å¯¹äºå›¾åƒæ¥è¯´è®¡ç®—é‡å¤ªå¤§ï¼Œä¸€èˆ¬ä¸ç”¨ã€‚ D4è·ç¦»/è¡—åŒºè·ç¦»/åŸå¸‚è·ç¦» $D4(p,q) = |x-s| + |y-t|$ åŒºåˆ«äºæ¬§å‡ é‡Œå¾—è·ç¦»ï¼ˆåˆ°æŸåƒç´ è·ç¦»ç­‰äºæŸä¸ªå€¼çš„åƒç´ å½¢æˆä¸€ä¸ªåœ†å½¢ï¼‰ï¼Œåˆ°æŸåƒç´ D4è·ç¦»å°äºç­‰äºæŸä¸ªå€¼çš„åƒç´ å½¢æˆä¸€ä¸ªè±å½¢ D8è·ç¦»/æ£‹ç›˜è·ç¦»ï¼šç”¨äºè¾¹ç¼˜æå–æ—¶è®¾ç½®è·ç¦»çš„é˜ˆå€¼ $D8(p,q) =max(|x-s| , |y-t|) $ å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š å°åˆ·å“ä¸­çš„åŠè°ƒè¾“å‡ºæŠ€æœ¯ èŠ‚é€‰è‡ªç»´åŸºç™¾ç§‘ï¼šåŠè‰²è°ƒï¼ˆHalftoneï¼‰æ˜¯æŒ‡ä¸ºäº†æ¨¡æ‹Ÿå‡ºè¿ç»­è°ƒå½±åƒï¼ˆè‰²é˜¶ï¼‰çš„è§†è§‰æ„Ÿè§‰ï¼Œä¸€èˆ¬ç”¨å¢¨ç‚¹ï¼ˆåŠè‰²è°ƒç½‘ç‚¹ï¼‰çš„å¤§å°æˆ–é¢‘ç‡çš„æ”¹å˜ï¼Œæ¥æ¨¡æ‹Ÿæ˜æš—çš„å˜åŒ–ã€‚åŠè‰²è°ƒæŠ€æœ¯æ˜¯ä¼ ç»Ÿå°åˆ·ä¸­ç”¨æ¥å¤„ç†é˜¶è°ƒå¹¶æ¨¡æ‹Ÿè¿ç»­è°ƒï¼ˆcontinue toneï¼‰çš„æ–¹æ³•ï¼Œé€šå¸¸ä¹Ÿç§°ä¸ºè¿‡ç½‘ï¼ˆscreeningï¼‰æŠ€æœ¯ã€‚åŠè‰²è°ƒæ˜¯ç›¸å¯¹äºè¿ç»­è°ƒè¡¨ç¤ºé˜¶è°ƒçš„ä¸€ç§æ–¹æ³•ï¼Œä¸€èˆ¬æˆ‘ä»¬æ‰€çœ‹åˆ°é“¶ç›ç›¸ç‰‡ä¸Šçš„å½±åƒæ˜¯ç”±è¿ç»­çš„å±‚æ¬¡æ‰€æ„æˆï¼Œåƒè¿™æ ·çš„å½±åƒç§°ä¹‹ä¸ºè¿ç»­è°ƒå½±åƒã€‚ç›¸å¯¹è€Œè¨€ï¼Œå°åˆ·æœºæˆ–æ‰“å°æœºä¸Šæ‰€æ‰“å°çš„å›¾åƒï¼Œåªèƒ½å€Ÿç”±ç€å¢¨æˆ–ä¸ç€å¢¨ä¸¤ç§é˜¶è°ƒæ¥è¡¨ç°å±‚æ¬¡ï¼Œåƒè¿™æ ·çš„ä¸¤å€¼åŒ–å½±åƒç§°ä¸ºåŠè‰²è°ƒå½±åƒã€‚åªè¦å€Ÿç”±è°ƒæ•´ä¸åŒå½¢å¼ã€ä¸åŒå¤§å°çš„å¢¨ç‚¹ï¼Œåˆ©ç”¨äººçœ¼å¯ä»¥å°†å›¾åƒä¸­é‚»è¿‘å¢¨ç‚¹è¿›è¡Œè§†è§‰ç§¯åˆ†çš„åŸç†ï¼Œåœ¨ä¸€å®šçš„è·ç¦»è§‚å¯Ÿä¸‹ï¼Œä¾¿å¯ä»¥ä½¿äºŒå€¼åŒ–å½±åƒé‡ç°è¿ç»­è°ƒçš„æ„Ÿè§‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“è¿™äº›å¢¨ç‚¹è¶Šå°æ—¶ï¼ŒäºŒå€¼åŒ–å½±åƒå°±å¯ä»¥åœ¨è¶ŠçŸ­çš„è§‚æµ‹è·ç¦»ä¸‹ï¼Œè¢«äººçœ¼è§‚æµ‹ç§¯åˆ†æˆè¿‘ä¼¼è¿ç»­è°ƒçš„å½±åƒã€‚ å›¾åƒåæ ‡å˜æ¢å¯å€ŸåŠ©çŸ©é˜µå†™ä¸º $\\boldsymbol{v}^{\\prime}=\\boldsymbol{A} \\boldsymbol{v}$ å…¶ä¸­Aä¸ºå˜æ¢çŸ©é˜µï¼Œvâ€˜ä¸ºå˜æ¢åçš„åæ ‡çŸ¢é‡ï¼Œvä¸ºå˜æ¢å‰çš„åæ ‡çŸ¢é‡ å¹³ç§»å˜æ¢ $\\boldsymbol{T}=\\left[\\begin{array}{ccc} 1 & 0 & x_{0} \\\\ 0 & 1 & y_{0} \\\\ 0 & 0 & 1 \\end{array}\\right]$ å°ºåº¦å˜æ¢ $\\boldsymbol{S}=\\left[\\begin{array}{ccc} S_{x} & 0 & 0 \\\\ 0 & S_{y} & 0 \\\\ 0 & 0 & 1 \\end{array}\\right]$ æ—‹è½¬å˜æ¢ $\\boldsymbol{R}=\\left[\\begin{array}{ccc} \\cos \\gamma & \\sin \\gamma & 0 \\\\ -\\sin \\gamma & \\cos \\gamma & 0 \\\\ 0 & 0 & 1 \\end{array}\\right]$ å›¾åƒçš„è´¨é‡æ¸…æ™°åº¦ï¼šäº®åº¦ï¼Œå¯¹æ¯”åº¦ï¼Œä¸»é¢˜å†…å®¹çš„å¤§å°ï¼Œç»†å¾®å±‚æ¬¡ï¼Œé¢œè‰²é¥±å’Œåº¦ å¯¹æ¯”åº¦ = æœ€å¤§äº®åº¦ / æœ€å°äº®åº¦ å›¾åƒå‚¨å­˜çš„æ•°æ®ç»“æ„ ä¸€ç»´æ•°ç»„ï¼Œè¡Œåˆ—å‚¨å­˜ å¤šæ³¢æ®µå‚¨å­˜ å›¾åƒæ–‡ä»¶æ ¼å¼BMP, GIF, TIFF, JPEGç­‰ &nbsp; &nbsp; *å…‰ç›˜è¯»å–åŸç†æ— è®ºæ˜¯CDå…‰ç›˜è¿˜æ˜¯DVDå…‰ç›˜ï¼Œå…¶å­˜å‚¨æ–¹å¼ä¸ç£ç›˜ä¸€æ ·ï¼Œéƒ½æ˜¯ä»¥äºŒè¿›åˆ¶æ•°æ®çš„å½¢å¼æ¥å­˜å‚¨ä¿¡æ¯ã€‚è¦åœ¨è¿™äº›å…‰ç›˜ä¸Šå­˜å‚¨æ•°æ®ï¼Œéœ€è¦å€ŸåŠ©æ¿€å…‰æŠŠäºŒè¿›åˆ¶æ•°æ®åˆ»åœ¨æ‰å¹³ã€å…·æœ‰åå°„èƒ½åŠ›çš„ç›˜ç‰‡ä¸Šã€‚ä¸ºäº†è¯†åˆ«æ•°æ®ï¼Œå®šä¹‰æ¿€å…‰åˆ»å‡ºçš„å°å‘å°±ä»£è¡¨äºŒè¿›åˆ¶çš„â€œ1â€ï¼Œè€Œç©ºç™½å¤„åˆ™ä»£è¡¨äºŒè¿›åˆ¶çš„â€œ0â€ã€‚ï¼ˆå‡¹å‘å’Œå¹³å¦åŒºåŸŸçš„ è¾¹ç¼˜å˜åŒ–ã€å¦‚ä»å‡¹å‘åˆ°å¹³å¦ï¼Œæˆ–åä¹‹ã€‘ä»£è¡¨â€1â€ï¼Œæ— å˜åŒ–ä»£è¡¨â€0â€ï¼‰DVDçš„è®°å½•å‡¹å‘æ¯”CDå°ï¼Œä¸”èºæ—‹å­˜å‚¨å‡¹å‘ä¹‹é—´çš„è·ç¦»ä¹Ÿæ›´å°ã€‚ CDå…‰é©±æˆ–DVDå…‰é©±çš„ä¸»è¦éƒ¨åˆ†å°±æ˜¯æ¿€å…‰å‘ç”Ÿå™¨å’Œå…‰ç›‘æµ‹å™¨ã€‚æ¿€å…‰å‘ç”Ÿå™¨ï¼ˆæ¿€å…‰äºŒæç®¡ï¼‰ï¼Œå¯ä»¥äº§ç”Ÿå¯¹åº”æ³¢é•¿çš„æ¿€å…‰å…‰æŸï¼Œç„¶åç»è¿‡ä¸€ç³»åˆ—çš„å¤„ç†åç…§åˆ°å…‰ç›˜ä¸Šã€‚ç»ç”±å…‰ç›‘æµ‹å™¨æ•æ‰åå°„ä¿¡å·è€Œè¯†åˆ«å®é™…çš„æ•°æ®ã€‚ç„¶åè®¡ç®—æœºå°†è¿™äº›äºŒè¿›åˆ¶ä»£ç è½¬æ¢æˆä¸ºåŸæ¥çš„æ•°æ®æˆ–ç¨‹åºã€‚å½“å…‰ç›˜åœ¨å…‰é©±ä¸­ä½œé«˜é€Ÿæ—‹è½¬ï¼Œæ¿€å…‰å¤´åœ¨ç”µæœºçš„æ§åˆ¶ä¸‹ä½œå¾„å‘ç§»åŠ¨ï¼Œæ•°æ®å°±è¿™æ ·æºæºä¸æ–­åœ°è¯»å–å‡ºæ¥ã€‚ æ ¹æ®æ•°æ®å¯†åº¦çš„å·®åˆ«å¯åˆ†ä¸ºCD, DVD, BDç­‰ã€‚ å…‰ç›˜ä¸æœºæ¢°ç¡¬ç›˜çš„å·¥ä½œåŸç†åŒºåˆ«å¯è§ä»¥ä¸‹åšå®¢ï¼š https://zhuanlan.zhihu.com/p/51572176 &nbsp; &nbsp; &nbsp; Ch2 ç©ºé—´åŸŸå›¾åƒå¢å¼ºå®šä¹‰ï¼šç›´æ¥ä½œç”¨äºåƒç´ çš„å¢å¼ºæ–¹æ³•ï¼Œæ ¹æ®å…·ä½“æ“ä½œæ˜¯åœ¨åƒç´ ç‚¹ä½ç½®ä¸Šè¿˜æ˜¯åƒç´ ç‚¹çš„é‚»åŸŸä¸Šå¯åˆ†ä¸ºç‚¹æ“ä½œå’Œæ¨¡æ¿æ“ä½œï¼ˆé‚»åŸŸæ“ä½œï¼‰ ç°åº¦æ˜ å°„é€šè¿‡æ˜ å°„å‡½æ•°:$ t= T(s)$ï¼ˆå¯æ ¹æ®å¢å¼ºçš„ç›®çš„æ¥è®¾è®¡æ˜ å°„å‡½æ•°ï¼‰å°†åŸå§‹å›¾åƒä¸­çš„æ¯ä¸ªåƒç´ çš„ç°åº¦éƒ½æ˜ å°„åˆ°æ–°çš„ç°åº¦ã€‚ å›¾åƒæ±‚åï¼ˆè´Ÿç‰‡ï¼‰ä¸€ä¸€å¯¹åº” å¹‚æ¬¡å˜æ¢$t= cs^{Î³}$ $Î³&lt;1$æ—¶åœ¨æ­£æ¯”å‡½æ•°ä¸Šæ–¹ï¼Œä½¿å¾—å›¾åƒå˜äº®ï¼ŒæŠŠè¾“å…¥çª„å¸¦æš—å€¼æ˜ å°„åˆ°å®½å¸¦è¾“å‡ºï¼› $Î³&gt;1$æ—¶åœ¨æ­£æ¯”å‡½æ•°ä¸‹æ–¹ï¼Œä½¿å¾—å›¾åƒå˜æš—ï¼ŒæŠŠè¾“å…¥çª„å¸¦äº®å€¼æ˜ å°„åˆ°å®½å¸¦è¾“å‡ºã€‚ åŠ¨æ€èŒƒå›´å‹ç¼©ç”±äºæŸäº›è®¾å¤‡çš„å±€é™æ€§ï¼Œé‡‡ç”¨åŠ¨æ€èŒƒå›´å‹ç¼©ï¼Œç›®æ ‡ä¸å¢å¼ºå›¾ç‰‡çš„å¯¹æ¯”åº¦ç›¸åï¼ˆåŒç­‰èŒƒå›´çš„åŸå§‹ç°åº¦çº§æ•°å˜æ¢åèŒƒå›´å˜åŒ–å‡å°ï¼‰ é˜¶æ¢¯é‡åŒ–å°†å›¾åƒç°åº¦åˆ†èŒƒå›´é‡åŒ–ï¼Œå˜æˆæ•°æ®é‡è¾ƒå°‘çš„çº§æ•°ï¼Œè·å¾—æ•°æ®é‡å‹ç¼©çš„æ•ˆæœï¼ˆæœ‰ç‚¹åƒç´ åŒ–é£æ ¼ï¼‰ ç°åº¦åˆ‡åˆ†/é˜ˆå€¼åˆ‡åˆ†åªç•™ä¸‹ä¸¤ä¸ªç°åº¦å€¼ï¼Œè·å¾—æœ€å¤§çš„å¯¹æ¯”åº¦ä»¥åŠæœ€å°‘çš„ç»†èŠ‚ *åˆ†æ®µå˜æ¢ï¼š ä½å¹³é¢åˆ‡ç‰‡ä»¥256ç°åº¦çº§å›¾åƒä¸ºä¾‹ï¼Œè¯¥å›¾åƒçš„ç°åº¦çº§å¯ä»¥ç”¨8ä½è¡¨ç¤ºã€‚å¯å‡è®¾å›¾åƒæ˜¯ç”±8ä¸ª1ä½å¹³é¢ç»„æˆï¼Œå³ä½å¹³é¢0~7ï¼Œå…¶ä¸­ä½å¹³é¢0åŒ…å«å›¾åƒä¸­åƒç´ çš„æœ€ä½ä½ï¼Œä½å¹³é¢7åŒ…å«åƒç´ çš„æœ€é«˜ä½ã€‚ è¾ƒé«˜ä½(å‰4ä½)åŒ…å«å¤§å¤šæ•°è§†è§‰é‡è¦æ•°æ®ã€‚è¾ƒä½ä½(å4ä½)åŒ…å«å¯¹å¾®å°ç»†èŠ‚é‡è¦çš„æ•°æ®ï¼Œä½å¹³é¢åˆ‡ç‰‡å¯ä»¥åˆ†ææ¯ä¸€ä½åœ¨å›¾åƒä¸­çš„ç›¸å¯¹é‡è¦æ€§ã€‚ &nbsp; å›¾åƒè¿ç®—ï¼ˆé€åƒç´ è¿›è¡Œï¼‰ç®—æœ¯è¿ç®—ï¼ˆä¸€èˆ¬ç”¨äºç°åº¦å›¾åƒï¼‰ä»£æ•°è¿ç®—åŠ æ³•ï¼š$C(x,y) = A(x,y) + B(x,y)$ åº”ç”¨åœºæ™¯ï¼š1. å»é™¤å åŠ æ€§å™ªå£°ï¼ˆå›¾åƒå‡å€¼åŒ–å°†é™ä½å™ªå£°çš„å½±å“ï¼‰2. ç”Ÿæˆå›¾åƒå åŠ æ•ˆæœ å‡æ³•ï¼š$C(x,y) = A(x,y) - B(x,y)$ åº”ç”¨åœºæ™¯ï¼š1. æ˜¾ç¤ºä¸¤å¹…å›¾ä¹‹é—´çš„å·®å¼‚ï¼Œå¦‚è§†é¢‘ä¸­çš„é•œå¤´è¾¹ç•Œçš„æ£€æµ‹ 2. å»é™¤ä¸éœ€è¦çš„å åŠ æ€§å›¾æ¡ˆï¼ˆgb\\bbå‰ªè¾‘ï¼‰ 3. å›¾åƒåˆ†å‰² ä¹˜æ³•ï¼š$C(x,y) = A(x,y) * B(x,y)$ åº”ç”¨åœºæ™¯ï¼šå±€éƒ¨æ˜¾ç¤ºâ€”â€”ç”¨äºŒå€¼è’™ç‰ˆå›¾åƒä¸åŸå›¾åƒåšä¹˜æ³• é€»è¾‘è¿ç®—ä¸ã€æˆ–ã€å¼‚æˆ–ã€é éƒ¨åˆ†è¿ç®—æ–¹æ³•ä¸åŠ å‡æ³•æœ‰ç±»ä¼¼çš„åœ°æ–¹ éï¼š$g(x,y) = 255 - f(x,y)$ å¯è·å¾—ä¸€ä¸ªè´Ÿç‰‡å›¾åƒï¼ˆè¡¥å›¾åƒï¼‰ *è´Ÿç‰‡ï¼š ç°åº¦å›¾åƒå…¬å¼å¦‚ä¸Šï¼›RGBå›¾åƒéœ€è¦åˆ†åˆ«è¿›è¡Œéè¿ç®—ï¼›éçº¿æ€§è‰²åŸŸéœ€è¦å…ˆè¿›è¡Œçº¿æ€§æ ¡æ­£åå†å¯¹ä¸åŒé€šé“åˆ†åˆ«æ ¡æ­£ ä¸ï¼š$g(x,y) = h(x,y) âˆ§ f(x,y)$ ï¼›æˆ–ï¼š$g(x,y) = h(x,y) ï¼¶ f(x,y)$ å¯ä»¥æå–ç›¸äº¤å­å›¾æˆ–åˆå¹¶å­å›¾åƒ &nbsp; ç›´æ–¹å›¾å˜æ¢ç°åº¦ç›´æ–¹å›¾æ˜¯å…³äºç°åº¦çº§çš„ç¦»æ•£å‡½æ•°ï¼Œæè¿°å›¾åƒä¸­å„ç°åº¦çº§çš„åƒç´ ä¸ªæ•°ï¼Œä¸€èˆ¬å½’ä¸€åŒ–åæè¿° ç›´æ–¹å›¾åªèƒ½åæ˜ å›¾åƒçš„ç°åº¦åˆ†å¸ƒæƒ…å†µï¼Œä¸èƒ½åæ˜ å›¾åƒåƒç´ çš„ä½ç½® ä¸€å¹…å›¾å¯¹åº”å”¯ä¸€çš„ç°åº¦ç›´æ–¹å›¾ *é«˜å¯¹æ¯”åº¦çš„å›¾åƒæœ‰æ›´å¹³å¦çš„ç›´æ–¹å›¾ï¼Œå¯¹äºå›¾åƒåˆ†å‰²ï¼Œè¯†åˆ«é¢†åŸŸï¼Œä¸€å¹…å›¾åƒåº”è¯¥åˆ©ç”¨å…¨éƒ¨æˆ–è€…å‡ ä¹å…¨éƒ¨å¯èƒ½çš„ç°åº¦çº§ åº”ç”¨ï¼š åˆ©ç”¨ç›´æ–¹å›¾åˆ†å¸ƒè¿›è¡Œé˜ˆå€¼åˆ†å‰²ï¼Œå¦‚æœæŸç°åº¦å›¾åƒçš„ç°åº¦ç›´æ–¹å›¾æœ‰ä¸¤ä¸ªæ˜æ˜¾çš„å°–å³°ï¼Œå–ä¸¤ä¸ªå°–å³°ä¹‹é—´çš„è°·ç‚¹ä½œä¸ºåˆ†å‰²ç‚¹ï¼Œå¯ä»¥å¾—åˆ°è¾ƒå¥½çš„äºŒå€¼å¤„ç†çš„æ•ˆæœ ç›´æ–¹å›¾å‡è¡¡åŒ–ï¼Œé€šè¿‡å°†åƒç´ ä¸ªæ•°å¤šçš„ç°åº¦çº§è¿›è¡Œå±•å®½ï¼Œå¯¹åƒç´ ä¸ªæ•°å°‘çš„ç°åº¦çº§è¿›è¡Œç¼©å‡ï¼Œå°†åŸå§‹å›¾åƒçš„ç›´æ–¹å›¾å˜ä¸ºå‡è¡¡åˆ†å¸ƒçš„å½¢å¼ï¼Œç”±äºå„ç°åº¦ä¹‹é—´æœ‰å‡åŒ€çš„æ¦‚ç‡åˆ†å¸ƒï¼Œå›¾åƒçœ‹èµ·æ¥å¯ä»¥æ›´æ¸…æ™° *ç›´æ–¹å›¾å‡è¡¡åŒ–æ–¹æ³•ï¼š ä¸ºä½¿å¾—å›¾åƒçš„ç›´æ–¹å›¾å‡è¡¡åŒ–ï¼ŒåŒæ—¶ä¿æŒç°åº¦å€¼çš„å•è°ƒæ€§å’ŒèŒƒå›´ä¸å˜ï¼Œæ„é€ çš„ç°åº¦å˜æ¢å‡½æ•°$ t= T(s)$éœ€è¦æ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶ï¼š $T(s)$æ˜¯å•è°ƒé€’å¢å‡½æ•°ï¼Œä¸”$0â‰¤T(s)â‰¤1$ï¼šä¿è¯å˜æ¢åçš„ç°åº¦å€¼ä¿æŒä»é»‘åˆ°ç™½çš„å˜æ¢é¡ºåºï¼Œé¿å…ç°åº¦å€¼åè½¬ï¼Œä¿è¯å˜æ¢åçš„ç°åº¦å€¼åœ¨0~1çš„èŒƒå›´å†…ï¼ˆå½’ä¸€åŒ–åï¼‰ åŸå§‹å›¾åƒçš„ç´¯ç§¯åˆ†å¸ƒå‡½æ•°(CDFï¼Œå³æ¦‚ç‡å¯†åº¦æ›²çº¿åŒ…å›´çš„é¢ç§¯)å¯æ»¡è¶³ä»¥ä¸Šæ¡ä»¶ $t = T(s) = \\int_{0}^{s}p(w)dw, p(w)æ˜¯æ¦‚ç‡å€¼$ $T^{-1}(s)$å­˜åœ¨ä¸”å•è°ƒé€’å¢ï¼Œå…è®¸å‡è¡¡åŒ–åçš„ç°åº¦å€¼tåå‘æ˜ å°„å›åŸå§‹ç°åº¦å€¼ï¼Œåå‡½æ•°å•è°ƒé€’å¢å¯ä»¥ä¿è¯åå‘æ˜ å°„æ—¶ä»ç„¶ä¿æŒç°åº¦é¡ºåºä¸å˜ï¼Œé¿å…å¼•å…¥æ–°çš„éçº¿æ€§å¤±çœŸ $T(s)$æ˜¯CDFï¼Œå…¶åå‡½æ•°å¯ä»¥é€šè¿‡æŸ¥æ‰¾æˆ–è€…æ•°å€¼æ–¹å¼æ±‚å¾— å› ä¸ºæ•°å­—å›¾åƒå¤„ç†æ˜¯ç¦»æ•£åŒ–çš„ï¼Œå› æ­¤éœ€è¦å¯¹ä¸Šè¿°æ–¹æ³•ç¦»æ•£åŒ–ï¼š è®¾ä¸€å¹…å›¾åƒçš„åƒç´ æ€»æ•°ä¸ºnï¼Œåˆ†Lä¸ªç°åº¦çº§ï¼Œå…¶ä¸­ç¬¬kä¸ªç°åº¦çº§å‡ºç°çš„æ¦‚ç‡ä¸º$p(s_{k}) = n_{k}/n$ï¼Œå…¶ä¸­$0â‰¤s_kâ‰¤1,k = 0,1,2,â€¦L-1$. å˜æ¢å‡½æ•°ï¼Œå³ç¦»æ•£CDFä¸º$T(s_k) = \\sum_{j=0}^{k} p(s_{k}) = \\sum_{j=0}^{k} n_j/n$ ç®—æ³•æ­¥éª¤ï¼š è®¡ç®—æ¯ä¸ªç°åº¦çº§çš„åƒç´ ä¸ªæ•°åœ¨æ•´ä¸ªå›¾åƒä¸­æ‰€å çš„æ¦‚ç‡ è®¡ç®—æ¯ä¸ªç°åº¦çº§çš„ç¦»æ•£CDF æ ¹æ®å˜æ¢åçš„$t_{k}$çš„å€¼åˆ¤æ–­å˜æ¢åçš„ç°åº¦çº§ï¼ˆåŒºé—´æ‹Ÿåˆï¼Œæ¯”å¦‚round()ï¼‰ æ‹Ÿåˆåä¼šåˆå¹¶éƒ¨åˆ†ç°åº¦çº§ï¼Œå®è§‚ä¸Šå¯¹ç°åº¦çº§åˆ†å¸ƒå‡è¡¡åŒ–ï¼Œå¾®è§‚ä¸Šä¸å¯èƒ½æ‹‰å¹³ï¼Œç°åº¦çº§å±‚æ¬¡å‡å°‘ï¼Œå¯¹æ¯”åº¦æé«˜ è¿™ç§æ–¹æ³•ä½¿å¾—åŸæœ¬é›†ä¸­åœ¨ç‹­çª„åŒºé—´çš„åƒç´ å€¼å˜æ¢åˆ°æ›´å¹¿çš„èŒƒå›´å†…ï¼Œå¢åŠ äº†åƒç´ ç°åº¦å€¼çš„æœ‰æ•ˆåŠ¨æ€èŒƒå›´ ä¼˜ç‚¹ï¼šè‡ªåŠ¨å¾—åˆ°è¿‘ä¼¼å‡åŒ€åˆ†å¸ƒçš„ç›´æ–¹å›¾ï¼Œä½†ç”±äºå˜æ¢å‡½æ•°é‡‡ç”¨CDFï¼Œåªèƒ½è¿‘ä¼¼ï¼Œå› æ­¤åœ¨ä¸€äº›æœ‰ç‰¹å®šéœ€æ±‚çš„åœºæ™¯ä¸‹é‡‡ç”¨ç›´æ–¹å›¾è§„å®šåŒ–æ–¹æ³• &nbsp; *ç›´æ–¹å›¾è§„å®šåŒ–æ–¹æ³•ï¼šå°†åŸå§‹ç›´æ–¹å›¾è½¬æ¢ä¸ºæœŸæœ›ç›´æ–¹å›¾ ç®—æ³•æ­¥éª¤ï¼š å¯¹åŸå§‹å›¾åƒè¿›è¡Œç°åº¦å‡è¡¡åŒ–ï¼ˆæŒ‰ç…§ä¸Šè¿°ç›´æ–¹å›¾å‡è¡¡åŒ–æ–¹æ³•ï¼‰ è®¡ç®—ç›®æ ‡ç›´æ–¹å›¾çš„ç¦»æ•£CDF å°†åŸå§‹ç›´æ–¹å›¾æ˜ å°„åˆ°ç›®æ ‡ç›´æ–¹å›¾ æ˜ å°„è§„åˆ™ï¼š å•æ˜ å°„è§„åˆ™ï¼ˆç°åº¦çº§ä¸€ä¸€å¯¹åº”ï¼‰ &amp; ç»„æ˜ å°„è§„åˆ™ï¼ˆç°åº¦çº§åˆ†ç»„åå¹³å‡åå¯¹åº”ï¼Œæ•ˆæœå¥½ï¼‰ &nbsp; é•œå¤´è¾¹ç•Œçš„æ£€æµ‹å®šä¹‰ï¼šä¸€ä¸ªé•œå¤´æŒ‡ä¸€ç³»åˆ—è¿ç»­è®°å½•çš„å›¾åƒå¸§ï¼Œç”¨äºè¡¨ç¤ºä¸€ä¸ªæ—¶é—´æ®µæˆ–è€…ç›¸åŒåœ°ç‚¹è¿ç»­çš„åŠ¨ä½œ é•œå¤´è¾¹ç•Œçš„æ£€æµ‹å³æ£€æµ‹ç”±é•œå¤´åˆ‡æ¢è€Œäº§ç”Ÿçš„å…³é”®å¸§ æ–¹æ³•ï¼š ä¸¤å¹…å›¾å›¾åƒç›¸å‡ï¼ˆæ£€æµ‹åƒç´ å˜åŒ–çš„æ•°ç›®æ˜¯å¦è¶…è¿‡é˜ˆå€¼ï¼‰å¯é€šè¿‡æ»¤æ³¢é™ä½å¯¹æ‘„åƒæœºè¿åŠ¨æ•æ„Ÿçš„é—®é¢˜å½±å“ è¿ç»­å¸§çš„ç›´æ–¹å›¾ç›¸å‡ï¼ˆç»Ÿè®¡ç›¸é‚»ä¸¤å¸§ä¸­æ‰€æœ‰åƒç´ åœ¨ä¸åŒç°åº¦ä¸Šçš„åˆ†å¸ƒå·®å¼‚ä¹‹å’Œæ˜¯å¦è¶…è¿‡é˜ˆå€¼ï¼‰å¯¹ç›®æ ‡çš„ç©ºé—´å˜åŒ–ä¸æ•æ„Ÿ æ—¶ç©ºåˆ‡ç‰‡åˆ†æï¼ˆé¢œè‰²å’Œçº¹ç†çš„ä¸è¿ç»­ï¼‰ &nbsp; å›¾åƒç©ºé—´å¹³æ»‘æ»¤æ³¢å¢å¼ºå›¾åƒä¸­çš„å™ªå£°å¼•èµ·åŸå› ï¼šæ•æ„Ÿå…ƒå™¨ä»¶çš„å†…éƒ¨å™ªå£°ï¼Œä¼ è¾“é€šé“çš„å¹²æ‰°ä»¥åŠé‡åŒ–å™ªå£° å™ªå£°åˆ†ç±»ï¼š åŠ æ€§å™ªå£°ï¼šä¸å›¾åƒä¿¡å·æ— å…³ã€‚ä¿¡é“å™ªå£°ã€æ‰«ææ—¶äº§ç”Ÿçš„å™ªå£° ä¹˜æ€§å™ªå£°ï¼šæŸåƒç´ å¤„çš„å™ªå£°åªä¸è¯¥åƒç´ å¤„çš„å›¾åƒä¿¡å·æœ‰å…³ï¼ˆæˆ–è€…ä¸å…¶é‚»åŸŸä¿¡å·ä¹Ÿæœ‰å…³ï¼‰ æ ¹æ®å™ªå£°çš„åˆ†å¸ƒç‰¹æ€§å¯ä»¥åˆ†ä¸ºï¼šæ¤’ç›å™ªå£°ï¼ˆæ³Šæ¾å™ªå£°ï¼‰ã€é«˜æ–¯å™ªå£°ã€é¢—ç²’å™ªå£°ç­‰ é‚»åŸŸå¹³å‡çº¿æ€§æ»¤æ³¢ï¼ˆå‡å€¼æ»¤æ³¢ï¼‰ æ€æƒ³ï¼šå°†ä¸€ä¸ªåƒç´ åŠå…¶é‚»åŸŸå†…çš„æ‰€æœ‰åƒç´ çš„å¹³å‡ç°åº¦å€¼èµ‹ç»™å¹³æ»‘å›¾åƒä¸­å¯¹åº”çš„åƒç´ ï¼Œä»è€Œè¾¾åˆ°å¹³æ»‘çš„ç›®çš„ å¸¸ç”¨çš„é‚»åŸŸæœ‰4-é‚»åŸŸå’Œ8-é‚»åŸŸ ä½œç”¨ï¼šå‡å™ªï¼Œå»é™¤ä¸ç›¸å¹²çš„ç»†èŠ‚ï¼Œå¯¹ç°åº¦çº§ä¸è¶³å¼•èµ·çš„ä¼ªè½®å»“è¿›è¡Œå¹³æ»‘ exampleï¼šéåŠ æƒ3*3é‚»åŸŸå‡å€¼æ»¤æ³¢å™¨æ¨¡æ¿ $H_{0}=\\frac{1}{9}\\left[\\begin{array}{ccc} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{array}\\right]$ åŠ æƒ3*3å‡å€¼æ»¤æ³¢å™¨æ¨¡æ¿ $H_{0}=\\frac{1}{10}\\left[\\begin{array}{ccc} 1 & 1 & 1 \\\\ 1 & 2 & 1 \\\\ 1 & 1 & 1 \\end{array}\\right]$ ä¸­å¿ƒåƒç´ ä¸ºå¾…å¤„ç†åƒç´  é‚£ä¹ˆå¯çŸ¥é“ï¼Œå½“åƒç´ å¤„äºå›¾åƒè¾¹ç¼˜æ—¶ï¼Œè¿™ä¸ªæ»¤æ³¢å™¨æœ‰ä¸€éƒ¨åˆ†æ˜¯æ²¡æœ‰å€¼å¯¹åº”çš„ï¼Œæ­¤æ—¶æœ‰ä¸¤ç§æ–¹æ³•è¿›è¡Œè¡¥å……ï¼š é•œåƒåå°„ è¡¥0 é‚»åŸŸå¹³å‡æ³•ç®—æ³•æ­¥éª¤ï¼š ç¡®å®šmaskå¤§å° å¯¹å¾…å¤„ç†çš„å›¾åƒè¾¹ç¼˜è¿›è¡Œæ‰©å…… å°†maskåœ¨å›¾åƒä¸­æ¸¸èµ°ï¼Œè®¡ç®—å¹³å‡ ç”¨å‡å€¼ä»£æ›¿ä¸­å¿ƒåƒç´ å€¼ *æ¨¡æ¿è¶Šå¤§ï¼Œå¯¹å›¾åƒçš„æ¨¡ç³Šä½œç”¨å°±è¶Šå¼ºï¼Œä½†ä¹Ÿå¯ä»¥åœ¨æå–è¾ƒå¤§ç›®æ ‡ä¹‹å‰å…ˆå»é™¤å¤ªå°çš„ç»†èŠ‚æˆ–å™ªå£° *åŠ æƒé‚»åŸŸå¹³å‡å¯ä»¥ä¸€å®šç¨‹åº¦ä¸Šç¼“è§£éåŠ æƒæ»¤æ³¢å¯¼è‡´çš„è¾¹ç¼˜æ¨¡ç³Šçš„é—®é¢˜ï¼Œå…¶ä¸­å¿ƒå…ƒç´ å çš„æ¯”ä¾‹è¶Šå°ï¼Œè¶Šå¹³æ»‘ï¼Œå›¾åƒè¶Šæ¨¡ç³Š &nbsp; ä¸­å€¼æ»¤æ³¢æ³•è™½ç„¶é‚»åŸŸå¹³å‡æ³•å¯ä»¥å¹³æ»‘å›¾åƒï¼Œä½†åœ¨æ¶ˆé™¤å™ªå£°çš„åŒæ—¶ï¼Œä¼šä½¿å¾—å›¾åƒä¸­çš„ä¸€äº›ç»†èŠ‚å˜å¾—æ¨¡ç³Šã€‚ä¸­å€¼æ»¤æ³¢åˆ™åœ¨æ¶ˆé™¤å™ªå£°çš„åŒæ—¶è¿˜èƒ½ä¿æŒå›¾åƒä¸­çš„ç»†èŠ‚éƒ¨åˆ†ã€‚ æ€æƒ³ï¼šå¯¹æ¨¡æ¿å†…çš„åƒç´ è¿›è¡Œå¤§å°é¡ºåºæ’åˆ—ï¼Œå¦‚æ­¤æœ€äº®çš„å’Œæœ€æš—çš„ç‚¹ä¼šæ’åœ¨ä¸¤ä¾§ï¼Œç”¨ä¸­é—´ä½ç½®åƒç´ å€¼ä»£æ›¿åŸç°åº¦å€¼ ä½œç”¨ï¼šæ¶ˆé™¤å™ªå£°ï¼Œä¿ç•™å›¾åƒç»†èŠ‚ï¼Œé˜²æ­¢è¾¹ç¼˜æ¨¡ç³Šã€‚å¯¹è„‰å†²å™ªå£°å’Œæ¤’ç›å™ªå£°çš„æŠ‘åˆ¶æ•ˆæœå¥½ ä¸­å€¼æ»¤æ³¢ç®—æ³•æ­¥éª¤ï¼š ç¡®å®šmaskå¤§å°ä¸å½¢çŠ¶ å¯¹å¾…å¤„ç†çš„å›¾åƒè¾¹ç¼˜è¿›è¡Œæ‰©å…… å°†maskåœ¨å›¾åƒä¸­æ¸¸èµ°ï¼Œå¯¹æ¨¡æ¿å†…åƒç´ å€¼è¿›è¡Œæ’åº ç”¨ä¸­é—´å€¼ä»£æ›¿ä¸­å¿ƒåƒç´ å€¼ maskå½¢çŠ¶ä¸€èˆ¬æœ‰æ–¹å½¢ä¸åå­—å½¢ æ³¨ï¼š æœ‰å°–é¡¶è§’å‡ ä½•ç»“æ„çš„å›¾åƒï¼Œä¸€èˆ¬é‡‡ç”¨åå­—çª—ï¼Œå¤§å°ä¸è¶…è¿‡æœ€å°æœ‰æ•ˆç‰©ä½“çš„å°ºå¯¸ æœ‰è¾ƒå¤šçš„ç‚¹ã€çº¿ç»†èŠ‚çš„ç»“æ„ï¼Œä¸€èˆ¬ä¸ç”¨ä¸­å€¼æ»¤æ³¢ ç”±ä¸­å€¼æ»¤æ³¢æ¨å¹¿åˆ°ç»Ÿè®¡æ’åºæ»¤æ³¢å™¨ï¼šæœ€å¤§å€¼æ»¤æ³¢å™¨ï¼ˆå¯»æ‰¾æœ€äº®ç‚¹ï¼‰&amp; æœ€å°å€¼æ»¤æ³¢å™¨ï¼ˆå¯»æ‰¾æœ€æš—ç‚¹ï¼‰ &nbsp; ç©ºé—´åŸŸæ»¤æ³¢æ¨å¹¿ é’åŒ–æ»¤æ³¢å™¨-å¹³æ»‘æ»¤æ³¢å™¨ï¼šä½é€šæ»¤æ³¢ &amp; ä¸­å€¼æ»¤æ³¢ é”åŒ–æ»¤æ³¢å™¨ï¼šé«˜é€šæ»¤æ³¢ &amp; å¾®åˆ†æ»¤æ³¢ &amp; é«˜å¢ç›Šæ»¤æ³¢ åŸºæœ¬ä½é€šæ»¤æ³¢å™¨è®¾è®¡åŸåˆ™ï¼šå¦‚åŒé‚»åŸŸå¹³å‡æ³•ï¼Œæ¨¡æ¿ç³»æ•°éœ€å¤§äº0ï¼Œéƒ½é€‰1æˆ–è€…ä¸­é—´é€‰1ï¼Œå‘¨å›´é€‰0.5 å›¾åƒé”åŒ–ï¼š è¡¥å¿å›¾åƒçš„è½®å»“ï¼Œçªå‡ºå›¾åƒä¸­ç‰©ä½“çš„è¾¹ç¼˜æˆ–ç»†èŠ‚ï¼Œä½¿å¾—å›¾åƒæ›´ä¸ºæ¸…æ™° æ€æƒ³ï¼šå›¾åƒæ¨¡ç³Šçš„åŸå› â€”â€”å›¾åƒè¢«å¹³å‡æˆ–ç§¯åˆ†ï¼Œå› æ­¤ä¸ºå®ç°å›¾åƒçš„é”åŒ–ï¼Œéœ€è¦è¿›è¡Œåè¿ç®—â€œå¾®åˆ†â€â€”â€”&gt;ä»¥æ­¤å¢å¼ºé«˜é¢‘åˆ†é‡ï¼Œä½¿å›¾åƒè¾¹ç¼˜å˜å¾—æ¸…æ™°ï¼Œä½†åŒæ—¶ä¹Ÿå¢å¼ºäº†å™ªå£° æ¡ä»¶ï¼šåŸå§‹å›¾åƒä¿¡å™ªæ¯”è´¨é‡è¦é«˜ è¾¹ç¼˜æ£€æµ‹åŸç†ï¼šå›¾åƒä¸­ç‰©ä½“è¾¹ç¼˜æ˜¯ç°åº¦å€¼å‘ç”Ÿçªå˜çš„åœ°æ–¹ï¼Œå¸¸ç”¨å·®åˆ†æˆ–è€…æ¢¯åº¦è®¡ç®—æ¥æ£€æµ‹è¾¹ç¼˜ åŸºæœ¬é«˜é€šæ»¤æ³¢è®¾è®¡åŸåˆ™ï¼š 1)ç³»æ•°ä¸­å¿ƒä¸ºæ­£å€¼ï¼Œå¤–å‘¨ä¸ºè´Ÿå€¼ 2)æ»¤æ³¢å™¨å„ç³»æ•°ä¹‹å’Œä¸º0 æ³¨ï¼š è®¡ç®—æ—¶ä¼šå‡ºç°è´Ÿå€¼ï¼Œå¸¸ç”¨å½’0å¤„ç† åƒç´ å€¼ç›¸åŒæˆ–è€…å˜åŒ–å¹³ç¼“çš„åŒºåŸŸï¼Œç»“æœä¸º0æˆ–è€…å¾ˆå°ï¼Œå›¾åƒäº®åº¦é™ä½ å¾®åˆ†æ»¤æ³¢å™¨ å¼•å…¥å¾®åˆ†ç®—å­çš„æ¦‚å¿µ å·²çŸ¥ï¼šä¸€é˜¶åå¯¼æ•°æ²¡æœ‰å„å‘åŒæ€§ $\\frac{\\partial f}{\\partial x} â‰  \\frac{\\partial f}{\\partial y}$ è€Œæ•°å­¦ä¸Šå¯ä»¥è¯æ˜ï¼šåå¯¼æ•°çš„å¹³æ–¹å’Œæ˜¯å„å‘åŒæ€§çš„ï¼Œå› æ­¤æ¢¯åº¦è¿ç®—ã€æ‹‰æ™®æ‹‰æ–¯è¿ç®—éƒ½ç¬¦åˆä¸æ–¹å‘æ— å…³æ€§ã€‚å³ï¼šæ— è®ºè¾¹ç•Œæ˜¯ä»€ä¹ˆèµ°å‘ï¼Œåªè¦å¹…åº¦ç›¸åŒï¼Œç®—å­çš„è¾“å‡ºå°±ç›¸åŒã€‚ æ¢¯åº¦æ³•ï¼š $G[f(x,y)] = [\\frac{\\partial f}{\\partial x} \\frac{\\partial f}{\\partial y}]^{T}$ æ¢¯åº¦çš„æ–¹å‘æ˜¯$f(x,y)$å˜åŒ–ç‡æœ€å¤§çš„æ–¹å‘ æ¢¯åº¦çš„åå¯¼æ•°å¯ä»¥ç”¨è¯¥å¤„åå¯¼æ•°çš„å¹³æ–¹å’Œå¼€æ ¹å·è¡¨ç¤ºã€‚ å¯¹äºæ•°å­—å›¾åƒï¼Œæ˜¾ç„¶æ˜¯è¦ç”¨å·®åˆ†æ¥ä»£æ›¿å¾®åˆ†çš„ åŒæ—¶ç”¨ç»å¯¹å€¼æ¥è¿‘ä¼¼å¹³æ–¹å’Œçš„è¡¨è¾¾ å¦‚ä¸Šå›¾æ‰€ç¤ºä¸¤ç§æ–¹æ³•ï¼Œç¬¬ä¸€ç§æ˜¯ç”¨4-é‚»åŸŸè¿›è¡Œè¿‘ä¼¼ï¼Œç¬¬äºŒç§æ˜¯äº¤å‰å·®(Robertsæ¢¯åº¦æ³•) å¾®åˆ†æ»¤æ³¢å™¨æ¨¡æ¿ç³»æ•°è®¾è®¡ Robertsäº¤å‰æ¢¯åº¦ç®—å­ $H_{0}=\\left[\\begin{array}{ccc} 1 & 0 \\\\ 0 & -1 \\end{array}\\right], H_{1}=\\left[\\begin{array}{ccc} 0 & 1 \\\\ -1 & 0 \\end{array}\\right]$ Prewittæ¢¯åº¦ç®—å­ $H_{0}=\\left[\\begin{array}{ccc} -1 & -1 & -1 \\\\ 0 & 0 & 0 \\\\ 1 & 1 & 1 \\end{array}\\right], H_{1}=\\left[\\begin{array}{ccc} -1 & 0 & 1 \\\\ -1 & 0 & 1 \\\\ -1 & 0 & 1 \\end{array}\\right]$ Sobelæ¢¯åº¦ç®—å­ï¼šæœ‰ä¸€å®šçš„å¹³æ»‘ä½œç”¨ $H_{0}=\\left[\\begin{array}{ccc} -1 & -2 & -1 \\\\ 0 & 0 & 0 \\\\ 1 & 2 & 1 \\end{array}\\right], H_{1}=\\left[\\begin{array}{ccc} -1 & 0 & 1 \\\\ -2 & 0 & 2 \\\\ -1 & 0 & 1 \\end{array}\\right]$ Scharræ¢¯åº¦ç®—å­ï¼šæ›´åŠ ç²¾ç¡® $H_{0}=\\left[\\begin{array}{ccc} -3 & -10 & -3 \\\\ 0 & 0 & 0 \\\\ 3 & 10 & 3 \\end{array}\\right], H_{1}=\\left[\\begin{array}{ccc} -3 & 0 & 3 \\\\ -10 & 0 & 10 \\\\ -3 & 0 & 3 \\end{array}\\right]$ æ‰€æœ‰é”åŒ–ç®—å­çš„ç³»æ•°ä¹‹å’Œä¸º0 æ‹‰æ™®æ‹‰æ–¯ç®—å­ï¼šæ±‚äºŒé˜¶å¾®åˆ†ï¼Œé€‚ç”¨äºæ”¹å–„å› ä¸ºå…‰çº¿çš„æ¼«åå°„é€ æˆçš„å›¾åƒæ¨¡ç³Š åº”ç”¨ ç»è¿‡æ¢¯åº¦ç®—å­è®¡ç®—åçš„å€¼ï¼š è‹¥æ¢¯åº¦å¤§äº25ï¼Œåˆ™ç»™åŸåƒç´ èµ‹æœ€å¤§å€¼255ï¼Œå¦åˆ™èµ‹åŸå€¼â€”â€”è¾¹å¢å¼ºä¸”èƒŒæ™¯ä¿ç•™ è‹¥æ¢¯åº¦å¤§äº25ï¼Œåˆ™ç»™åŸåƒç´ èµ‹æœ€å¤§å€¼255ï¼Œå¦åˆ™èµ‹0â€”â€”è¾¹å¢å¼ºä¸”å›¾åƒäºŒå€¼åŒ– &nbsp; é«˜å¢ç›Šæ»¤æ³¢æ€æƒ³ï¼šå¼¥è¡¥é«˜é€šæ»¤æ³¢çš„ç¼ºé™·ï¼Œåœ¨å¢å¼ºè¾¹ç¼˜å’Œç»†èŠ‚çš„åŒæ—¶ï¼Œä¸ä¸¢å¤±åŸå›¾åƒçš„ä½é¢‘æˆåˆ†ï¼Œå³å¢åŠ ä¸€éƒ¨åˆ†åŸå›¾åƒåˆ°é«˜é€šä¹‹ä¸­ï¼Œç®—å­å¯åœ¨é«˜é€šåŸºç¡€ä¸Šå¢ç›Š é«˜é€š = åŸå›¾ - ä½é€š é«˜å¢ç›Š = AåŸå›¾ - ä½é€š &nbsp; &nbsp; &nbsp; Ch3 é¢‘åŸŸå›¾åƒå¢å¼ºç†è®ºåŸºç¡€ç©ºé—´åŸŸå›¾åƒå˜æ¢åˆ°é¢‘åŸŸçš„å…·ä½“å®ç°â€”â€”å›¾åƒç¦»æ•£å‚…é‡Œå¶å˜æ¢ä¸åå˜æ¢ é¢‘åŸŸå›¾åƒçš„è¡¨è¾¾ç‰¹ç‚¹â€”â€”ç»è¿‡ä¸­å¿ƒå˜æ¢åï¼Œä½é¢‘ä½äºä¸­å¿ƒï¼Œé«˜é¢‘åœ¨å¤– ç©ºé—´é¢‘ç‡çš„å®šä¹‰ï¼šå›¾åƒç°åº¦å€¼éšç©ºé—´åæ ‡å˜åŒ–çš„å¿«æ…¢ä¹Ÿå¯ä»¥ç”¨é¢‘ç‡æ¥åº¦é‡ï¼Œç§°ä¸ºç©ºé—´é¢‘ç‡ äºŒç»´å·ç§¯å¯¹äºäºŒç»´å¹³é¢å‡½æ•°ï¼ŒäºŒç»´å·ç§¯å®šä¹‰ï¼š $ h(x, y)=f^{*} g=\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} f(u, v) g(x-u, y-v) d u d v $ *æ³¨ï¼š æ·±åº¦å­¦ä¹ ä¸­ï¼ŒCNNä¸­çš„å·ç§¯å…¶å®æ˜¯â€œäº’ç›¸å…³è¿ç®—â€ï¼Œå³kernelä¸ç¿»è½¬ï¼Œä¸ä¸Šé¢çš„äºŒç»´å·ç§¯å®šä¹‰æ— æ³•å®Œå…¨å¯¹åº”ã€‚ åœ¨æ•°å­—å›¾åƒä¸­ï¼Œéœ€è¦ç¦»æ•£åŒ–ï¼Œç¦»æ•£äºŒç»´å·ç§¯ï¼š $ h(x, y)=f^{*} g=\\sum_{m} \\sum_{n} f(m, n) g(x-m, y-n) $ äºŒç»´ç¦»æ•£å‚…é‡Œå¶å˜æ¢\\begin{array}{l}F(u, v)=\\frac{1}{M N} \\sum_{x=0}^{M-1} \\sum_{y=0}^{N-1} f(x, y) \\mathrm{e}^{[-\\mathrm{j} 2 \\pi(u x / M+v y / N)]} \\\\f(x, y)=\\sum_{u=0}^{M-1} \\sum_{v=0}^{N-1} F(u, v) \\mathrm{e}^{[\\mathrm{j} 2 \\pi(u x / M+v y / N)]}\\end{array} Mï¼ŒNè¡¨ç¤ºå›¾åƒåœ¨xï¼Œyæ–¹å‘ä¸Šçš„å¤§å° åŸºæœ¬æ€§è´¨ å¯åˆ†ç¦»æ€§ï¼šå¯ä»¥å°†äºŒç»´DFTè½¬æ¢æˆä¸€ç»´è®¡ç®—ï¼Œå…ˆåšä¸€ä¸ªæ–¹å‘ä¸Šçš„ï¼š \\begin{aligned}F(u, v) &amp; =\\frac{1}{N^{2}} \\sum_{x=0}^{N-1} \\mathrm{e}^{-\\mathrm{j} 2 \\pi u x / N} \\bullet \\sum_{y=0}^{N-1} f(x, y) \\mathrm{e}^{-\\mathrm{j} 2 \\pi v y / N} \\\\f(x, y) &amp; =\\sum_{u=0}^{N-1} \\mathrm{e}^{-\\mathrm{j} 2 \\pi u x / N} \\bullet \\sum_{v=0}^{N-1} F(u, v) \\mathrm{e}^{-\\mathrm{j} 2 \\pi v y / N}\\end{aligned} å†åšç¬¬äºŒä¸ªæ–¹å‘ä¸Šçš„ï¼š \\begin{array}{l}F(u, v)=F_{x}\\left\\{F_{y}[f(x, y)]\\right\\}=F_{y}\\left\\{F_{x}[f(x, y)]\\right\\} \\\\f(x, y)=F_{u}^{-1}\\left\\{F_{v}^{-1}[F(u, v)]\\right\\}=F_{v}^{-1}\\left\\{F_{u}^{-1}[F(u, v)]\\right\\} \\\\F(u, v)=\\frac{1}{N} \\sum_{x=0}^{N-1} F(x, v) \\mathrm{e}^{-\\mathrm{j} 2 \\pi u x / N} \\\\\\text { å…¶ä¸­: } F(x, v)=N\\left[\\frac{1}{N} \\sum_{y=0}^{N-1} f(x, y) \\mathrm{e}^{-\\mathrm{j} 2 \\pi v x / N}\\right]\\end{array} å¹³ç§»æ€§â€”â€”&gt;å›¾åƒä¸­å¿ƒåŒ– \\begin{aligned}f(x, y) e^{j 2 \\pi\\left(\\frac{u_{0} x}{M}+\\frac{v_{0} y}{N}\\right)} &amp; \\Leftrightarrow F\\left(u-u_{0}, v-v_{0}\\right) \\\\f\\left(x-x_{0}, y-y_{0}\\right) &amp; \\Leftrightarrow F(u, v) e^{-j 2 \\pi\\left(\\frac{u x_{0}}{M}+\\frac{v y_{0}}{N}\\right)}\\end{aligned} ç¬¬ä¸€ä¸ªå…¬å¼è¡¨æ˜ï¼Œå°†f(x,y)ä¸ä¸€ä¸ªæŒ‡æ•°é¡¹ç›¸ä¹˜å°±ç›¸å½“äºæŠŠå…¶å˜æ¢åçš„é¢‘åŸŸä¸­å¿ƒç§»åŠ¨åˆ°æ–°çš„ä½ç½®ã€‚ ç¬¬äºŒä¸ªå…¬å¼è¡¨æ˜ï¼Œå°†F(u,v)ä¸ä¸€ä¸ªæŒ‡æ•°é¡¹ç›¸ä¹˜ï¼Œç›¸å½“äºæŠŠå…¶å˜æ¢åçš„ç©ºé—´åŸŸä¸­å¿ƒç§»åŠ¨åˆ°æ–°çš„ä½ç½®ã€‚ åŒæ—¶å¯ä»¥çœ‹å‡ºï¼Œå¯¹f(x,y)çš„å¹³ç§»ä¸ä¼šå½±å“å…¶å‚…é‡Œå¶å˜æ¢çš„å¹…å€¼ï¼Œå°†u0 = M/2 å’Œ v0 = N/2ä»£å…¥å…¬å¼ï¼ŒæŒ‡æ•°éƒ¨åˆ†å°±å˜æˆï¼š$e^{j 2 \\pi\\left(\\frac{u_{0} x}{M}+\\frac{\\nu_{0} y}{N}\\right)}=e^{j \\pi(x+y)}=(-1)^{(x+y)} $ ä»£å…¥ä¸Šé¢çš„å…¬å¼æœ‰ï¼š \\begin{array}{ll}f(x, y)(-1)^{(x+y)} &amp; \\Leftrightarrow F(u-M / 2, v-N / 2) \\\\f(x-M / 2, y-N / 2) &amp; \\Leftrightarrow F(u, v)(-1)^{(u+v)}\\end{array} å› æ­¤æœ‰ç»“è®ºï¼Œå¯¹æ•°å­—å›¾åƒçš„æ¯ä¸€ä¸ªåƒç´ ç‚¹çš„å–å€¼ç›´æ¥ä¹˜ä¸Š$(-1)^{x+y}$ï¼Œä¹‹ååœ¨åšå‚…é‡Œå¶å˜æ¢ï¼Œå¯ä»¥å¾—åˆ°ä¸­å¿ƒåŒ–åçš„é¢‘åŸŸå›¾ã€‚è¿™å’Œåœ¨é¢‘åŸŸç§»åŠ¨M/2å’ŒN/2æ˜¯ä¸€æ ·çš„æ•ˆæœã€‚ å‘¨æœŸæ€§ï¼šDFTå’Œä»–çš„é€†å˜æ¢æ˜¯ä»¥Mï¼ŒNä¸ºå‘¨æœŸçš„ å…±è½­å¯¹ç§°æ€§ æ—‹è½¬ä¸å˜æ€§ åŠ æ³•æœ‰åˆ†é…æ€§ï¼Œä¹˜æ³•æœ‰æ¯”ä¾‹æ€§ å¹³å‡å€¼ï¼šå°†$u = v = 0$ä»£å…¥äºŒç»´DFTå…¬å¼ï¼Œå¯å¾—åŸå›¾åƒå‡å€¼å°±æ˜¯è¯¥DFTåœ¨$(0,0)$å¤„çš„å€¼ DFTçš„é—®é¢˜è®¡ç®—é‡å¤§ï¼Œæ”¶æ•›æ…¢ å¼•å…¥FFTï¼šå¯¹äºä»»ä½•N = 2mçš„DFTï¼Œé€šè¿‡è®¡ç®—ä¸¤ä¸ªN/2çš„DFTï¼Œæ¥è®¡ç®—Nçš„DFT æœ‰æŒ‰ä½å€’åºæ’åˆ—ç­‰æ–¹æ³• å°ç»“ï¼šäºŒç»´ç¦»æ•£å‚…é‡Œå¶å˜æ¢åœ¨å›¾åƒå¤„ç†ä¸­æ˜¯ä¸€ä¸ªæ¯”è¾ƒåŸºæœ¬çš„æ•°å­¦å·¥å…·ï¼Œåˆ©ç”¨è¿™ä¸ªå·¥å…·ï¼Œå¯ä»¥å¯¹å›¾åƒçš„é¢‘è°±è¿›è¡Œå„ç§å„æ ·çš„å¤„ç†ï¼Œæ¯”å¦‚æ»¤æ³¢ã€é™å™ªã€å¢å¼ºç­‰ã€‚ é™¤ç¦»æ•£å‚…é‡Œå¶å˜æ¢ä¹‹å¤–ï¼Œè¿˜æœ‰æ²ƒå°”ä»€å’Œå“ˆè¾¾ç›å˜æ¢è¿™ä¸¤ç§é‡è¦çš„æ­£äº¤å˜æ¢ï¼Œä»–ä»¬å°†ä¿¡å·ä»æ—¶åŸŸæˆ–è€…ç©ºé—´åŸŸè½¬æ¢åˆ°ä¸€ç§ç”±äºŒè¿›åˆ¶å‡½æ•°(å¦‚çŸ©å½¢æ³¢)æ„æˆçš„é¢‘åŸŸï¼Œç±»ä¼¼äºå‚…é‡Œå¶å˜æ¢ï¼Œä½†è®¡ç®—æ›´åŠ é«˜æ•ˆ(åªæ¶‰åŠåŠ å‡è¿ç®—ï¼Œæ— éœ€å¤æ•°è¿ç®—) &nbsp; é¢‘åŸŸå›¾åƒå¢å¼ºæœ‰äº†äºŒç»´ç¦»æ•£å‚…é‡Œå¶å˜æ¢çš„åŸºç¡€ï¼Œä¸‹é¢å¯ä»¥è€ƒè™‘å…·ä½“çš„åº”ç”¨äº† ä¸€èˆ¬æ­¥éª¤æœ‰è¢«å¤„ç†å›¾åƒf(x,y)ï¼Œ å˜æ¢å‡½æ•°h(x,y)ï¼Œä»¥åŠæœ€ç»ˆçš„ç›®æ ‡å›¾åƒg(x,y) é¦–å…ˆå¯¹ä¸Šè¿°åŸå§‹å›¾åƒè¿›è¡Œçº¿æ€§ä½ç½®æ“ä½œï¼Œæ¯”å¦‚åˆ©ç”¨DFTçš„å¹³ç§»æ€§è´¨è¿›è¡Œå›¾åƒä¸­å¿ƒåŒ– ç„¶åæ ¹æ®è‡ªå·±çš„éœ€æ±‚ç¡®å®šå˜æ¢å‡½æ•° ç©ºé—´åŸŸçš„å·ç§¯ç­‰äºé¢‘åŸŸçš„ä¹˜ç§¯ $g(x,y) = h(x,y)* f(x,y),G(u,v) = H(u,v)F(u,v)$ æœ€åå¯¹ç›®æ ‡å›¾åƒçš„å‚…é‡Œå¶å˜æ¢è¿›è¡Œå‚…é‡Œå¶åå˜æ¢(ä¹Ÿåˆ©ç”¨å¹³ç§»æ€§è´¨ï¼Œå…·ä½“å¯è§ä¸Šä¸€å°èŠ‚çš„å…¬å¼)ï¼Œå³å¯å¾—åˆ°ç›®æ ‡å›¾åƒçš„ç©ºé—´åŸŸä¿¡å· é¢‘åŸŸå¹³é¢ä¸å›¾åƒç©ºåŸŸç‰¹æ€§çš„å…³ç³» å›¾åƒå˜åŒ–å¹³ç¼“çš„éƒ¨åˆ†(ä½é¢‘åŒºåŸŸ)é è¿‘é¢‘ç‡å¹³é¢çš„åœ†å¿ƒ å›¾åƒä¸­è¾¹ç•Œï¼Œå™ªå£°ï¼Œå˜åŒ–é™¡å³­çš„éƒ¨åˆ†ï¼Œä»¥æ”¾å°„æ–¹å‘ç¦»å¼€é¢‘ç‡å¹³é¢çš„åœ†å¿ƒï¼Œç§°ä¸ºé«˜é¢‘åŒºåŸŸ æ»¤æ³¢å™¨ç†æƒ³ä½é€šæ»¤æ³¢å™¨çš„å®šä¹‰ $H(u, v)=\\left\\{\\begin{array}{ll} 1 & \\operatorname{,D}(u, v) \\leq D_{0} \\\\ 0 & \\operatorname{,D}(u, v)>D_{0} \\end{array}\\right.$ å…¶ä¸­ï¼ŒD0ä¸ºæˆªæ­¢é¢‘ç‡åœ¨é¢‘ç‡å¹³é¢å†…åˆ°åŸç‚¹çš„è·ç¦»ï¼ŒD(u,v)ä¸ºè·ç¦»å‡½æ•°$D(u,v) = (u^2+v^2)^{\\frac{1}{2}}$ä¸è¿‡å› ä¸ºæ˜¯åœ¨é¢‘åŸŸï¼Œè¯´æ˜¯è·ç¦»æœ‰äº›é—®é¢˜ï¼Œåº”è¯¥å¯ä»¥æŠŠè¿™ä¸ªè¯´æˆæ˜¯æ°´å¹³ç©ºé—´é¢‘ç‡uå’Œå‚ç›´ç©ºé—´é¢‘ç‡vç»„æˆçš„å‘é‡çš„æ¨¡ ç†æƒ³ä½é€šæ»¤æ³¢å™¨çš„åˆ†æ æ•´ä¸ªèƒ½é‡çš„90%éƒ½è¢«ä¸€ä¸ªå¾ˆå°çš„å°åœ†å‘¨åŒ…å«ï¼Œå¤§éƒ¨åˆ†å°–é”çš„ç»†èŠ‚ä¿¡æ¯éƒ½å­˜åœ¨äºè¢«å»æ‰çš„10%çš„èƒ½é‡ä¸­ è¢«é’åŒ–çš„å›¾åƒæœ‰ä¸€ç§éå¸¸ä¸¥é‡çš„æŒ¯é“ƒæ•ˆæœ Butterworthä½é€šæ»¤æ³¢å™¨å®šä¹‰ï¼šä¸€ä¸ªæˆªæ­¢é¢‘ç‡åœ¨ä¸åŸç‚¹è·ç¦»ä¸ºD0çš„né˜¶butterworthæ»¤æ³¢å™¨çš„å˜æ¢å‡½æ•°å¦‚ä¸‹ï¼š $H(u, v)=\\frac{1}{1+\\left[D(u, v) / D_{0}\\right]^{2 n}}$ å…¶ä¸­ï¼ŒD0ä¸ºæˆªæ­¢é¢‘ç‡åœ¨é¢‘ç‡å¹³é¢å†…åˆ°åŸç‚¹çš„è·ç¦»ï¼ŒD(u,v)ä¸ºè·ç¦»å‡½æ•°$D(u,v) = (u^2+v^2)^{\\frac{1}{2}}$ ä¸ç†æƒ³ä½é€šæ»¤æ³¢å™¨çš„åŒºåˆ«æ˜¯ï¼Œå·´ç‰¹æ²ƒæ–¯ä½é€šæ»¤æ³¢å™¨åœ¨é€šå¸¦ä¸è¢«æ»¤é™¤çš„é¢‘ç‡ä¹‹é—´æ²¡æœ‰æ˜æ˜¾çš„æˆªæ–­ï¼Œå¯ä»¥ç¼“è§£æŒ¯é“ƒæ•ˆæœ åœ¨æŸäº›æ–‡çŒ®ä¸­ï¼Œå·´ç‰¹æ²ƒæ–¯æ»¤æ³¢å™¨çš„ä¼ é€’å‡½æ•°å¯èƒ½æ˜¯æŒ‡æ•°å½¢å¼ï¼Œä¾‹å¦‚ï¼š $H(u, v)=e^{-\\left(\\frac{D(u, v)}{D_{0}}\\right)^{2 n}}$ è¿™æ˜¯å› ä¸ºåœ¨xè¾ƒå¤§æ—¶ï¼Œä¸¤ç§ä¼ é€’å‡½æ•°çš„ä¸»ä½“éƒ¨åˆ†è¡°å‡çš„è¶‹åŠ¿ç›¸ä¼¼ï¼Œä¸”æŒ‡æ•°å½¢å¼åœ¨æŸäº›æƒ…å†µä¸‹è®¡ç®—æ›´ä¸ºæ–¹ä¾¿ã€‚ è¿™æ—¶å¯ä»¥æŠŠå·´ç‰¹æ²ƒæ–¯æ»¤æ³¢å™¨çœ‹ä½œé«˜æ–¯æ»¤æ³¢å™¨çš„ä¸€ç§æ¨å¹¿ã€‚ ç†æƒ³é«˜é€šæ»¤æ³¢å™¨åŠå…¶åˆ†æå¯æ ¹æ®ä½é€šæ»¤æ³¢å™¨ç‰¹æ€§ç±»æ¯” Butterworthé«˜é€šæ»¤æ³¢å™¨ $H(u, v)=\\frac{1}{1+\\left[{D}_{0} / {D}({u}, {v})\\right]^{2 n}}$ Butterworthé«˜é€šæ»¤æ³¢å™¨çš„åˆ†æ ä½é¢‘æˆåˆ†è¢«ä¸¥é‡åœ°å‰Šå¼±ï¼Œä½¿å›¾åƒå¤±å»å±‚æ¬¡ æ”¹è¿›æªæ–½ï¼š åŠ ä¸€ä¸ªå¸¸æ•°é¡¹åˆ°å˜æ¢å‡½æ•°ä¸­ ä¸ºè§£å†³å˜æš—åœ°è¶‹åŠ¿ï¼Œåœ¨å˜æ¢ååœ°å›¾åƒä¸Šå†è¿›è¡Œä¸€æ¬¡ç›´æ–¹å›¾å‡è¡¡åŒ–ï¼ˆåæ»¤æ³¢å¤„ç†ï¼‰ åŒå½¢æ»¤æ³¢å™¨æ¶ˆé™¤å›¾åƒä¸Šç…§æ˜ä¸å‡çš„é—®é¢˜ï¼Œå¢åŠ æš—åŒºçš„å›¾åƒç»†èŠ‚ï¼ŒåŒæ—¶åˆä¸æŸå¤±äº®åŒºçš„å›¾åƒç»†èŠ‚ï¼Œå®ƒåœ¨é¢‘åŸŸä¸­åŒæ—¶å°†äº®åº¦èŒƒå›´è¿›è¡Œå‹ç¼©ï¼Œä¸”å°†å›¾åƒå¯¹æ¯”åº¦è¿›è¡Œå¢å¼º é¦–å…ˆï¼Œä¸€ä¸ªå›¾åƒä¹Ÿå¯ä»¥ç”¨å…¶äº®åº¦å’Œåå°„åˆ†é‡çš„ä¹˜ç§¯æ¥è¡¨ç¤ºï¼š $f(x,y) = i(x,y)r(x,y)$ åŒå½¢æ»¤æ³¢å™¨é’ˆå¯¹ä¸Šé¢ä¸¤ä¸ªåˆ†é‡ï¼ŒåŒæ—¶è¿›è¡Œæ»¤æ³¢å¤„ç†ï¼Œä½†å› ä¸ºä¸¤ä¸ªå‡½æ•°ä¹˜ç§¯çš„å‚…é‡Œå¶å˜æ¢æ˜¯ä¸å¯ä»¥åˆ†ç¦»çš„ï¼Œæ‰€ä»¥é‡‡ç”¨å–å¯¹æ•°lnæ¥æ“ä½œ ä¸ªäººè®¤ä¸ºå¯ä»¥ç†è§£åŒå½¢æ»¤æ³¢å™¨æ˜¯ä¸€å®šç¨‹åº¦ä¸Šçš„å›¾åƒå¸¦é€šæ»¤æ³¢ ç©ºé—´åŸŸæ»¤æ³¢å’Œé¢‘åŸŸæ»¤æ³¢ä¹‹é—´çš„å…³ç³» é¢‘åŸŸä½é€šæ»¤æ³¢å™¨è¶Šçª„ï¼Œæ»¤é™¤çš„ä½é¢‘æˆåˆ†å°±è¶Šå¤šï¼Œå›¾åƒè¶Šæ¨¡ç³Šï¼›åœ¨ç©ºé—´åŸŸï¼Œè¿™æ„å‘³ç€ä½é€šæ»¤æ³¢å™¨è¶Šå®½ï¼Œæ¨¡æ¿è¶Šå¤§ é¢‘åŸŸå¯ä»¥å‡­å€Ÿç›´è§‚æŒ‡å®šæ»¤æ³¢å™¨ ç©ºé—´åŸŸæ»¤æ³¢å™¨æ•ˆæœå–å†³äºç©ºé—´æ¨¡æ¿çš„å¤§å° &nbsp; &nbsp; &nbsp; Ch4 å›¾åƒå¤åŸä¸æ¢å¤å›¾åƒå¤åŸçš„åŸºæœ¬æ¦‚å¿µå›¾åƒé€€åŒ–å®šä¹‰ï¼šå›¾åƒçš„è´¨é‡ä¸‹é™å«åšé€€åŒ– å½¢å¼ï¼šæ¨¡ç³Šã€å¤±çœŸã€æœ‰å™ªå£°ç­‰ åŸå› ï¼šæ— è®ºæ˜¯ç”±å…‰å­¦ã€å…‰ç”µæˆ–è€…ç”µå­æ–¹æ³•è·å¾—çš„å›¾åƒï¼Œå‡ä¼šæœ‰ä¸åŒç¨‹åº¦çš„é€€åŒ–ã€‚æ¯”å¦‚ä¼ æ„Ÿå™¨å™ªå£°ï¼Œç‰©ä½“ä¸æ‘„åƒè®¾å¤‡ä¹‹é—´çš„ç›¸å¯¹ç§»åŠ¨ç­‰ åœ¨å›¾åƒé‡‡é›†è¿‡ç¨‹ä¸­äº§ç”Ÿçš„è®¸å¤šé€€åŒ–å¸¸ç§°ä¸ºæ¨¡ç³Šï¼Œåœ¨å›¾åƒè®°å½•è¿‡ç¨‹ä¸­äº§ç”Ÿçš„é€€åŒ–å¸¸ç§°ä¸ºå™ªå£° å¦‚æœå¯¹é€€åŒ–çš„ç±»å‹ã€æœºåˆ¶å’Œè¿‡ç¨‹éƒ½ååˆ†æ¸…æ¥šï¼Œå°±å¯ä»¥åˆ©ç”¨å…¶åè¿‡ç¨‹æ¥å¤åŸå›¾åƒ å›¾åƒå¤åŸå¯¹é™è´¨äº†çš„å›¾åƒæ¢å¤æˆåŸæ¥çš„å›¾åƒã€‚å…·ä½“æ–¹æ³•ï¼šé’ˆå¯¹å¼•èµ·å›¾åƒé€€åŒ–çš„åŸå› ï¼Œä»¥åŠé™è´¨è¿‡ç¨‹çš„æŸå…ˆéªŒçŸ¥è¯†ï¼Œå»ºç«‹èµ·é€€åŒ–æ¨¡å‹ï¼Œå†é’ˆå¯¹é™è´¨è¿‡ç¨‹é‡‡å–ç›¸åçš„æ–¹å‘ï¼Œæ¢å¤å›¾åƒã€‚æœ¬è´¨ä¸Šæ˜¯ä¸€ç§é€†è¿‡ç¨‹ã€‚ ä¸€èˆ¬æ¥è®²ï¼Œå¤åŸçš„å¥½åæœ‰ä¸€ä¸ªè§„å®šçš„å®¢è§‚æ ‡å‡†ï¼Œä»¥ä¾¿å¯¹å¤åŸçš„ç»“æœä½œå‡ºæŸç§æœ€ä½³çš„è¯„ä¼°ã€‚ &nbsp; å›¾åƒé€€åŒ–æ¨¡å‹é€€åŒ–è¿‡ç¨‹å¯ä»¥çœ‹ä½œå¯¹åŸå›¾åƒä½œçº¿æ€§è¿ç®— $ g(x,y) = H f(x,y) + n(x,y)$ å…¶ä¸­Hæ˜¯é€€åŒ–æ¨¡å‹ï¼Œn(x,y)æ˜¯å™ªå£°ï¼Œé€€åŒ–æ¨¡å‹è¢«å»ºæ¨¡ä¸ºä¸€ä¸ªé€€åŒ–å‡½æ•°å’Œä¸€ä¸ªåŠ æ€§å™ªå£°é¡¹ åœ¨åç»­çš„è®¨è®ºä¸­ï¼Œå¯¹é€€åŒ–æ¨¡å‹Hä½œå‡ºä»¥ä¸‹çš„å‡è®¾ï¼š Hæ˜¯çº¿æ€§çš„ Hæ˜¯ç©ºé—´ï¼ˆæˆ–ä½ç§»ï¼‰ä¸å˜çš„ åœ¨è¿™é‡Œå…ˆçœç•¥å™ªå£°é¡¹ï¼Œå¯å°†ä¸€å¹…å›¾åƒçœ‹ä½œæ˜¯ç”±ä¸€ç³»åˆ—å†²æ¿€å‡½æ•°ç»„æˆçš„ï¼Œåˆ©ç”¨å†²æ¿€å‡½æ•°çš„å¶å‡½æ•°æ€§è´¨ä¸æŠ½æ ·æ€§è´¨ï¼š$\\int_{-\\infty}^{+\\infty} f(t) \\delta\\left(t-t_{0}\\right) d t=f\\left(t_{0}\\right)$ï¼Œå¯æ¨å¹¿åˆ°äºŒç»´ç©ºé—´ï¼š$f(x, y)=\\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(\\alpha, \\beta) \\delta(x-\\alpha, y-\\beta) \\mathrm{d} \\alpha \\mathrm{~d} \\beta$ï¼Œåˆ™æœ‰$g(x, y)=H \\cdot \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(\\alpha, \\beta) \\delta(x-\\alpha, y-\\beta) \\mathrm{d} \\alpha \\mathrm{~d} \\beta$ ç”±æ¨¡å‹Hçš„ä¸¤ä¸ªå‡è®¾æ€§è´¨å¯å¾—ï¼š Hæ˜¯çº¿æ€§çš„ï¼š$g(x,y) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty}H f(\\alpha, \\beta) \\delta(x-\\alpha, y-\\beta) \\mathrm{d} \\alpha \\mathrm{~d} \\beta$ Hæ˜¯ç©ºé—´ä½ç§»ä¸å˜çš„ï¼š $g(x,y) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty}f(\\alpha, \\beta) H \\delta(x-\\alpha, y-\\beta) \\mathrm{d} \\alpha \\mathrm{~d} \\beta$ $= \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty}f(\\alpha, \\beta) h(x-\\alpha, y-\\beta) \\mathrm{d} \\alpha \\mathrm{~d} \\beta$ ç§°$h(x,\\alpha;y,\\beta)$ä¸ºæ‰©æ•£å‡½æ•°(PSF)æˆ–è€…ç³»ç»Ÿå†²æ¿€å“åº” åœ¨å…‰å­¦ä¸­å†²æ¿€ä¸ºä¸€ä¸ªå…‰ç‚¹ï¼Œé€€åŒ–å¯ä»¥ç†è§£ä¸ºç³»ç»Ÿå†²æ¿€å“åº”é€ æˆçš„å›¾åƒçš„é™è´¨ ä¸Šè¿°å…¬å¼ç¬¦åˆäºŒç»´å·ç§¯çš„å®šä¹‰ï¼Œæœ‰ï¼š $g(x,y) = f(x,y)* h(x,y)$ å¦‚æœHæ˜¯ä¸€ä¸ªå¯åˆ†ç¦»ç³»ç»Ÿï¼Œå³$h(x,\\alpha;y,\\beta) = h_1(x,\\alpha)h_2(y,\\beta)$ï¼Œåˆ™äºŒç»´è¿ç®—å¯ä»¥åˆ†è§£ä¸ºåˆ—å’Œè¡Œä¸¤æ¬¡ä¸€ç»´è¿ç®—æ¥ä»£æ›¿ æ­¤æ—¶åœ¨åŠ ä¸Šå™ªå£°ï¼š $g(x,y) = f(x,y)+h(x,y) + n(x,y)$ ç»“è®ºï¼šä¸€ä¸ªçº¿æ€§ç³»ç»Ÿå®Œå…¨å¯ä»¥ç”±å®ƒçš„ç‚¹æ‰©æ•£å‡½æ•°PSFæ¥è¡¨å¾ã€‚è‹¥ç³»ç»Ÿçš„ç‚¹æ‰©æ•£å‡½æ•°å·²çŸ¥ï¼Œåˆ™ç³»ç»Ÿåœ¨(x,y)å¤„çš„è¾“å‡ºå“åº”å¯ä»¥çœ‹æˆæ˜¯ä¸åŒåæ ‡$(\\alpha,\\beta)$å¤„è¾“å…¥å‡½æ•°$f(\\alpha,\\beta)$æ‰€äº§ç”Ÿçš„è„‰å†²å“åº”åœ¨$(x,y)$å¤„çš„å åŠ ã€‚ æ¢å¤æ–¹æ³•ï¼š ç©ºé—´åŸŸä¸­çš„å·ç§¯ç­‰äºé¢‘åŸŸä¸­çš„ä¹˜ç§¯ï¼Œé¢‘åŸŸè¡¨ç¤ºä¸º $G(u,v) = H(u,v)F(u,v)+N(u,v)$ è‹¥ç•¥å»å™ªéŸ³ï¼Œæœ‰$F(u,v) = \\frac{G(u,v)}{H(u,v)}$ å¯¹ä¸Šå¼è¿›è¡Œå‚…é‡Œå¶åå˜æ¢ï¼Œå¯ä»¥æ±‚å¾—ç©ºé—´åŸŸæ¢å¤å›¾åƒ *åœ¨æ•°å­—å›¾åƒä¸­ï¼Œéœ€è¦å¯¹ä¸Šè¿°æ‰€æœ‰å†…å®¹è¿›è¡Œç¦»æ•£åŒ–å¤„ç† &nbsp; å™ªå£°ä»‹ç»å™ªå£°æ¦‚ç‡å¯†åº¦å‡½æ•° é«˜æ–¯å™ªå£° $p(z)=\\frac{1}{\\sqrt{2 \\pi} \\sigma} \\exp \\left[-\\frac{(z-\\mu)^{2}}{2 \\sigma^{2}}\\right]$ å‡åŒ€å™ªå£° $p(z)=\\left\\{\\begin{array}{ll} 1 /(b-a) & \\text { å¦‚æœ } \\quad a \\leqslant z \\leqslant b \\\\ 0 & \\text { å…¶ä»– } \\end{array}\\right.$ æ¤’ç›å™ªå£°ï¼ˆè„‰å†²å™ªå£°ï¼‰ $ p(z)=\\left\\{\\begin{array}{lll} P_{a} & \\text { å¦‚æœ } & z=a \\\\ P_{b} & \\text { å¦‚æœ } & z=b \\\\ 0 & \\text { å…¶ä»– } & \\end{array}\\right. $ é«˜æ–¯å™ªå£°æºäºç”µå­ç”µè·¯å™ªå£°å’Œç”±ä½ç…§æ˜åº¦æˆ–é«˜æ¸©å¸¦æ¥çš„ä¼ æ„Ÿå™¨å™ªå£° ç‘åˆ©å™ªå£°å¯¹åˆ†å¸ƒå†å›¾åƒèŒƒå›´å†…ç‰¹å¾åŒ–å™ªå£°æœ‰ç”¨ gammaåˆ†å¸ƒå’ŒæŒ‡æ•°åˆ†å¸ƒç”¨äºæ¿€å…‰æˆåƒçš„å™ªå£° å‡åŒ€å¯†åº¦åˆ†å¸ƒä½œä¸ºæ¨¡æ‹Ÿéšæœºæ•°äº§ç”Ÿå™¨çš„åŸºç¡€ è„‰å†²å™ªå£°ç”¨äºæˆåƒä¸­çš„çŸ­æš‚åœç•™ä¸­ï¼Œæ¯”å¦‚é”™è¯¯çš„å¼€å…³æ“ä½œ &nbsp; å›¾åƒå¤åŸçš„æ–¹æ³•æ— çº¦æŸè¿˜åŸæ³•åå‘æ»¤æ³¢æ³•æœ‰é€€åŒ–æ¨¡å‹ï¼š$g(x,y) = h(x,y)*f(x,y)+n(x,y)$ æ— çº¦æŸçš„åå‘æ»¤æ³¢æ³•è¿‡ç¨‹å¦‚ä¸‹ï¼š $ \\begin{array}{l} \\hat{f}(x, y)=g(x, y)^{*} h_{I}(x, y)=\\left[h(x, y)^{*} f(x, y)+n(x, y)\\right]^{*} h_{I}(x, y) \\\\ \\hat{F}(u, v)=[H(u, v) F(u, v)+N(u, v)] H_{I}(u, v) \\\\ \\text { è®¾: } \\quad H_{I}(u, v)=\\frac{1}{H(u, v)} \\Rightarrow \\hat{F}(u, v)=F(u, v)+\\frac{N(u, v)}{H(u, v)} \\end{array}$ å½“$H(u,v)$ä¸º0æˆ–è€…å¾ˆå°æ—¶ï¼Œå¤åŸå›¾åƒçš„å‚…é‡Œå¶å˜æ¢è¶‹è¿‘äºæ­£æ— ç©·ï¼Œå™ªå£°å®Œå…¨æ·¹æ²¡å›¾åƒ è§£å†³é€€åŒ–å‡½æ•°ä¸º0æˆ–è€…éå¸¸å°çš„æ–¹æ³•ï¼šé™åˆ¶æ»¤æ³¢çš„é¢‘ç‡ï¼Œä½¿å…¶æ¥è¿‘åŸç‚¹ ç»´çº³æ»¤æ³¢/æœ€å°å‡æ–¹è¯¯å·®æ»¤æ³¢ç»´çº³æ»¤æ³¢æ¢å¤æ­£æ˜¯åœ¨å‡å®šå›¾åƒä¿¡å·å¯ä»¥è¿‘ä¼¼çœ‹ä½œå¹³ç¨³éšæœºè¿‡ç¨‹çš„å‰æä¸‹ï¼ŒæŒ‰ç…§ä½¿åŸå›¾åƒ$f(x,y)$å’Œæ¢å¤åçš„å›¾åƒ$\\hat{f}(x,y)$ä¹‹é—´çš„å‡æ–¹è¯¯å·®è¾¾åˆ°æœ€å°çš„å‡†åˆ™ï¼Œæ¥å®ç°å›¾åƒæ¢å¤ï¼Œå¦‚ä¸‹ï¼š $e^{2}=\\min exp\\left\\{[f(x, y)-\\hat{f}(x, y)]^{2}\\right\\}$ æ»¡è¶³è¿™ä¸€è¦æ±‚çš„è½¬ç§»å‡½æ•°ä¸ºï¼š $H_{w}(u, v)=\\frac{H^{*}(u, v)}{|H(u, v)|^{2}+\\frac{S_{n}(u, v)}{S_{f}(u, v)}}$ å…¶ä¸­ï¼Œ$H^{*}(u, v)$æ˜¯é€€åŒ–å‡½æ•°çš„å¤å…±è½­å‡½æ•°ï¼Œ$S_n$æ˜¯å™ªå£°å›¾åƒåŠŸç‡è°±ï¼Œ$S_f$æ˜¯åŸå§‹å›¾åƒåŠŸç‡è°± æ¨å¹¿åˆ°æœ€å°å‡æ–¹è¯¯å·®æ»¤æ³¢å™¨ï¼š $\\hat{F}(u, v)=\\left[\\frac{1}{H(u, v)} \\times \\frac{|H(u, v)|^{2}}{|H(u, v)|^{2}+s\\left[S_{n}(u, v) / S_{f}(u, v)\\right]}\\right] G(u, v)$ å¦‚æœ $s = 1$ï¼Œæ–¹æ‹¬å·å†…çš„é¡¹å°±æ˜¯ç»´çº³æ»¤æ³¢å™¨ å¦‚æœsæ˜¯å˜é‡ï¼Œæ­¤æ—¶è¯¥æ»¤æ³¢å™¨è¢«ç§°ä¸ºå‚æ•°ç»´çº³æ»¤æ³¢å™¨ å½“æ²¡æœ‰å™ªå£°ï¼Œ$S_n(u,v) = 0$æ—¶ï¼Œç»´çº³æ»¤æ³¢å™¨é€€åŒ–æˆåå‘æ»¤æ³¢å™¨ä¸­çš„ç†æƒ³æ»¤æ³¢å™¨ æœ‰çº¦æŸè¿˜åŸæ³•æœ€å¤§å¹³æ»‘å¤åŸå‡†åˆ™ï¼šä»¥å‡½æ•°å¹³æ»‘ä¸ºåŸºç¡€ ä½¿å¾—å‡½æ•°çš„äºŒé˜¶å¯¼æ•°ä¸ºæœ€å° ç”¨å†…ç§¯æ¥è€ƒå¯Ÿå‡½æ•°çš„å¹³æ»‘æ€§ &nbsp; è¿åŠ¨æ¨¡ç³Šå›¾åƒçš„å¤åŸæ ¹æ®å…ˆéªŒçŸ¥è¯†ï¼ˆé€€åŒ–çš„åŸå› ä¸ºå·²çŸ¥ï¼‰å¤§æ°”æ¹æµé€ æˆçš„ä¼ é€’å‡½æ•° $H(u, v)=\\exp \\left[-c\\left(u^{2}+v^{2}\\right)^{5 / 6}\\right]$ cæ˜¯ä¸æ¹æµæ€§è´¨æœ‰å…³çš„å¸¸æ•° å…‰å­¦ç³»ç»Ÿæ•£ç„¦çš„ä¼ é€’å‡½æ•° $ H(u, v)=J_{1}(\\pi \\mathrm{~d} \\rho) / \\pi \\mathrm{d} \\rho \\\\ $ æ­¤å¤„$\\rho=\\sqrt{u^{2}+v^{2}} $ï¼Œdæ˜¯å…‰å­¦ç³»ç»Ÿæ•£ç„¦ç‚¹æ‰©æ•£å‡½æ•°çš„ç›´å¾„ $J_1()$æ˜¯ç¬¬ä¸€ç±»ä¸€é˜¶è´å¡å°”å‡½æ•° $ J_{1}(Z)=\\frac{Z}{2} \\sum_{k=0}^{\\infty} \\frac{(-1)^{k} Z^{2 k}}{2^{2 k} \\cdot k(k+1)} $ å½“å…‰å­¦ç³»ç»Ÿæ•£ç„¦æ—¶ï¼Œç‚¹å…‰æºçš„åƒå°†å˜æˆåœ†ç›˜ã€‚ä»å…¬å¼å¯ä»¥çœ‹å‡ºï¼Œæ•£ç„¦ç³»ç»Ÿçš„ä¼ é€’å‡½æ•°åœ¨ä»¥åŸç‚¹ä¸ºä¸­å¿ƒï¼Œdä¸ºåŠå¾„å¤„å­˜åœ¨é›¶ç‚¹ï¼Œå½¢æˆä¸€äº›åŒå¿ƒçš„æš—ç¯ï¼Œç”±æ•£ç„¦å›¾åƒçš„é¢‘è°±ä¸Šä¼°è®¡å‡ºè¿™äº›åŒå¿ƒåœ†çš„åŠå¾„ï¼Œå¯ä»¥å¾—åˆ°$H(u,v)$ åŒ€é€Ÿç›´çº¿è¿åŠ¨æ¨¡ç³Šä¸‹çš„ä¼ é€’å‡½æ•°ç›¸æœºä¸æ™¯ç‰©ä¹‹é—´ç›¸å¯¹è¿åŠ¨é€ æˆå›¾åƒé™è´¨ è®¾ç›¸æœºä¸åŠ¨ï¼Œå¯¹è±¡è¿åŠ¨ï¼Œè¿åŠ¨åˆ†é‡xï¼Œyåˆ†åˆ«ä¸º$x_0(t),y_0(t)$ï¼Œç›¸æœºå¿«é—¨é€Ÿåº¦æ˜¯ç†æƒ³çš„ï¼Œå¿«é—¨å¼€å¯æ—¶é—´ï¼ˆæ›å…‰æ—¶é—´ä¸º$T_0$, è¿™é‡Œçš„æ¨¡ç³Šåçš„å›¾åƒå€¼ä¸ºï¼š $ g(x, y)=\\int_{0}^{T} f\\left[x-x_{0}(t), y-y_{0}(t)\\right] \\mathrm{d} t $ æ¨¡ç³Šä¼ é€’å‡½æ•°ä¸º $H(u,v) = \\frac{sin\\pi l w}{\\pi l w}$ è¿™é‡Œçš„lä¸ºç”±äºè¿åŠ¨é€ æˆçš„ç‚¹ä½ç§»çš„é•¿åº¦ï¼Œ$w = ucons\\phi + v sin\\phi$ &nbsp; æ ¹æ®å›¾åƒä¸­çš„ç‚¹æˆ–è€…çº¿ä¼°è®¡(åéªŒçŸ¥è¯†)ç”±åŠŸç‡è°±ä¼°è®¡ä¼ é€’å‡½æ•°å™ªå£°çš„ç¡®å®šåªè¦å™ªå£°å¸¦å®½è¿œå¤§äºå›¾åƒå¸¦å®½å³å¯ä½œç™½å™ªå£°å¤„ç† &nbsp; å›¾åƒçš„å‡ ä½•æ ¡æ­£æ¦‚å¿µï¼šå‡ ä½•æ ¡æ­£æ˜¯ä¸€ç§å‡ ä½•å˜æ¢ï¼Œæ˜¯å›¾åƒçš„å‡ ä½•ç•¸å˜çš„åè¿ç®—ï¼Œä¸å‡ ä½•å˜æ¢ç±»ä¼¼ã€‚ æ­¥éª¤ï¼šç©ºé—´å˜æ¢ï¼Œç°åº¦æ’å€¼ å‡ ä½•åŸºå‡†å›¾åƒçš„åæ ‡ç³»ç»Ÿç”¨$(x,y)$æ¥è¡¨ç¤ºï¼Œéœ€è¦æ ¡æ­£çš„å›¾åƒçš„åæ ‡ç³»ç»Ÿç”¨ $(x^{â€˜},y^{â€˜})$è¡¨ç¤ºï¼Œä¸¤ä¸ªåæ ‡ç³»ç»Ÿä¹‹é—´çš„å…³ç³»ç”¨è§£æå¼è¡¨ç¤ºï¼š $\\begin{array}{l} x^{\\prime}=h_{1}(x, y) \\\\ y^{\\prime}=h_{2}(x, y) \\end{array}$ é€šå¸¸å¯ä»¥ç”¨å¤šé¡¹å¼è¡¨ç¤º $\\begin{aligned} x^{\\prime} & =\\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} a_{i j} x^{i} y^{j} \\\\ y^{\\prime} & =\\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} b_{i j} x^{i} y^{j} \\end{aligned}$ ç©ºé—´å˜æ¢å¯¹äºç©ºé—´å˜æ¢ï¼Œé€šå¸¸å¯ä»¥ç”¨çº¿æ€§ç•¸å˜æ¥è¿‘ä¼¼è¾ƒå°çš„å‡ ä½•ç•¸å˜ $\\begin{array}{l} x^{\\prime}=a_{0}+a_{1} x+a_{2} y \\\\ y^{\\prime}=b_{0}+b_{1} x+b_{2} y \\end{array}$ ä¹Ÿå¯ä»¥ç”¨æ›´ç²¾ç¡®ä¸€äº›çš„äºŒæ¬¡å‹æ¥è¿‘ä¼¼ å¯¹äºçº¿æ€§ç•¸å˜ï¼Œå¯ä»¥åœ¨åŸºå‡†å›¾ä¸Šæ‰¾å‡ºä¸‰ä¸ªç‚¹ï¼Œåœ¨ç•¸å˜å›¾ä¸Šä¹Ÿæ‰¾å‡ºå¯¹åº”çš„ä¸‰ä¸ªç‚¹ è”ç«‹è§£å‡ºä¸Šé¢çš„6ä¸ªç³»æ•° äºŒæ¬¡ç•¸å˜æ–¹ç¨‹ä¸ç³»æ•°é‡æ›´å¤š ç°åº¦æ’å€¼ç”±è¾“å‡ºå›¾åƒåæ ‡åç®—å‡ºè¾“å…¥å›¾åƒåæ ‡æ—¶ï¼Œè‹¥è¯¥åæ ‡å¹¶éæ•´æ•°ï¼Œéœ€è¦è¿›è¡Œç°åº¦å†é‡‡æ · æœ‰ä»¥ä¸‹å‡ ç§æ–¹æ³•ï¼š æœ€é‚»è¿‘æ’å€¼ï¼šæœ€ç®€å•ï¼Œä½†ä¼šæœ‰å—çŠ¶æ•ˆåº” åŒçº¿æ€§æ’å€¼ï¼š2*2é‚»åŸŸé‡‡æ ·ç‚¹çš„å¹³å‡å€¼ åŒä¸‰æ¬¡æ’å€¼ï¼š4*4é‚»åŸŸï¼Œè®¡ç®—å‡½æ•°ä¸ºä¸‰æ¬¡å‡½æ•°ï¼Œæ•ˆæœæœ€å¥½ï¼Œè®¡ç®—é‡æœ€å¤§ &nbsp; å›¾åƒå¤åŸçš„åº”ç”¨å›¾åƒå¤åŸçš„ç©ºé—´æ»¤æ³¢å™¨ï¼ˆåªå­˜åœ¨å™ªå£°ï¼‰ å‡å€¼æ»¤æ³¢å™¨ï¼ˆå¯è§å›¾åƒå¢å¼ºç¬”è®°ï¼‰ é¡ºåºç»Ÿè®¡æ»¤æ³¢å™¨ï¼ˆå¯è§å›¾åƒå¢å¼ºç¬”è®°ï¼‰ è‡ªé€‚åº”æ»¤æ³¢å™¨ è¡Œä¸ºå˜åŒ–åŸºäºç”±mxnçŸ©å½¢çª—å£å®šä¹‰çš„åŒºåŸŸ$S_{xy}$å†…çš„å›¾åƒç»Ÿè®¡ç‰¹æ€§ ä¸å‰è¿°æ»¤æ³¢å™¨ç›¸æ¯”ï¼Œæ€§èƒ½æ›´ä¼˜ï¼Œä½†ä¹Ÿå¢åŠ äº†ç®—æ³•å¤æ‚åº¦ åŒ…æ‹¬è‡ªé€‚åº”å±€éƒ¨å™ªå£°æ¶ˆé™¤æ»¤æ³¢å™¨å’Œè‡ªé€‚åº”ä¸­å€¼æ»¤æ³¢å™¨ è‡ªé€‚åº”å±€éƒ¨å™ªå£°æ¶ˆé™¤æ»¤æ³¢å™¨æ»¤æ³¢å™¨å“åº”åŸºäºä»¥ä¸‹4ä¸ªé‡ï¼š $g(x,y)$,è¡¨ç¤ºå™ªå£°å›¾åƒåœ¨ç‚¹$(x,y)$ä¸Šçš„å€¼ $\\sigma_{\\eta}^{2}$ï¼Œ$g(x,y)$çš„å™ªå£°æ–¹å·® $m_L$ï¼Œåœ¨$S_{xy}$ä¸Šåƒç´ ç‚¹çš„å±€éƒ¨å‡å€¼ $\\sigma_{L}^{2}$ï¼Œåœ¨$S_{xy}$ä¸Šåƒç´ ç‚¹çš„å±€éƒ¨æ–¹å·® æœ‰ï¼š $\\hat{f}(x, y)=g(x, y)-\\frac{\\sigma_{\\eta}^{2}}{\\sigma_{L}^{2}}\\left[g(x, y)-m_{L}\\right]$ å”¯ä¸€éœ€è¦çŸ¥é“æˆ–è€…ä¼°è®¡çš„æœªçŸ¥é‡æ˜¯å™ªå£°æ–¹å·®$\\sigma_{\\eta}^{2}$ï¼Œå…¶ä»–å‚æ•°å¯ä»¥ä»$S_{xy}$ä¸­çš„åƒç´ è®¡ç®—å‡ºæ¥ è‡ªé€‚åº”ä¸­å€¼æ»¤æ³¢å™¨ä¸¤ä¸ªè¿›ç¨‹ï¼Œæ˜¯æ¨ç†çª—å£æ‰©å¤§çš„è¿‡ç¨‹ å›¾åƒå¤åŸçš„é¢‘ç‡åŸŸæ»¤æ³¢å™¨å¸¦é€šæ»¤æ³¢å™¨å¸¦é˜»æ»¤æ³¢å™¨é™·æ³¢æ»¤æ³¢å™¨ç†æƒ³æ»¤æ³¢å™¨ &amp; å·´ç‰¹æ²ƒæ–¯æ»¤æ³¢å™¨ &amp; é«˜æ–¯æ»¤æ³¢å™¨ï¼ŒåŒå›¾åƒå¢å¼ºç« èŠ‚ &nbsp; å°ç»“å›¾åƒå¢å¼ºä¸å›¾åƒå¤åŸæœ‰äº¤å‰éƒ¨åˆ† å›¾åƒå¢å¼ºä¸»è¦æ˜¯ä¸»è§‚è¿‡ç¨‹ï¼Œè€Œå›¾åƒå¤åŸä¸»è¦æ˜¯å®¢è§‚è¿‡ç¨‹ &nbsp; &nbsp; &nbsp; Ch5 å½©è‰²å›¾åƒå¤„ç†å½©è‰²å›¾åƒå¤„ç†å¯ä»¥åˆ†ä¸ºï¼š å…¨å½©è‰²å¤„ç†ï¼šæ•°ç ç›¸æœºï¼Œå½©è‰²æ‰«æä»ª ä¼ªå½©è‰²å¤„ç†ï¼šå¯¹ä¸åŒç°åº¦æˆ–ç°åº¦èŒƒå›´èµ‹äºˆä¸åŒçš„é¢œè‰² &nbsp; å½©è‰²ç©ºé—´â€”â€”ä¹Ÿç§°ä¸ºå½©è‰²æ¨¡å‹æˆ–è€…å½©è‰²ç³»ç»Ÿ â€”â€”example: RGB \\ CMY &amp; CMYK \\ HSI \\ YIQ \\ YUV \\ YCbCr RGB CCDæˆ–è€…CMOSæŠ€æœ¯ç›´æ¥æ„ŸçŸ¥RGBä¸‰ä¸ªåˆ†é‡ï¼ˆæœ¬èº«å…‰ç”µä¼ æ„Ÿå™¨æ— æ³•è¯†åˆ«é¢œè‰²ï¼Œå¢åŠ æ»¤å…‰ç‰‡ä¹‹åå¯ä»¥åˆ†è¾¨ï¼‰ CMY &amp; CMYK CMYï¼ˆé’è‰²ï¼Œå“çº¢ï¼Œé»„ï¼‰CMYKï¼ˆé’ã€å“çº¢ã€é»„ã€é»‘ï¼‰ å¤§å¤šæ•°åœ¨çº¸ä¸Šæ²‰ç§¯å½©è‰²é¢œæ–™çš„è®¾å¤‡ï¼Œæ¯”å¦‚å½©è‰²æ‰“å°æœºå’Œå¤å°æœºã€å°åˆ·è®¾å¤‡ æ‰“å°ä¸­çš„ä¸»è¦é¢œè‰²æ˜¯é»‘è‰²ï¼Œç­‰é‡çš„CMYåŸè‰²å¯ä»¥äº§ç”Ÿé»‘è‰²ï¼Œä½†ä¸çº¯ HSI HSIï¼ˆè‰²è°ƒï¼Œé¥±å’Œåº¦ï¼Œäº®åº¦ï¼‰ Iåˆ†é‡ä¸å›¾åƒçš„å½©è‰²ä¿¡æ¯æ— å…³ Hå’ŒSåˆ†é‡ä¸äººæ„Ÿå—é¢œè‰²çš„æ–¹å¼æ˜¯ç´§å¯†ç›¸è¿çš„ å¹¿æ³›ç”¨äºè®¡ç®—æœºè§†è§‰ã€å›¾åƒæ£€ç´¢å’Œè§†é¢‘æ£€ç´¢ YIQ &amp; YUV YæŒ‡äº®åº¦ï¼Œå³ç°åº¦å€¼ Iå’ŒQæŒ‡è‰²è°ƒï¼Œæè¿°è‰²å½©åŠé¥±å’Œåº¦ï¼ŒUå’ŒVä¹ŸæŒ‡è‰²è°ƒï¼Œä¸å‰è€…ä¸åŒ ç”¨äºå½©è‰²ç”µè§†å¹¿æ’­ï¼ŒYIQè¢«åŒ—ç¾çš„ç”µè§†ç³»ç»Ÿæ‰€é‡‡ç”¨ï¼ŒYUVè¢«æ¬§æ´²çš„ç”µè§†ç³»ç»Ÿæ‰€é‡‡ç”¨ Yåˆ†é‡å¯æä¾›é»‘ç™½ç”µè§†æœºçš„æ‰€æœ‰å½±åƒä¿¡æ¯ YCbCr YæŒ‡äº®åº¦ Cbå’ŒCrç”±Uå’ŒVè°ƒæ•´å¾—åˆ° JPEGé‡‡ç”¨çš„å½©è‰²ç©ºé—´ &nbsp; å½©è‰²ç©ºé—´çš„è½¬æ¢ï¼ˆRGBä¸å…¶ä»–ï¼‰CMY å°†æ‰€æœ‰å€¼éƒ½å½’ä¸€åŒ–ä¹‹åï¼š $ \\left[\\begin{array}{l} C \\\\ M \\\\ Y \\end{array}\\right]=\\left[\\begin{array}{l} 1 \\\\ 1 \\\\ 1 \\end{array}\\right]-\\left[\\begin{array}{l} R \\\\ G \\\\ B \\end{array}\\right] $ RGB-&gt;HSI $ \\begin{array}{l} H=\\left\\{\\begin{array}{ll} \\theta & B \\leq G \\\\ 360-\\theta & B>G \\end{array}\\right. \\\\ \\theta=\\arccos \\left\\{\\frac{\\frac{1}{2}[(R-G)+(R-B)]}{\\left[(R-G)^{2}+(R-G)(G-B)\\right]^{\\frac{1}{2}}}\\right\\} \\\\ S=1-\\frac{3}{(R+G+B)}[\\min (R, G, B)] \\\\ I=\\frac{1}{3}(R+G+B) \\end{array}$ HSI-&gt;RGB $\\begin{array}{l}0^{0} \\leq H&lt;120^{\\circ} \\\\R=I\\left[1+\\frac{S \\cos H}{\\cos \\left(60^{\\circ}-H\\right)}\\right] \\quad G=1-(R+B) \\quad B=I(1-s)\\end{array}$ $\\begin{array}{l}120^{0} \\leq H&lt;240^{\\circ} \\\\G=I\\left[1+\\frac{S \\cos H}{\\cos \\left(60^{\\circ}-H\\right)}\\right] \\quad B=1-(R+G) \\quad R=I(1-s)\\end{array}$ $\\begin{array}{l}240^{0} \\leq H&lt;360^{\\circ} \\\\B=I\\left[1+\\frac{S \\cos H}{\\cos \\left(60^{\\circ}-H\\right)}\\right] \\quad R=1-(G+B) \\quad G=I(1-s)\\end{array}$ å…¶ä»– éœ€è¦æ•°å€¼çŸ©é˜µ &nbsp; ä¼ªå½©è‰²å›¾åƒå¤„ç†æ€æƒ³ï¼šæ ¹æ®ä¸€å®šçš„å‡†åˆ™å¯¹ç°åº¦å€¼èµ‹å€¼ä»¥å½©è‰²çš„å¤„ç† ä¸ºä»€ä¹ˆéœ€è¦ï¼šäººç±»å¯ä»¥è¾¨åˆ«ä¸Šåƒç§é¢œè‰²å’Œå¼ºåº¦ï¼Œä½†åªèƒ½è¾¨åˆ«äºŒåå‡ ç§ç°åº¦ï¼Œå› æ­¤éœ€è¦ä¸€ç§èƒ½å¤Ÿå¸®åŠ©äººç±»è§‚å¯Ÿä¸è§£é‡Šç°åº¦å›¾åƒçš„æŠ€æœ¯ å¦‚ä½•ï¼šå¼ºåº¦åˆ†å±‚æŠ€æœ¯ &amp; ç°åº¦çº§åˆ°å½©è‰²è½¬æ¢æŠ€æœ¯ å¼ºåº¦åˆ†å±‚æŠ€æœ¯ç®€å•æ¥è¯´å°±æ˜¯å¯¹å›¾åƒç°åº¦åˆ†å±‚åˆ‡å‰²ä¹‹ååˆ†é…å½©è‰²å€¼ ç°åº¦çº§åˆ°å½©è‰²çš„è½¬æ¢ å¯¹ä»»ä½•è¾“å…¥åƒç´ çš„ç°åº¦çº§æ‰§è¡Œ3ä¸ªç‹¬ç«‹å˜æ¢ 3ä¸ªå˜æ¢ç»“æœåˆ†åˆ«é€å…¥å½©è‰²ç›‘è§†å™¨çš„çº¢ç»¿è“ä¸‰ä¸ªé€šé“ï¼Œäº§ç”Ÿä¸€å¹…åˆæˆå›¾åƒ åº”ç”¨ï¼šXå…‰æ‰«æè¡Œæç®± &nbsp; å…¨å½©è‰²å›¾åƒå¤„ç†åˆ†ä¸ºä¸¤å¤§ç±»ï¼š åˆ†åˆ«å¤„ç†æ¯ä¸€ä¸ªåˆ†é‡çš„å›¾åƒååˆæˆå½©è‰²å›¾åƒ ç›´æ¥å¯¹å½©è‰²å›¾åƒå¤„ç†ï¼š3ä¸ªé¢œè‰²åˆ†é‡è¡¨ç¤ºåƒç´ å‘é‡ &nbsp; å½©è‰²å˜æ¢å½©è‰²å˜æ¢å‡½æ•°ï¼š $ g(x, y)=T[f(x, y)]\\\\ f(x, y) æ˜¯å½©è‰²è¾“å…¥å›¾åƒ \\\\ g(x, y) æ˜¯å˜æ¢æˆ–å¤„ç†è¿‡çš„å½©è‰²è¾“å‡ºå›¾åƒ \\\\T æ˜¯åœ¨ç©ºé—´é‚»åŸŸ (x, y) ä¸Šå¯¹ f çš„æ“ä½œ $ å¯¹äºæŸä¸€ä¸ªç‚¹å¤„å½©è‰²åˆ†é‡çš„å˜é‡ï¼š $ s_{i}=T_{i}\\left(r_{1}, r_{2}, \\ldots, r_{n}\\right) \\quad i=1,2, \\ldots, n\\\\ r_{i} å’Œ S_{i} æ˜¯ f(x, y) å’Œ g(x, y) åœ¨ä»»ä½•ç‚¹å¤„å½©è‰²åˆ†é‡çš„å˜é‡\\\\ \\left\\{T_{1}, T_{2}, \\ldots T_{n}\\right\\} æ˜¯ä¸€ä¸ªå¯¹ r_{i} æ“ä½œäº§ç”Ÿ s_{i} çš„å˜æ¢æˆ–å½©è‰²æ˜ å°„å‡½æ•°é›†$ è¡¥è‰²ï¼šåœ¨å½©è‰²ç¯ä¸Šï¼Œä¸ä¸€ç§è‰²è°ƒç›´æ¥ç›¸å¯¹ç«‹çš„å¦ä¸€ç§è‰²è°ƒç§°ä¸ºè¡¥è‰² è‰²è°ƒæ ¡æ­£ï¼šå®éªŒæ€§åœ°è°ƒæ•´å›¾åƒäº®åº¦å’Œå¯¹æ¯”åº¦ å½©è‰²å¹³è¡¡ï¼š åè‰²ï¼š é‡‡æ ·è¿‡ç¨‹ä¸­ï¼Œç”±äºè®¾å¤‡ã€ç¯å¢ƒçš„åŸå› ä¼šé€ æˆå›¾è±¡çš„ä¸‰ä¸ªé¢œè‰²åˆ†é‡ä¸åŒçš„å˜æ¢å…³ç³»ï¼Œä½¿å›¾è±¡ä¸­æ‰€æœ‰ç‰©ä½“çš„é¢œè‰²åç¦»äº†å…¶åŸæœ‰çš„çœŸå®è‰²å½©ï¼Œè¿™ç§ç°è±¡è¢«ç§°ä¸ºåè‰²ã€‚ å¦‚ä½•æ£€æŸ¥å½©è‰²å›¾åƒçš„åè‰²é—®é¢˜ï¼šå³æ£€æŸ¥åœ¨ç°å®ç§åº”è¯¥æ˜¯ç°è‰²çš„ç‰©ä½“ï¼Œåœ¨å›¾åƒä¸­æ˜¯å¦æ˜¯ç°è‰² è‰²å½©å¹³è¡¡ç®—æ³•ï¼šéœ€è¦é€‰å–ç°è‰²åŒºåŸŸï¼ŒæŒ‰æŸä¸€ä¸ªRGBåˆ†é‡ä½œä¸ºçº¿æ€§æ ¡æ­£çš„åŸºå‡† &nbsp; å½©è‰²å›¾åƒå¹³æ»‘å’Œå°–é”åŒ–åŒç°åº¦å›¾åƒï¼Œæœ‰ç©ºé—´åŸŸæ»¤æ³¢ä¸é¢‘ç‡å¾®åˆ†ï¼Œåªæ˜¯è¾“å…¥é€šé“æ¢æˆäº†å¯¹åº”å½©è‰²ç©ºé—´çš„nä¸ªåˆ†é‡ å½©è‰²ç©ºé—´åˆ†å‰²ï¼š HSIï¼šå¯ç”¨ç›´æ–¹å›¾åˆ†å‰² RGBï¼šå¯ç”¨ä¸åŒåƒç´ çš„é¢œè‰²å‘é‡ä¸åˆ†å‰²æ ·æœ¬çš„é¢œè‰²å‘é‡ä¹‹é—´çš„æ¬§æ°è·ç¦»ä¸ºåˆ¤æ® &nbsp; &nbsp; &nbsp; Ch6 å½¢æ€å­¦å›¾åƒå¤„ç†åŸºç¡€çŸ¥è¯†å½¢æ€å­¦ï¼šæ˜¯ç”Ÿç‰©å­¦ä¸­ç ”ç©¶åŠ¨ç‰©å’Œæ¤ç‰©ç»“æ„çš„ä¸€ä¸ªåˆ†æ”¯ã€‚ æ•°å­¦å½¢æ€å­¦ï¼ˆå›¾åƒä»£æ•°ï¼‰ï¼šä»¥å½¢æ€ä¸ºåŸºç¡€å¯¹å›¾åƒè¿›è¡Œåˆ†æçš„æ•°å­¦å·¥å…·ã€‚ å½¢æ€å­¦å›¾åƒå¤„ç†çš„åº”ç”¨ï¼šå¯ä»¥ç®€åŒ–å›¾åƒæ•°æ®ï¼Œä¿æŒå®ƒä»¬åŸºæœ¬çš„å½¢çŠ¶ç‰¹æ€§ï¼Œå¹¶é™¤å»ä¸ç›¸å¹²çš„ç»“æ„ã€‚ æ€æƒ³ï¼šç”¨å…·æœ‰ä¸€å®šå½¢æ€çš„ç»“æ„å…ƒç´ ï¼Œå»åº¦é‡å’Œæå–å›¾åƒä¸­çš„å¯¹åº”å½¢çŠ¶ï¼Œä»¥è¾¾åˆ°å¯¹å›¾åƒåˆ†æå’Œè¯†åˆ«çš„ç›®çš„ å‘å±•ï¼šåˆæœŸçš„æ•°å­¦å½¢æ€å­¦æ–¹æ³•ä»…å¯ä»¥åº”ç”¨äºäºŒå€¼å›¾åƒï¼Œæ‰€ä»¥éœ€è¦å°†ç°åº¦å›¾åƒå…ˆè¿›è¡ŒäºŒå€¼åŒ–ã€‚åæ¥ç°åº¦å½¢æ€å­¦å¾—åˆ°å‘å±•ï¼Œä½¿å¾—æ•°å­¦å½¢æ€å­¦æ–¹æ³•ä¸ä»…å¯ä»¥ç”¨äºäºŒå€¼å›¾åƒï¼Œä¹Ÿå¯ä»¥åº”ç”¨äºå„ç§ç°åº¦ä¸å½©è‰²å›¾åƒã€‚ &nbsp; äºŒå€¼å½¢æ€å­¦ä¸­çš„è¿ç®—å¯¹è±¡æ˜¯é›†åˆï¼Œä½†å®é™…è¿ç®—ä¸­å½“æ¶‰åŠä¸¤ä¸ªé›†åˆæ—¶å¹¶ä¸æŠŠä»–ä»¬çœ‹ä½œæ˜¯äº’ç›¸å¯¹ç­‰çš„ï¼Œä¸€èˆ¬è®¾Aä¸ºå›¾åƒé›†åˆï¼ŒBä¸ºç»“æ„å…ƒç´ ï¼Œæ•°å­¦å½¢æ€å­¦è¿ç®—æ˜¯ç”¨Bå¯¹Aè¿›è¡Œæ“ä½œã€‚ ç»“æ„å…ƒç´ æœ¬èº«å®é™…ä¸Šä¹Ÿæ˜¯ä¸€ä¸ªå›¾åƒé›†åˆã€‚å¯¹æ¯ä¸ªç»“æ„å…ƒç´ ï¼Œå…ˆè¦æŒ‡å®šä¸€ä¸ªåŸç‚¹ï¼Œå®ƒæ˜¯ç»“æ„å…ƒç´ å‚ä¸å½¢æ€å­¦è¿ç®—çš„å‚è€ƒç‚¹ã€‚æ³¨æ„åŸç‚¹å¯ä»¥åŒ…å«åœ¨ç»“æ„å…ƒç´ ä¸­ï¼Œä¹Ÿå¯ä»¥ä¸åŒ…å«åœ¨ç»“æ„å…ƒç´ ä¸­ï¼ˆå³åŸç‚¹å¹¶ä¸ä¸€å®šè¦å±äºç»“æ„å…ƒç´ ï¼‰ï¼Œä½†ä¸¤ç§æƒ…å†µä¸‹çš„è¿ç®—ç»“æœå¸¸ä¸ç›¸åŒ ã€‚ é›†åˆè®ºä¸­çš„åŸºæœ¬æ¦‚å¿µï¼šå¹¶ï¼Œäº¤ï¼Œè¡¥ï¼Œå·® æœ‰å…¬å¼ï¼š é›†åˆAçš„å¹³ç§»ï¼Œå¹³ç§»åˆ°z(z1,z2) $(A)_{z}=\\{c \\mid c=a+z, a \\in A\\}$ Bçš„åå°„ï¼šå…³äºç»“æ„å…ƒç´ çš„åŸç‚¹ $\\hat{B}=\\{w \\mid w=-b, b \\in B\\}$ ç¤ºæ„å›¾å¦‚ä¸‹ï¼š &nbsp; äºŒå€¼å›¾åƒçš„åŸºæœ¬é€»è¾‘è¿ç®— &nbsp; è†¨èƒ€ä¸è…èš€è†¨èƒ€ä¸è…èš€æ˜¯å½¢æ€å­¦ç®—æ³•çš„åŸºç¡€ è†¨èƒ€ï¼šä½¿å¾—å›¾åƒæ‰©å¤§ è…èš€ï¼šä½¿å¾—å›¾åƒç¼©å° è†¨èƒ€ï¼šAè¢«Bè†¨èƒ€çš„å®šä¹‰ï¼š $A \\oplus B=\\left\\{z \\mid(\\hat{B})_{z} \\cap A \\neq \\varnothing\\right\\}$ Aä¸ºå›¾åƒå…ƒç´ ï¼ŒBä¸ºç»“æ„å…ƒç´ ï¼Œä¸Šè¿°å¼å­è¡¨æ˜ï¼ŒBçš„åå°„è¿›è¡Œå¹³ç§»åä¸Açš„äº¤é›†ä¸ä¸ºç©º åå°„çš„ç›®çš„ï¼šç¡®ä¿è†¨èƒ€çš„ç©ºé—´å¯¹ç§°æ€§ ç®—æ³•å®ç°è¿‡ç¨‹ï¼š å¯¹Bè¿›è¡Œåå°„ï¼Œåå°„åBçš„åŸç‚¹ç§»åŠ¨è‡³é›†åˆAçš„æŸä¸€ç‚¹ å°†åå°„åBçš„åæ ‡ä¸é›†åˆAä¸­è¯¥åº—åæ ‡ç›¸åŠ ï¼Œå¾—åˆ°è†¨èƒ€è¿ç®—ç»“æœ å¯¹é›†åˆAä¸­æ‰€æœ‰å…ƒç´ é‡å¤ä¸Šè¿°è¿‡ç¨‹ example: åº”ç”¨ï¼šå°†è£‚ç¼æ¡¥æ¥èµ·æ¥ &nbsp; è…èš€Bå¯¹Açš„è…èš€æ˜¯ä¸€ä¸ªç”¨zå¹³ç§»çš„BåŒ…å«åœ¨Aä¸­æ‰€æœ‰çš„ç‚¹zçš„é›†åˆï¼Œå¯ä»¥ç†è§£ä¸ºï¼ŒBå®Œå…¨åŒ…å«åœ¨Aä¸­æ—¶ï¼ŒBçš„åŸç‚¹ä½ç½®çš„é›†åˆ å®šä¹‰ï¼š $A \\ominus B=\\left\\{z \\mid(B)_{z} \\subseteq A\\right\\}$ è†¨èƒ€å’Œè…èš€è¿™ä¸¤ç§è¿ç®—æ˜¯ç´§å¯†è”ç³»åœ¨ä¸€èµ·çš„ï¼Œä¸€ä¸ªè¿ç®—å¯¹å›¾åƒç›®æ ‡çš„æ“ä½œç›¸å½“äºå¦ä¸€ä¸ªè¿ç®—å¯¹å›¾åƒèƒŒæ™¯çš„æ“ä½œ exampleï¼š åº”ç”¨ï¼šåœ¨æ•°å­¦å½¢æ€å­¦è¿ç®—ä¸­çš„ä½œç”¨æ˜¯æ¶ˆé™¤ç‰©ä½“è¾¹ç•Œç‚¹ï¼Œå¯ä»¥æŠŠå°äºç»“æ„å…ƒç´ çš„ç‰©ä½“ï¼ˆæ¯›åˆºã€å°çªèµ·ï¼‰å»é™¤ï¼Œå› æ­¤é€‰å–ä¸åŒå¤§å°çš„ç»“æ„å…ƒç´ ï¼Œå°±å¯ä»¥åœ¨åŸå§‹å›¾åƒä¸­å»é™¤ä¸åŒå¤§å°çš„ç‰©ä½“ï¼Œè¾¾åˆ°ç­›é€‰çš„ç›®çš„ &nbsp; å¼€æ“ä½œå’Œé—­æ“ä½œå¼€æ“ä½œï¼šä½¿å›¾åƒçš„è½®å»“å˜å¾—å…‰æ»‘ï¼Œæ–­å¼€ç‹­çª„çš„è¿æ¥å’Œæ¶ˆé™¤ç»†çš„çªå‡ºç‰© $A \\circ B=(A \\ominus B) \\oplus B$ å…ˆç”¨Bå¯¹Aè…èš€ï¼Œç„¶åç”¨Bå¯¹ç»“æœè¿›è¡Œè†¨èƒ€ &nbsp; é—­æ“ä½œï¼šåŒæ ·ä½¿å¾—å›¾åƒçš„è½®å»“å˜å¾—å…‰æ»‘ï¼Œä½†ä¸å¼€æ“ä½œç›¸åï¼Œèƒ½æ¶ˆé™¤ç‹­çª„çš„é—´æ–­ä¸é•¿ç»†çš„é¸¿æ²Ÿï¼Œæ¶ˆé™¤å°çš„ç©ºæ´ï¼Œå¹¶å¡«è¡¥è½®å»“çº¿ä¸­çš„è£‚ç—• $A \\bullet B=(A \\oplus B) \\ominus B$ å…ˆç”¨Bå¯¹Aè†¨èƒ€ï¼Œç„¶åç”¨Bå¯¹ç»“æœè¿›è¡Œè…èš€ &nbsp; å‡»ä¸­æˆ–å‡»ä¸ä¸­å˜æ¢ ä¸€èˆ¬æ¥è¯´ï¼Œä¸€ä¸ªç‰©ä½“çš„ç»“æ„å¯ä»¥ç”±ç‰©ä½“å†…éƒ¨å„ç§æˆåˆ†ä¹‹é—´çš„å…³ç³»æ¥ç¡®å®šã€‚ä¸ºäº†ç ”ç©¶ç‰©ä½“ï¼ˆåœ¨è¿™é‡ŒæŒ‡å›¾åƒï¼‰çš„ç»“æ„ï¼Œå¯ä»¥é€ä¸ªåœ°åˆ©ç”¨å…¶å„ç§æˆåˆ† ï¼ˆä¾‹å¦‚å„ç§ç»“æ„å…ƒç´ ï¼‰å¯¹å…¶è¿›è¡Œæ£€éªŒï¼Œåˆ¤å®šå“ªäº›æˆåˆ†åŒ…æ‹¬åœ¨å›¾åƒå†…ï¼Œå“ªäº›åœ¨å›¾åƒå¤–ï¼Œä»è€Œæœ€ç»ˆç¡®å®šå›¾åƒçš„ç»“æ„ã€‚ è®¾æœ‰ä¸¤å¹…å›¾åƒA &amp; Bï¼Œå¦‚æœAä¸Bçš„äº¤é›†ä¸ä¸ºç©ºé›†ï¼Œé‚£ä¹ˆç§°Bå‡»ä¸­Aï¼Œå¦åˆ™ç§°Bå‡»ä¸ä¸­A &nbsp; ä¸€äº›åŸºæœ¬çš„å½¢æ€å­¦ç®—æ³•è¾¹ç•Œæå– $\\beta(A)=A-(A \\ominus B)$ å…ˆç”¨Bå¯¹Aè…èš€ï¼Œç„¶åç”¨Aå‡å»è…èš€çš„ç»“æœ ä½¿ç”¨3x3çš„ç»“æ„å…ƒç´ æå–çš„è¾¹ç•Œå®½åº¦ä¸º1åƒç´  åŒºåŸŸå¡«å……ä½¿ç”¨è¿­ä»£æ³•è¿›è¡ŒåŒºåŸŸå¡«å…… $X_{k}=\\left(X_{k-1} \\oplus B\\right) \\cap A^{c}$ å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š$X_7 = X_8$ï¼Œå½“$X_k = X_{k-1}$æ—¶ï¼Œç®—æ³•åœ¨è¿­ä»£çš„ç¬¬kæ­¥ç»“æŸ *å¦‚æœå…¬å¼ä¸åŠ ä¸Açš„è¡¥é›†çš„äº¤é›†ï¼Œåˆ™ç»“æœå°†ä¼šæ— é™è†¨èƒ€ å‡¸å£³ ç»†åŒ– ç²—åŒ– éª¨æ¶ è£å‰ªç­‰äºŒå€¼å½¢æ€å­¦çš„äº”ä¸ªåŸºæœ¬ç»“æ„å…ƒç´ ï¼ˆBï¼‰ &nbsp; ç°åº¦çº§å½¢æ€å­¦è†¨èƒ€ &amp; è…èš€è†¨èƒ€ï¼š $(f \\oplus b)(s, t)=\\max \\left\\{f(s-x, t-y)+b(x, y)(s-x),(t-y) \\in D_{f} ;(x, y) \\in D_{b}\\right\\} $ äº®ç‰¹å¾å˜å¼ºï¼Œæš—ç‰¹å¾å˜å¼± è…èš€ï¼š $(f \\ominus b)(s, t)=\\min \\left\\{f(s+x, t+y)-b(x, y)(s+x),(t+y) \\in D_{f} ;(x, y) \\in D_{b}\\right\\} $ äº®ç‰¹å¾å˜å¼±ï¼Œæš—ç‰¹å¾å˜å¼º å¼€æ“ä½œä¸é—­æ“ä½œä¸äºŒå€¼åŒ–å›¾åƒæ“ä½œçš„æ„æˆç›¸åŒ &nbsp; ç°åº¦çº§å½¢æ€å­¦å¤„ç†çš„ä¸€äº›åº”ç”¨å½¢æ€å­¦å¹³æ»‘å¤„ç†å…ˆå¼€æ“ä½œï¼Œå†é—­æ“ä½œï¼šæ¶ˆé™¤/å‡å¼±äººä¸ºçš„äº®å’Œæš—çš„ç»†èŠ‚ å½¢æ€å­¦å›¾åƒæ¢¯åº¦ï¼ˆè¾¹ç¼˜å¢å¼ºï¼‰ç±»ä¼¼äºå¾®åˆ† or æ¢¯åº¦æ“ä½œ è†¨èƒ€ç²—åŒ–å›¾åƒä¸­çš„ç›®æ ‡åŒºåŸŸï¼Œè…èš€ç»†åŒ–å®ƒä»¬ï¼Œä¸¤è€…ä¹‹å·®å¼ºè°ƒäº†åŒºåŸŸé—´çš„è¾¹ç•Œ $g=(f \\oplus b)-(f \\ominus b)$ Top-hatå˜æ¢å¯å¢å¼ºé˜´å½±ç»†èŠ‚ $h=f-(f \\circ b)$ ç²’åº¦æµ‹å®š é€‰æ‹©å„ç±»åˆé€‚åŠå¾„å°ºå¯¸çš„åœ†ç›˜ç»“æ„å…ƒå¯¹å›¾åƒè¿›è¡Œå¼€æ“ä½œ å¯¹äºæ¯ä¸€æ¬¡å¼€æ“ä½œï¼Œè®¡ç®—åƒç´ å€¼çš„å’Œ è¡¨é¢åŒºåŸŸæ˜¯åœ†ç›˜å½¢ç»“æ„å…ƒåŠå¾„çš„å‡½æ•° *ä¸ºä»€ä¹ˆä¸ç›´æ¥è…èš€ï¼šå•çº¯è…èš€ä¼šå¯¼è‡´é¢—ç²’å°ºå¯¸è¢«ä½ä¼°ï¼Œå¼€æ“ä½œé€šè¿‡ç»“æ„å…ƒç´ ä¸é¢—ç²’çš„åŒ¹é…åº¦ç­›é€‰å°ºå¯¸ï¼Œç»“æœæ›´æ¥è¿‘çœŸå®åˆ†å¸ƒ çº¹ç†åˆ†å‰² å¯¹åŸå›¾æ‰§è¡Œé—­æ“ä½œåˆ é™¤å°åœ†ç‚¹ æ‰§è¡Œå¼€æ“ä½œåˆ é™¤å¤§åœ†ç‚¹ä¹‹é—´çš„äº®é—´éš”ï¼Œå¾—åˆ°åˆ†å‰²è¾¹ç•Œ &nbsp; &nbsp; &nbsp; Ch7 å›¾åƒåˆ†å‰²åŸºç¡€çŸ¥è¯†å›¾åƒåˆ†å‰²æ˜¯æŒ‡æŠŠå›¾åƒåˆ†æˆå„ä¸ªå…·æœ‰ç›¸åº”ç‰¹æ€§çš„åŒºåŸŸå¹¶æå–å‡ºæ„Ÿå…´è¶£ç›®æ ‡çš„æŠ€æœ¯å’Œè¿‡ç¨‹ ç‰¹æ€§åŒ…æ‹¬ï¼šç°åº¦ã€é¢œè‰²ã€çº¹ç†ç­‰ï¼Œç›®æ ‡å¯ä»¥å¯¹åº”å•ä¸ªåŒºåŸŸï¼Œä¹Ÿå¯ä»¥å¯¹åº”å¤šä¸ªåŒºåŸŸ åˆ†ç±»ï¼š æŒ‰å¹…åº¦ä¸åŒåˆ†å‰²ï¼šå¹…åº¦åˆ†å‰² æŒ‰è¾¹ç¼˜ä¸åŒåˆ†å‰²ï¼šè¾¹ç¼˜æ£€æµ‹ æŒ‰å½¢çŠ¶ä¸åŒåˆ†å‰²ï¼šåŒºåŸŸæ£€æµ‹ å¯¹ç°åº¦å›¾åƒçš„åˆ†å‰²å¸¸å¯ä»¥åŸºäºåƒç´ ç°åº¦å€¼çš„ä¸¤ä¸ªæ€§è´¨ï¼š ä¸è¿ç»­æ€§å’Œç›¸ä¼¼æ€§ã€‚åŒºåŸŸå†…éƒ¨çš„åƒç´ ä¸€èˆ¬å…·æœ‰ç°åº¦ç›¸ä¼¼æ€§ï¼Œè€Œåœ¨åŒºåŸŸä¹‹é—´çš„è¾¹ç•Œä¸Šä¸€èˆ¬å…·æœ‰ç°åº¦ä¸è¿ç»­æ€§ã€‚ä¸è¿ç»­æ€§-&gt;åŸºäºè¾¹ç•Œçš„åˆ†å‰²ï¼›ç›¸ä¼¼æ€§-&gt;åŸºäºåŒºåŸŸçš„åˆ†å‰² &nbsp; é—´æ–­æ£€æµ‹ç‚¹æ£€æµ‹ä½¿ç”¨æ¨¡æ¿ $R = w_1z_1+w_2z_2+w_3z_3+...+w_9z_9 = \\sum_{i=1}^{9}w_iz_i$ äººä¸ºè®¾ç½®é˜ˆå€¼ï¼Œä¸”å¦‚æœæ¨¡æ¿çš„å“åº”ä¸º0ï¼Œåˆ™è¡¨ç¤ºåœ¨ç°åº¦çº§ä¸ºå¸¸æ•°çš„åŒºåŸŸ çº¿æ£€æµ‹æœ‰4ä¸ªçº¿æ£€æµ‹æ¨¡æ¿ï¼Œåˆ†åˆ«åœ¨æ°´å¹³ï¼Œ+45Â°ï¼Œå‚ç›´ä»¥åŠ-45Â°æ–¹å‘ä¸Šæœ‰æœ€å¤§å“åº” è¾¹ç¼˜æ£€æµ‹ è¾¹ç¼˜æ˜¯ä¸€ç»„ç›¸è¿çš„åƒç´ é›†åˆï¼Œè¿™äº›åƒç´ ä½äºä¸¤ä¸ªåŒºåŸŸçš„è¾¹ç•Œä¸Šã€‚ç°åº¦è¾¹ç¼˜æ˜¯ç°åº¦å€¼ä¸è¿ç»­çš„ç»“æœã€‚ ä¸€é˜¶å¯¼æ•°ä¸äºŒé˜¶å¯¼æ•°åœ¨è¯†åˆ«å›¾åƒçš„è¾¹ç¼˜ä¸­å…·æœ‰é‡è¦çš„ä½œç”¨ æ•°å­—è¾¹ç¼˜çš„æ¨¡å‹æœ‰ï¼šç†æƒ³æ•°å­—è¾¹ç¼˜æ¨¡å‹ &amp; æ–œå¡æ•°å­—è¾¹ç¼˜æ¨¡å‹ã€‚ç†æƒ³æ•°å­—è¾¹ç¼˜æ¨¡å‹æ˜¯ä¸€ç§é˜¶è·ƒå‹çš„ä¿¡å·ï¼Œè€Œæ–œå¡æ•°å­—è¾¹ç¼˜æ¨¡å‹ä¸è¾¹ç¼˜çš„æ¨¡ç³Šç¨‹åº¦æˆæ¯”ä¾‹å…³ç³»ã€‚ å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œä»¥æ–œå¡æ•°å­—è¾¹ç¼˜æ¨¡å‹ä¸ºä¾‹ï¼Œå¯å¯¹å…¶æ±‚å¯¼ï¼Œåœ¨è¾¹ç¼˜æ–œé¢ä¸Šï¼Œä¸€é˜¶å¯¼æ•°ä¸ºæ­£ï¼Œå…¶ä»–åŒºåŸŸä¸º0ï¼›åœ¨è¾¹ç¼˜ä¸é»‘è‰²äº¤ç•Œå¤„ï¼ŒäºŒé˜¶å¯¼æ•°ä¸ºæ­£ï¼Œåœ¨è¾¹ç¼˜ä¸äº®è‰²äº¤ç•Œå¤„ï¼ŒäºŒé˜¶å¯¼æ•°ä¸ºè´Ÿï¼›æ²¿ç€æ–œå¡å’Œç°åº¦ä¸ºå¸¸æ•°çš„åŒºåŸŸä¸º0ã€‚ å› æ­¤æœ‰ï¼š ä¸€é˜¶å¯¼æ•°å¯ä»¥ç”¨äºæ£€æµ‹å›¾åƒä¸­çš„ä¸€ä¸ªç‚¹æ˜¯å¦åœ¨è¾¹ç¼˜ä¸Š äºŒé˜¶å¯¼æ•°çš„ç¬¦å·å¯ä»¥åˆ¤æ–­ä¸€ä¸ªè¾¹ç¼˜åƒç´ æ˜¯åœ¨è¾¹ç¼˜çš„äº®ä¾§è¿˜æ˜¯åœ¨è¾¹ç¼˜çš„æš—ä¾§ ä¸€é˜¶å¯¼æ•°ä½¿ç”¨æ¢¯åº¦ç®—å­ï¼ŒäºŒé˜¶å¯¼æ•°ä½¿ç”¨æ‹‰æ™®æ‹‰æ–¯ç®—å­ *å¾®å¼±çš„å™ªå£°å¯¹å¯¼æ•°çš„å½±åƒéå¸¸ä¸¥é‡ï¼Œæ‰€ä»¥é¢„å¤„ç†è¦å…ˆé™å™ª/å¹³æ»‘å¤„ç† è¾¹ç¼˜æ£€æµ‹ç®—å­ æ¢¯åº¦ç®—å­ or å·®åˆ†ç®—å­ Laplaceç®—å­ Cannyç®—å­ &nbsp; æ¢¯åº¦ç®—å­$\\nabla f(x, y) = G[f(x,y)] = [\\frac{\\partial f}{\\partial x} \\frac{\\partial f}{\\partial y}]^{T}$ æ¢¯åº¦çš„æ¨¡ï¼š$|\\nabla f(x, y)|=\\sqrt{\\left(\\frac{\\partial f}{\\partial x}\\right)^{2}+\\left(\\frac{\\partial f}{\\partial y}\\right)^{2}}$ æ–¹å‘è§’ï¼š$\\phi(x, y)=\\arctan \\left(G_{x} / G_{y}\\right)$ ç¦»æ•£åŒ–åä¸ºï¼š$\\nabla f(x, y)=|f(x, y)-f(x+1, y+1)|+|f(x+1, y)-f(x, y+1)|$ åœ¨ç©ºé—´åŸŸå›¾åƒå¢å¼ºçš„åŸºç¡€ä¸Šå¢åŠ æ¢¯åº¦ç®—å­Kirschï¼š ç”±8ä¸ªæ–¹å‘æ¨¡æ¿ç»„æˆï¼Œæ¯ä¸ªæ¨¡æ¿çš„å€¼æœ‰ä¸åŒçš„è¶‹å‘æ€§ï¼Œå°†8ä¸ªæ¨¡æ¿åˆ†åˆ«ä¸å›¾åƒç›¸ä¹˜ï¼Œé€‰å–æœ€å¤§çš„ä¸€ä¸ªå€¼ï¼Œä½œä¸ºä¸­å¤®åƒç´ çš„è¾¹ç¼˜å¼ºåº¦ã€‚ä½¿å¾—æ¢¯åº¦ç®—å­ä¸€å®šç¨‹åº¦ä¸Šå…·æœ‰äº†æ–¹å‘æ€§ã€‚ &nbsp; æ‹‰æ™®æ‹‰æ–¯ç®—å­å…¬å¼ä¸æ¨¡æ¿ï¼š $ \\begin{array}{l} \\nabla^{2} f(x, y)=\\frac{\\partial^{2} f(x, y)}{\\partial x^{2}}+\\frac{\\partial^{2} f(x, y)}{\\partial y^{2}} \\\\ =f(x+1, y)+f(x-1, y)+f(x, y-1)+4 f(x, y) \\\\\\\\ {\\left[\\begin{array}{ccc} 0 & -1 & 0 \\\\ -1 & 4 & -1 \\\\ 0 & -1 & 0 \\end{array}\\right] \\quad\\left[\\begin{array}{ccc} -1 & -1 & -1 \\\\ -1 & 8 & -1 \\\\ -1 & -1 & -1 \\end{array}\\right] \\quad\\left[\\begin{array}{ccc} 1 & -2 & 1 \\\\ -2 & 4 & -2 \\\\ 1 & -2 & 1 \\end{array}\\right] } \\end{array} $ æ¨å¹¿ï¼š ä¸ºå‡å°‘å™ªå£°å¯¹æ‹‰æ™®æ‹‰æ–¯ç®—å­çš„å½±å“ï¼Œåœ¨å…¶åŸºç¡€ä¸Šå®ç°çš„é©¬å°”ç®—å­ï¼Œå®ƒå…ˆç”¨ä¸€ä¸ª2Dçš„é«˜æ–¯å¹³æ»‘æ¨¡æ¿ä¸æºå›¾åƒè¿›è¡Œå·ç§¯ï¼Œä¹‹åå†è¿›è¡Œæ‹‰æ™®æ‹‰æ–¯ç®—å­å¥—ç”¨ã€‚ &nbsp; æœ€ä¼˜è¾¹ç¼˜æ£€æµ‹ç®—æ³•â€”â€”Cannyç®—å­ å¥½çš„å›¾åƒè¾¹ç¼˜æ£€æµ‹éœ€è¦æ»¡è¶³ä¸‹é¢ä¸¤ä¸ªæ¡ä»¶ï¼š èƒ½æœ‰æ•ˆåœ°æŠ‘åˆ¶å™ªå£° èƒ½ç²¾ç¡®åœ°å®šä½åˆ°è¾¹ç¼˜çš„ä½ç½® ç±»ä¼¼äºé©¬å°”ç®—å­ï¼ŒCannyç®—å­ä¹Ÿå±äºå…ˆå¹³æ»‘åæ±‚å¯¼çš„æ–¹æ³• ç®—æ³•æ­¥éª¤ ç”¨é«˜æ–¯æ»¤æ³¢å™¨å¹³æ»‘å›¾åƒï¼š $G(x, y)=f(x, y) * H(x, y)$ ç”¨ä¸€é˜¶åå¯¼çš„æœ‰é™å·®åˆ†æ¥è®¡ç®—æ¢¯åº¦çš„å¹…å€¼å’Œæ–¹å‘ $\\begin{array}{l} H_{1}=\\left|\\begin{array}{cc} -1 & -1 \\\\ 1 & 1 \\end{array}\\right| \\quad H_{2}=\\left|\\begin{array}{ll} 1 & -1 \\\\ 1 & -1 \\end{array}\\right| \\\\ \\varphi_{1}(m, n)=f(m, n) * H_{1}(m, n) \\\\ \\varphi_{2}(m, n)=f(m, n) * H_{2}(m, n) \\\\ \\varphi(m, n)=\\sqrt{\\varphi_{1}^{2}(m, n)+\\varphi_{2}^{2}(m, n)} \\\\ \\theta_{\\varphi}(m, n)=\\tan ^{-1} \\frac{\\varphi_{2}(m, n)}{\\varphi_{1}(m, n)} \\end{array}$ éæå¤§å€¼æŠ‘åˆ¶â€”â€”ç»†åŒ–è¾¹ç¼˜ åˆ©ç”¨æ¢¯åº¦çš„æ–¹å‘ï¼Œä¿ç•™å±€éƒ¨æ¢¯åº¦æœ€å¤§çš„ç‚¹ $\\xi[\\mathbf{i}, \\mathbf{j}]=\\operatorname{Sector}(\\theta[\\mathbf{i}, \\mathbf{j}])$ åœ¨ä¸€ä¸ª3x3çš„é‚»åŸŸä¸­ï¼Œ4ç§ç±»å‹çš„è¾¹ç¼˜æ–¹å‘çš„è¾¹ç¼˜æ³•çº¿æœ‰ä¸€å®šçš„è§’åº¦èŒƒå›´ï¼Œåœ¨æ¯ä¸€ç‚¹ä¸Šï¼Œé‚»åŸŸçš„ä¸­å¿ƒåƒç´ Mä¸æ²¿ç€æ¢¯åº¦çº¿çš„ä¸¤ä¸ªåƒç´ ç›¸æ¯”ã€‚å¦‚æœMçš„æ¢¯åº¦å€¼ä¸æ¯”æ²¿æ¢¯åº¦çº¿çš„ä¸¤ä¸ªç›¸é‚»åƒç´ æ¢¯åº¦å€¼å¤§ï¼Œåˆ™ä»¤M = 0. $\\mathbf{N}[\\mathbf{i}, \\mathbf{j}]=\\mathbf{N M S}(\\mathbf{M}[\\mathbf{i}, \\mathbf{j}], \\xi[\\mathbf{i}, \\mathbf{j}])$ é˜ˆå€¼åŒ– å¯¹Nä½¿ç”¨ä¸€ä¸ªé˜ˆå€¼ï¼Œå°†ä½äºé˜ˆå€¼çš„æ‰€æœ‰å€¼èµ‹0ï¼Œè§£å†³æ–¹æ³•ä¸ºåŒé˜ˆå€¼ç®—æ³• &nbsp; è¾¹ç¼˜è¿æ¥åœ¨è¾¹ç¼˜æ£€æµ‹åï¼Œä»…ä»…å¾—åˆ°ä½ç½®åœ¨è¾¹ç¼˜ä¸Šçš„åƒç´ ç‚¹ï¼Œå®é™…ä¸Šå¾—åˆ°çš„è¿™äº›åƒç´ ç‚¹ç”±äºå„ç§åŸå› å¾ˆå°‘èƒ½å®Œæ•´åœ°ç»„æˆä¸€æ¡è¾¹ç¼˜ï¼Œå› æ­¤åœ¨ä½¿ç”¨è¾¹ç¼˜æ£€æµ‹ç®—æ³•ä¹‹åï¼Œéœ€è¦ä½¿ç”¨è¿æ¥è¿‡ç¨‹å°†è¾¹ç¼˜åƒç´ ç»„åˆæˆæœ‰æ„ä¹‰çš„è¾¹ç¼˜ã€‚ å±€éƒ¨å¤„ç†å¦‚ä½•ç¡®å®šè¾¹ç¼˜åƒç´ çš„ç›¸ä¼¼æ€§ å¯¹äºä¸¤ä¸ªè¾¹ç¼˜åƒç´ ï¼Œè‹¥ä»¥ä¸‹ä¸¤ä¸ªå€¼ï¼š è¾¹ç¼˜åƒç´ æ¢¯åº¦ç®—å­çš„å“åº”å¼ºåº¦ è¾¹ç¼˜åƒç´ æ¢¯åº¦ç®—å­çš„æ–¹å‘ åœ¨è‡ªå·±è®¾å®šçš„é˜ˆå€¼èŒƒå›´å†…ï¼Œåˆ™å¯ä»¥å°†ä¸¤ç‚¹è¿æ¥èµ·æ¥ è½®å»“è·Ÿè¸ªå’Œå›¾æœç´¢ ç¡®å®šä½œä¸ºæœç´¢èµ·ç‚¹çš„è¾¹ç¼˜ç‚¹ ç¡®å®šå’Œé‡‡å–ä¸€ç§åˆé€‚çš„æ•°æ®ç»“æ„å’Œæœç´¢æœºç†ï¼Œåœ¨å·²ç»å‘ç°çš„è½®å»“ç‚¹åŸºç¡€ä¸Šç¡®å®šæ–°çš„è½®å»“ç‚¹ ç¡®å®šæœç´¢ç»ˆç»“çš„å‡†åˆ™æˆ–è€…ç»ˆæ­¢æ¡ä»¶ï¼Œæ»¡è¶³æ¡ä»¶æ—¶åœæ­¢è¿›ç¨‹ï¼Œç»“æŸæœç´¢ ä¸ªäººè®¤ä¸ºç®—æ˜¯ä¸€ç§è·¯å¾„æœç´¢ç®—æ³•ï¼Œè¾¹ç•Œç‚¹å’Œè¾¹ç•Œæ®µå¯ä»¥ç”¨å›¾ç»“æ„è¡¨ç¤ºï¼Œé€šè¿‡åœ¨å›¾ä¸­è¿›è¡Œæœç´¢å¯¹åº”æœ€å°ä»£ä»·çš„é€šé“ä¹Ÿå¯ä»¥æ‰¾åˆ°é—­åˆè¾¹ç•Œã€‚ è¾¹ç¼˜å…ƒç´ æ˜¯2ä¸ªäº’ä¸º4-è¿‘é‚»çš„åƒç´ çš„è¾¹ç¼˜ï¼Œæ¯ä¸ªç”±åƒç´ på’Œqç¡®å®šçš„è¾¹ç¼˜å…ƒç´ å¯¹åº”ä¸€ä¸ªä»£ä»·å‡½æ•°ï¼š $ c(p,q) = H- [f(p)-f(q)] $ å…¶ä¸­Hä¸ºå›¾åƒä¸­çš„æœ€å¤§ç°åº¦å€¼ï¼Œä»£ä»·å‡½æ•°çš„å–å€¼ä¸åƒç´ ä¹‹é—´çš„ç°åº¦å·®æˆåæ¯”ï¼Œéœ€è¦æ‰¾å¯»çš„è¾¹ç•Œæ—¶ä»£ä»·æœ€å°çš„è·¯å¾„ exampleï¼š å“ˆå¤«å˜æ¢åˆ©ç”¨å›¾åƒçš„å…¨å±€ç‰¹æ€§ç›´æ¥æ£€æµ‹ç›®æ ‡è½®å»“ æå‡ºï¼šä»åƒç´ ä¹‹é—´çš„æ•´ä½“å…³ç³»å‡ºå‘ï¼Œæ£€æµ‹ç›®æ ‡è¾¹ç•Œ æŠŠåœ¨å›¾åƒç©ºé—´é‡Œçš„ç›´çº¿æ£€æµ‹é—®é¢˜è½¬æ¢ä¸ºå‚æ•°ç©ºé—´é‡Œå¯¹ç‚¹çš„æ£€æµ‹é—®é¢˜ï¼Œé€šè¿‡åœ¨å‚æ•°ç©ºé—´é‡Œè¿›è¡Œç®€å•çš„ç´¯åŠ ç»Ÿè®¡å®Œæˆæ£€æµ‹ä»»åŠ¡ã€‚ æ¶‰åŠåˆ°åæ ‡ç³»å˜æ¢ä¸è§£æï¼Œå¯çœ‹å…¶ä»–èµ„æ–™è¿›ä¸€æ­¥äº†è§£å¹¶ç†è§£æ¨å¯¼ã€‚ &nbsp; é˜ˆå€¼åˆ†å‰²å­—é¢ç†è§£ï¼Œé˜ˆå€¼åˆ†å‰²æ–¹æ³•çš„å…³é”®æ˜¯é€‰å–åˆé€‚çš„é˜ˆå€¼ æœ‰ä»¥ä¸‹å‡ ç§æ–¹æ³•ï¼š å…¨å±€é˜ˆå€¼ å±€éƒ¨é˜ˆå€¼ åŠ¨æ€/è‡ªé€‚åº”é˜ˆå€¼ å…¨å±€é˜ˆå€¼è‡ªåŠ¨è·å–é˜ˆå€¼Tçš„æ–¹æ³•ï¼š é€‰å–ä¸€ä¸ªTçš„åˆå§‹ä¼°è®¡å€¼ï¼Œä¸€èˆ¬å–å›¾åƒçš„å¹³å‡ç°åº¦ ç”¨Tåˆ†å‰²å›¾åƒï¼ŒG1ä¸ºæ‰€æœ‰ç°åº¦å€¼å¤§äºTçš„ï¼Œå‰©ä½™ä¸ºG2 å¯¹G1å’ŒG2ä¸­æ‰€æœ‰åƒç´ è®¡ç®—å¹³å‡ç°åº¦å€¼g1å’Œg2 è®¡ç®—æ–°çš„é˜ˆå€¼$T_1 = \\frac{1}{2}(g_1+g_2)$ é‡å¤æ­¥éª¤2~4ï¼Œç›´åˆ°è¿­ä»£å¾—åˆ°çš„Tå€¼å°äºç­‰äºTåˆå§‹å€¼ åŸºæœ¬è‡ªé€‚åº”é˜ˆå€¼å•ä¸€å…¨å±€é˜ˆå€¼å­˜åœ¨çš„é—®é¢˜ï¼šä¸å‡åŒ€äº®åº¦å›¾åƒæ— æ³•æœ‰æ•ˆåˆ†å‰² è§£å†³æ–¹æ³•ï¼šå°†å›¾åƒè¿›ä¸€æ­¥ç»†åˆ†ä¸ºå­å›¾åƒï¼Œå¹¶å¯¹ä¸åŒçš„å­å›¾åƒä½¿ç”¨ä¸åŒçš„é˜ˆå€¼å¤„ç† é—®é¢˜ï¼šå¦‚ä½•å°†å›¾åƒè¿›è¡Œç»†åˆ†ï¼Œä¸”å¦‚ä½•ä¸ºå¾—åˆ°çš„å­å›¾åƒä¼°è®¡é˜ˆå€¼ å¯¹äºä»…åŒ…å«2ä¸ªä¸»è¦ç°åº¦çº§çš„åŒºåŸŸï¼Œä»¤zè¡¨ç¤ºç°åº¦çº§å€¼ï¼Œåˆ™ä¸¤ä¸ªç°åº¦åŒºåŸŸçš„ç›´æ–¹å›¾å¯ä»¥çœ‹ä½œå…¶æ¦‚ç‡å¯†åº¦å‡½æ•°çš„ä¼°è®¡p(z)ï¼Œå¦‚æœp(z)å·²çŸ¥ï¼Œåˆ™å®ƒèƒ½å¤Ÿç¡®å®šä¸€ä¸ªæœ€æœ‰é˜ˆå€¼ï¼Œå°†å›¾åƒåˆ†å‰²æˆä¸¤ä¸ªå¯ä»¥åŒºåˆ†çš„éƒ¨åˆ†ï¼Œä¸‹å¼ä¸­P1æ˜¯å±äºç›®æ ‡å¯¹è±¡çš„æ¦‚ç‡ï¼ŒP2æ˜¯å±äºèƒŒæ™¯åƒç´ çš„æ¦‚ç‡ï¼Œæœ‰$P_1+P_2 = 1$ æœ€ä¼˜é˜ˆå€¼ï¼š $T=\\frac{\\mu_{1}+\\mu_{2}}{2}+\\frac{\\sigma^{2}}{\\mu_{1}-\\mu_{2}} \\ln \\left(\\frac{P_{2}}{P_{1}}\\right)$ æ•°å­¦æ¨å¯¼ç•¥å¤æ‚ï¼Œé‚çœç•¥ é€šè¿‡è¾¹ç•Œç‰¹æ€§é€‰æ‹©é˜ˆå€¼åŸºæœ¬æ€æƒ³ï¼Œå°†ç›´æ–¹å›¾ä¿®æ­£ä¸ºè¾ƒä¸ºç›´è§‚çš„å½¢æ€ï¼šæ³¢å³°é«˜ä¸”çª„ï¼Œå¯¹ç§°ï¼Œä¸”è¢«å¾ˆæ·±çš„æ³¢è°·åˆ†å¼€ã€‚ ä¿®æ­£æ–¹æ³•ï¼šç”¨å¾®åˆ†ç®—å­å¤„ç†å›¾åƒï¼Œä½¿å¾—å›¾åƒåªå‰©ä¸‹è¾¹ç•Œä¸­å¿ƒä¸¤è¾¹çš„å€¼ï¼Œå› æ­¤ç›´æ–¹å›¾ä¹Ÿåªå‰©ä¸‹è¾¹ç¼˜çš„åƒç´ ã€‚è¾¹ç¼˜ä¸Šçš„ç‚¹åœ¨åŒºåŸŸå†…å’ŒåŒºåŸŸå¤–çš„æ¦‚ç‡ç›¸ç­‰ï¼Œå› æ­¤å¯ä»¥å¢åŠ æ³¢å³°çš„å¯¹ç§°æ€§ &nbsp; èšç±»åˆ†å‰²æœºå™¨å­¦ä¹ å¸¸è§ç®—æ³• &nbsp; åŒºåŸŸåˆ†å‰²æ¦‚å¿µï¼šå°†æ•´å¹…å›¾åƒåŒºåŸŸåˆ’åˆ†ä¸ºnä¸ªå­åŒºåŸŸï¼Œæ»¡è¶³å®Œå¤‡æ€§ã€è¿é€šæ€§ã€ç‹¬ç«‹æ€§ã€äº’æ–¥æ€§ åŒºåŸŸç”Ÿé•¿æ³•ä¸€ç§ä»å•ä¸ªåƒç´ å‡ºå‘ï¼Œé€æ¸åˆå¹¶ä»¥å½¢æˆæ‰€éœ€åˆ†å‰²åŒºåŸŸçš„æŠ€æœ¯ æ ¸å¿ƒï¼šç›¸ä¼¼æ¡ä»¶çš„ç¡®å®š ç”Ÿé•¿å‡†åˆ™ï¼š åŸºäºåŒºåŸŸç°åº¦å·®ï¼ˆå­—é¢æ„æ€ï¼‰åŸºäºåŒºåŸŸå†…ç°åº¦åˆ†å¸ƒç»Ÿè®¡æ€§è´¨ æŠŠåƒç´ åˆ†æˆäº’ä¸é‡å çš„å°åŒºåŸŸï¼› æ¯”è¾ƒé‚»æ¥åŒºåŸŸçš„ç´¯ç§¯ç°åº¦ç›´æ–¹å›¾ï¼Œæ ¹æ®ç°åº¦åˆ†å¸ƒçš„ç›¸ä¼¼æ€§è¿›è¡ŒåŒºåŸŸåˆå¹¶ï¼› è®¾å®šç»ˆæ­¢å‡†åˆ™ï¼Œé€šè¿‡åå¤è¿›è¡Œä¸Šä¸€ä¸ªæ­¥éª¤ä¸­çš„æ“ä½œå°†å„ä¸ªåŒºåŸŸä¾æ¬¡åˆå¹¶ç›´åˆ°æ»¡è¶³ç»ˆæ­¢å‡†åˆ™ åŸºäºåŒºåŸŸå½¢çŠ¶æ–¹æ³•1ï¼šæŠŠå›¾åƒåˆ†å‰²æˆç°åº¦å›ºå®šçš„åŒºåŸŸï¼Œè®¾ä¸¤ç›¸é‚»åŒºåŸŸçš„å‘¨é•¿ä¸ºP1å’ŒP2ï¼ŒæŠŠä¸¤åŒºåŸŸå…±åŒè¾¹ç•Œçº¿ä¸¤ä¾§ç°åº¦å·®å°äºç»™å®šå€¼çš„é‚£éƒ¨åˆ†è®¾ä¸ºLï¼Œå¦‚æœæœ‰ï¼šï¼ˆT1ä¸ºé¢„å®šçš„é˜ˆå€¼ï¼‰ $\\frac{L}{\\min \\left\\{P_{1}, P_{2}\\right\\}}>T_{1} $ åˆ™åˆå¹¶ä¸¤åŒºåŸŸ æ–¹æ³•2ï¼šæŠŠå›¾åƒåˆ†å‰²æˆç°åº¦å›ºå®šçš„åŒºåŸŸï¼Œè®¾ä¸¤é‚»æ¥åŒºåŸŸçš„å…±åŒè¾¹ç•Œé•¿åº¦ä¸ºBï¼ŒæŠŠä¸¤åŒºåŸŸå…±åŒè¾¹ç•Œçº¿ä¸¤ä¾§ç°åº¦å·®å°äºç»™å®šå€¼çš„é‚£éƒ¨åˆ†é•¿åº¦è®¾ä¸ºLï¼Œå¦‚æœæœ‰ï¼šï¼ˆT2ä¸ºé¢„å®šé˜ˆå€¼ï¼‰ $\\frac{L}{B}>T_{2} $ åˆ™åˆå¹¶ä¸¤ä¸ªåŒºåŸŸ ç¬¬ä¸€ç§æ–¹æ³•æ˜¯åˆå¹¶ä¸¤é‚»æ¥åŒºåŸŸçš„å…±åŒè¾¹ç•Œä¸­å¯¹æ¯”åº¦è¾ƒä½éƒ¨åˆ†å æ•´ä¸ªåŒºåŸŸè¾¹ç•Œä»½é¢è¾ƒå¤§çš„åŒºåŸŸï¼Œ ç¬¬äºŒç§æ–¹æ³•åˆ™æ˜¯åˆå¹¶ä¸¤é‚»æ¥åŒºåŸŸçš„å…±åŒè¾¹ç•Œä¸­å¯¹æ¯”åº¦è¾ƒä½éƒ¨åˆ†æ¯”è¾ƒå¤šçš„åŒºåŸŸã€‚ &nbsp; åˆ†è£‚åˆå¹¶æ€æƒ³ï¼šå…ˆæŠŠå›¾åƒåˆ†æˆä»»æ„å¤§å°ä¸”ä¸é‡å çš„åŒºåŸŸï¼Œç„¶åæ ¹æ®å‡†åˆ™åˆå¹¶æˆ–è€…åˆ†è£‚è¿™äº›åŒºåŸŸï¼Œè¿­ä»£ç›´åˆ°å®ç°åˆ†å‰² &nbsp; åŸºäºå½¢æ€å­¦åˆ†æ°´å²­çš„åˆ†å‰²åˆç§°ä¸ºwatershedå˜æ¢ï¼Œæ˜¯ä¸€ç§å€Ÿé‰´å½¢æ€å­¦ç†è®ºçš„åˆ†å‰²æ–¹æ³•ã€‚å®ƒåˆ©ç”¨å›¾åƒåŒºåŸŸç‰¹æ€§æ¥åˆ†å‰²å›¾åƒï¼Œå°†è¾¹ç¼˜æ£€æµ‹ä¸åŒºåŸŸç”Ÿé•¿çš„ä¼˜ç‚¹ç»“åˆèµ·æ¥ï¼Œèƒ½å¤Ÿå¾—åˆ°å•åƒç´ çš„ã€è¿é€šçš„ã€å°é—­çš„ä¸”ä½ç½®å‡†ç¡®çš„è½®å»“ æŠŠå›¾åƒçœ‹æˆ3-Dåœ°å½¢çš„è¡¨ç¤ºï¼Œå³2-Dçš„åœ°åŸºï¼ˆå¯¹åº”å›¾åƒç©ºé—´ï¼‰åŠ ä¸Šç¬¬3ç»´çš„é«˜åº¦ï¼ˆå¯¹åº”å›¾åƒç°åº¦ï¼‰ &nbsp; &nbsp; ã€Šæ•°å­—å›¾åƒå¤„ç†ã€‹è¿™æœ¬ä¹¦çœ‹äº†ä¸ƒä¸ƒå…«å…«ï¼Œæœ‰ä¸€äº›å†…å®¹å¾ˆæœ‰è¶£ï¼ŒçŸ¥é“opencvåº“çš„ä¸€äº›åº•å±‚åŸç†è¿˜æ˜¯æœ‰å¿…è¦çš„ã€‚å…¶ä¸­æœ‰ä¸€äº›å†…å®¹ï¼Œä¾‹å¦‚ï¼šå›¾åƒç†è§£ã€æ•°å­—å›¾åƒç¼–ç æŠ€æœ¯ã€å›¾åƒæ¨¡å¼åˆ†ç±»ç­‰ï¼Œæ²¡æœ‰å†ç»§ç»­çœ‹ã€‚å¸Œæœ›å¯ä»¥åœ¨å®è·µä¸­å·©å›ºè¿™äº›çŸ¥è¯†ã€‚","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://miustannis.github.io/tags/Algorithm/"},{"name":"å›¾åƒå¤„ç†","slug":"å›¾åƒå¤„ç†","permalink":"https://miustannis.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"æ‰‹æŒçº¢å¤–çƒ­æˆåƒä»ªV2.0-åŠ è½½å›¾åƒç®—æ³•å¹¶åµŒå…¥è½»é‡çº§ç¥ç»ç½‘ç»œ","slug":"250510","date":"2025-05-10T02:05:52.000Z","updated":"2026-01-25T05:01:23.559Z","comments":true,"path":"2025/05/10/250510/","link":"","permalink":"https://miustannis.github.io/2025/05/10/250510/","excerpt":"","text":"åœ¨ä¹‹å‰çš„åŸºç¡€ä¸Šæ”¹è¿›äº†ä¸€éƒ¨åˆ† ç¡¬ä»¶ä¸ŠæŠŠä¸²å£å’ŒSWDä¸‹è½½å£å¼•å‡ºæ¥äº†ï¼Œå¤¹å…·ä¸‹è½½æœ‰ç‚¹ä¸ç¨³å®š åŒæ—¶æŠŠæ‰‹å¤´ä¸Šçš„LCDæ¨¡ç»„å’Œçº¢å¤–ä¼ æ„Ÿå™¨æ¨¡ç»„ç»™ç”¨äº†ï¼Œæ²¡æœ‰é¢å¤–è´­ä¹°ç‰©èµ„ï¼Œæˆå“å›¾å¦‚ä¸‹ï¼š å·¦è¾¹æ˜¯V1ï¼Œå³è¾¹æ˜¯V2 &nbsp; è½¯ä»¶éƒ¨åˆ†å¢åŠ äº†ä¸€äº›å›¾åƒå¤„ç†çš„åŠŸèƒ½ï¼š å›¾åƒå¹³æ»‘ï¼šåŒçº¿æ€§æ’å€¼ void interpolateTemperature(float *src, float *dst, uint8_t src_w, uint8_t src_h, uint8_t dst_w, uint8_t dst_h) &#123; float x_ratio = (float)(src_w-1) / dst_w; float y_ratio = (float)(src_h-1) / dst_h; for (int y = 0; y &lt; dst_h; y++) &#123; for (int x = 0; x &lt; dst_w; x++) &#123; float x_src = x * x_ratio; float y_src = y * y_ratio; int x0 = (int)x_src, y0 = (int)y_src; float x_diff = x_src - x0; float y_diff = y_src - y0; float val = src[y0*src_w + x0] * (1-x_diff)*(1-y_diff) + src[y0*src_w + x0+1] * x_diff*(1-y_diff) + src[(y0+1)*src_w + x0] * (1-x_diff)*y_diff + src[(y0+1)*src_w + x0+1] * x_diff*y_diff; dst[y*dst_w + x] = val; &#125; &#125; &#125; æœ€è¿‘é‚»æ’å€¼ void nearestNeighborInterpolate(float *src, float *dst, uint8_t src_w, uint8_t src_h, uint8_t dst_w, uint8_t dst_h) &#123; float x_ratio = (float)src_w / dst_w; float y_ratio = (float)src_h / dst_h; for (int y = 0; y &lt; dst_h; y++) &#123; for (int x = 0; x &lt; dst_w; x++) &#123; int src_x = (int)(x * x_ratio); int src_y = (int)(y * y_ratio); // é˜²æ­¢è¶Šç•Œ if (src_x >= src_w) src_x = src_w - 1; if (src_y >= src_h) src_y = src_h - 1; dst[y * dst_w + x] = src[src_y * src_w + src_x]; &#125; &#125; &#125; è¾¹ç¼˜æå–// Sobel ç®—å­å·ç§¯æ ¸ const int sobel_x[3][3] = &#123; &#123;-1, 0, 1&#125;, &#123;-2, 0, 2&#125;, &#123;-1, 0, 1&#125; &#125;; const int sobel_y[3][3] = &#123; &#123;-1, -2, -1&#125;, &#123; 0, 0, 0&#125;, &#123; 1, 2, 1&#125; &#125;; void detectEdges(float *input, uint8_t *output, uint8_t width, uint8_t height) &#123; for (int y = 1; y &lt; height - 1; y++) &#123; for (int x = 1; x &lt; width - 1; x++) &#123; float gx = 0, gy = 0; // 3x3 é‚»åŸŸå·ç§¯ for (int j = -1; j &lt;= 1; j++) &#123; for (int i = -1; i &lt;= 1; i++) &#123; float pixel = input[(y + j) * width + (x + i)]; gx += pixel * sobel_x[j + 1][i + 1]; gy += pixel * sobel_y[j + 1][i + 1]; &#125; &#125; uint8_t edge_strength = (uint8_t)(fabs(gx) + fabs(gy)); edge_strength = (edge_strength > 255) ? 255 : edge_strength; output[y * width + x] = edge_strength; &#125; &#125; &#125; static void drawPicture3(void) &#123; uint8_t cell_size = 4; uint8_t start_x = 0; uint8_t start_y = 16; float interpolated_temp[32 * 24]; uint8_t edge_map[32 * 24]; //åŒçº¿æ€§æ’å€¼ interpolateTemperature(tempValues, interpolated_temp, 32, 24, 32, 24); //è¾¹ç¼˜æ£€æµ‹ detectEdges(interpolated_temp, edge_map, 32, 24); //åªç»˜åˆ¶è¾¹ç¼˜ï¼ˆç™½è‰²ï¼‰ï¼Œå…¶ä½™åŒºåŸŸé»‘è‰² for (int y = 0; y &lt; 24; y++) &#123; for (int x = 0; x &lt; 32; x++) &#123; uint16_t color = ST7735_BLACK; // é»˜è®¤é»‘è‰² // å¦‚æœè¾¹ç¼˜å¼ºåº¦è¶³å¤Ÿé«˜ï¼Œåˆ™æ˜¾ç¤ºç™½è‰² if ((edge_map[y * 32 + x] > 10 ) &amp;&amp; (edge_map[y * 32 + x] &lt; 40 ))&#123; // é˜ˆå€¼å¯è°ƒ color = ST7735_WHITE; &#125; ST7735_FillRectangle( start_x + x * cell_size, start_y + (23 - y) * cell_size, cell_size, cell_size, color ); &#125; &#125; &#125; å›¾åƒè¯†åˆ«å‡†å¤‡å¾€è®¾å¤‡é‡ŒåµŒä¸€ä¸ªè½»é‡çº§çš„ç¥ç»ç½‘ç»œï¼Œå°è¯•ä¸€ä¸‹æ›´æ·±å±‚æ¬¡çš„è¾¹ç¼˜è®¡ç®— åº”ç”¨åœºæ™¯æ˜¯ç»å…¸æ‰‹åŠ¿è¯†åˆ«ï¼Œè®¾ç½®äº†1~5çš„æ•°æ®é›†ï¼Œå…¶å®å°±æ˜¯è‡ªå·±ç”¨ä¸²å£ä¼ åˆ°PCè¿›è¡Œæ•°æ®æ¸…æ´— ç½‘ç»œç»“æ„å¦‚ä¸‹ï¼š ç‰¹å¾æå–å±‚ï¼šåŒ…å«ä¸¤ä¸ªæ­¥é•¿ä¸º2çš„3x3å·ç§¯å±‚ï¼ˆé€šé“æ•°ä»1â†’4â†’8ï¼‰ï¼Œæ¯å±‚åæ¥ReLUæ¿€æ´»ï¼Œå°†è¾“å…¥ä» [1,32,24] é€æ­¥ä¸‹é‡‡æ ·è‡³ [8,8,6]ã€‚ åˆ†ç±»å™¨å±‚ï¼šå°†ç‰¹å¾å±•å¹³åï¼Œç»è¿‡ä¸€ä¸ª8ç»´çš„çº¿æ€§å±‚ï¼ˆå«ReLUï¼‰ï¼Œæœ€ç»ˆè¾“å‡º5ç±»æ¦‚ç‡ã€‚æ€»å‚æ•°é‡çº¦3KBï¼ŒRAMå ç”¨&lt;8KB åœ¨pyTorchä¸­ç§’æ­å»ºæ¨¡å‹ class MicroTempNet(nn.Module): def __init__(self, num_classes=5): super().__init__() # ç‰¹å¾æå– self.features = nn.Sequential( nn.Conv2d(1, 4, kernel_size=3, stride=2, padding=1), # [4, 16, 12] nn.ReLU(), nn.Conv2d(4, 8, kernel_size=3, stride=2, padding=1), # [8, 8, 6] nn.ReLU(), ) # åˆ†ç±»å™¨ (å‚æ•°é‡: 8*8*6*8 + 8 + 8*5 + 5 = 2,669) self.classifier = nn.Sequential( nn.Linear(8*8*6, 8), nn.ReLU(), nn.Linear(8, num_classes) ) def forward(self, x): x = x.unsqueeze(1) # æ·»åŠ é€šé“ç»´åº¦ [B,1,32,24] x = self.features(x) x = torch.flatten(x, 1) x = self.classifier(x) return x å°†æ¨¡å‹ä»¥æƒé‡æ¨¡å¼ä¿å­˜å¹¶å¯¼å‡ºåˆ°cå¤´æ–‡ä»¶ torch.save(model.state_dict(), 'micro_temp_net_params.pth') ä¹‹åå°†æ¯ä¸ªéƒ¨åˆ†è½¬Cï¼Œè¿™é‡Œå¤§é‡ä½¿ç”¨aiå·¥å…·ï¼Œè¿˜æ˜¯æ¯”è¾ƒç»™åŠ›çš„ // ReLU static void relu(float* data, int size) &#123; for (int i = 0; i &lt; size; i++) &#123; data[i] = data[i] > 0 ? data[i] : 0; &#125; &#125; // 2d convolution stride = 2 static void conv2d_stride2(const float* input, const float* weights, const float* bias, float* output, int in_channels, int out_channels, int height, int width, int kernel_size) &#123; int out_h = height / 2; int out_w = width / 2; for (int oc = 0; oc &lt; out_channels; oc++) &#123; for (int oh = 0; oh &lt; out_h; oh++) &#123; for (int ow = 0; ow &lt; out_w; ow++) &#123; float sum = bias[oc]; int ih = oh * 2; int iw = ow * 2; for (int ic = 0; ic &lt; in_channels; ic++) &#123; for (int kh = 0; kh &lt; kernel_size; kh++) &#123; for (int kw = 0; kw &lt; kernel_size; kw++) &#123; int input_idx = ic * height * width + (ih + kh) * width + (iw + kw); int weight_idx = oc * in_channels * kernel_size * kernel_size + ic * kernel_size * kernel_size + kh * kernel_size + kw; sum += input[input_idx] * weights[weight_idx]; &#125; &#125; &#125; int output_idx = oc * out_h * out_w + oh * out_w + ow; output[output_idx] = sum; &#125; &#125; &#125; &#125; // fc static void dense(const float* input, const float* weights, const float* bias, float* output, int in_features, int out_features) &#123; for (int i = 0; i &lt; out_features; i++) &#123; output[i] = bias[i]; for (int j = 0; j &lt; in_features; j++) &#123; output[i] += input[j] * weights[i * in_features + j]; &#125; &#125; &#125; // initialize void micro_temp_net_init(MicroTempNet* net, const float* conv1_w, const float* conv1_b, const float* conv2_w, const float* conv2_b, const float* fc1_w, const float* fc1_b, const float* fc2_w, const float* fc2_b) &#123; net->conv1_weight = conv1_w; net->conv1_bias = conv1_b; net->conv2_weight = conv2_w; net->conv2_bias = conv2_b; net->fc1_weight = fc1_w; net->fc1_bias = fc1_b; net->fc2_weight = fc2_w; net->fc2_bias = fc2_b; &#125; // predict void micro_temp_net_predict(const MicroTempNet* net, float* input, float* output) &#123; // [1,32,24] -> [4,16,12] float conv1_out[4 * 16 * 12]; conv2d_stride2(input, net->conv1_weight, net->conv1_bias, conv1_out, 1, 4, 32, 24, 3); relu(conv1_out, 4 * 16 * 12); // [4,16,12] -> [8,8,6] float conv2_out[8 * 8 * 6]; conv2d_stride2(conv1_out, net->conv2_weight, net->conv2_bias, conv2_out, 4, 8, 16, 12, 3); relu(conv2_out, 8 * 8 * 6); // [8,8,6] -> 384 float flattened[8 * 8 * 6]; memcpy(flattened, conv2_out, sizeof(flattened)); // 384->8 float fc1_out[8]; dense(flattened, net->fc1_weight, net->fc1_bias, fc1_out, 8 * 8 * 6, 8); relu(fc1_out, 8); // 8->5 dense(fc1_out, net->fc2_weight, net->fc2_bias, output, 8, NUM_CLASSES); &#125; ä¸»å‡½æ•°é‡ŒæŒ‰æ•°æ®é¢„å¤„ç†ï¼Œæ¨ç†ï¼Œåˆ†ç±»çš„é¡ºåºå†™äº†é€»è¾‘ï¼Œæ³¨æ„è¦å’Œpythonä¸­ä¸€æ ·æŠŠæ•°æ®å½’ä¸€åŒ– void CNN_PROC(void)&#123; //input for (int y = 0; y &lt; 24; y++) &#123; for (int x = 0; x &lt; 32; x++)&#123; input[y * 32 + x] = tempValues[(31- x) + (y * 32)]; &#125; &#125; z_score_normalize(input,768); // airun float output[NUM_CLASSES]; micro_temp_net_predict(&amp;CNNmodel, input, output); // postproc int predicted_class = 0; float max_prob = output[0]; for (int i = 1; i &lt; NUM_CLASSES; i++) &#123; if (output[i] > max_prob) &#123; max_prob = output[i]; predicted_class = i; &#125; &#125; predicted_class += 1; sprintf(tempbuffer, \"%d \" , predicted_class); ST7735_WriteString(65, 115, tempbuffer, Font_7x10, ST7735_WHITE, ST7735_BLACK); &#125; void z_score_normalize(float* input, int size) &#123; for (int i = 0; i &lt; size; i++) &#123; input[i] = (input[i] - INPUT_MEAN) / INPUT_STD; &#125; &#125; ä¸è¿‡æœ€ååˆ†ç±»æ•ˆæœæœ‰ç‚¹çƒ‚ï¼Œå°±3å’Œ5æ•ˆæœæ¯”è¾ƒå¥½ï¼Œå½“ä½œä¸€æ¬¡è¾¹ç¼˜è®¾å¤‡éƒ¨ç½²aiçš„ç»å†è¿˜æ˜¯æŒºæœ‰è¶£çš„","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://miustannis.github.io/tags/Algorithm/"},{"name":"å›¾åƒå¤„ç†","slug":"å›¾åƒå¤„ç†","permalink":"https://miustannis.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"Hexoåšå®¢æ’å…¥æ•°å­¦å…¬å¼","slug":"250327","date":"2025-03-27T04:22:29.000Z","updated":"2026-01-27T03:26:18.674Z","comments":true,"path":"2025/03/27/250327/","link":"","permalink":"https://miustannis.github.io/2025/03/27/250327/","excerpt":"","text":"ç›®å½•ï¼š Step 1 : å®‰è£…MathJaxå¼•æ“å¹¶æ›´æ¢æ¸²æŸ“å¼•æ“ï¼š Step 2 : æ›´æ–°MathJaxçš„cdné“¾æ¥ Step 3 : æ›´æ”¹éƒ¨åˆ†è½¬ä¹‰è§„åˆ™ Step 4 (å¯é€‰) : ä¸»é¢˜æœªé¢„é…ç½®ä¸‹ä½¿ç”¨Hexo-filter-mathjax æµ‹è¯• åœ¨å†™ä¸€äº›å†…å®¹æ—¶ï¼Œä¼šé‡åˆ°éœ€è¦æ·»åŠ æ•°å­¦å…¬å¼çš„åœ°æ–¹ï¼ŒHexoéƒ¨åˆ†ä¸»é¢˜ä¸æ”¯æŒå…¬å¼çš„æ¸²æŸ“ï¼Œæ¯”å¦‚æˆ‘æ­£åœ¨ä½¿ç”¨çš„viviaä¸»é¢˜ï¼Œåœ¨æŸ¥é˜…ä¸€äº›èµ„æ–™ä¹‹åï¼Œæˆ‘ä½¿ç”¨MathJaxå¼•æ“å®ç°äº†viviaä¸»é¢˜ä¸‹çš„æ•°å­¦å…¬å¼æ¸²æŸ“ã€‚ MathJaxç®€ä»‹ï¼šhttps://www.osgeo.cn/mathjax/basic/mathjax.html è¯¥å¼•æ“æ˜¯ä¸€æ¬¾å¯åœ¨æ‰€æœ‰ç°ä»£æµè§ˆå™¨ä¸­å·¥ä½œçš„å¼€æºjsæ˜¾ç¤ºå¼•æ“ï¼Œè¾…åŠ©é¡µé¢ä½œè€…ç¼–å†™å«æœ‰æ•°å­¦å…¬å¼çš„æ–‡æ¡£ Step 1 : å®‰è£…MathJaxå¼•æ“å¹¶æ›´æ¢æ¸²æŸ“å¼•æ“ï¼šâ€‹ æ“ä½œåŒ…æ‹¬å¸è½½Hexoè‡ªå¸¦çš„Hexo-mathï¼Œå¸è½½é»˜è®¤çš„å¯¹MathJaxä¸å‹å¥½çš„markedå¼•æ“ npm uninstall hexo-math --save npm install hexo-renderer-mathjax --save npm uninstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save Step 2 : æ›´æ–°MathJaxçš„cdné“¾æ¥Step 3 : æ›´æ”¹éƒ¨åˆ†è½¬ä¹‰è§„åˆ™ hexo é»˜è®¤çš„è½¬ä¹‰è§„åˆ™ä¼šå°†ä¸€äº›å­—ç¬¦è¿›è¡Œè½¬ä¹‰ï¼Œæ‰€ä»¥è¦å¯¹é»˜è®¤çš„è§„åˆ™è¿›è¡Œä¿®æ”¹ã€‚é¦–å…ˆï¼Œ æ‰“å¼€/node_modules/kramed/lib/rules/inline.js æŠŠï¼š escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_>])/, em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, æ›´æ”¹ä¸ºï¼š escape: /^\\\\([`*\\[\\]()# +\\-.!_>])/, em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, Step 4 (å¯é€‰) : ä¸»é¢˜æœªé¢„é…ç½®ä¸‹ä½¿ç”¨Hexo-filter-mathjaxå¯¹äºå·²ç»é…ç½®MathJaxçš„ä¸»é¢˜æ¥è¯´ï¼Œåœ¨ç›¸å…³configæ–‡ä»¶é‡Œæ‰“å¼€æ§ä»¶å³å¯ï¼Œå¯¹äºæœªé…ç½®çš„ä¸»é¢˜ï¼Œå¯ä»¥ä½¿ç”¨Hexo-filter-mathjaxæ¥å¸®åŠ©å®ç° Hexo-filter-mathjaxé¡¹ç›®åœ°å€ï¼šhttps://github.com/next-theme/hexo-filter-mathjax å®‰è£…ï¼š npm install hexo-filter-mathjax --save å¯¹éœ€è¦å¼€å¯çš„åšæ–‡ï¼Œåœ¨å…¶Front-Matterå¤„å¢åŠ mathjax: trueè¿™ä¸€è¡Œå³å¯ï¼Œå¦‚ï¼š --- title: xxxxxx categories: xxxxx date: xxxx-xx-xx mathjax: true --- &nbsp; æµ‹è¯•å…¬å¼ï¼š $\\Bbb{\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6} }$ $\\frak{\\cos 2\\theta = \\cos^2 \\theta - \\sin^2 \\theta = 2 \\cos^2 \\theta-1}$ çŸ©é˜µè¿ç®—ï¼š $\\left( \\begin{array}{c} s \\\\ t \\end{array}\\right)=\\left( \\begin{array}{cc} cos(b) &amp; -sin(b) \\\\ sin(b) &amp; cos(b) \\end{array}\\right)\\left( \\begin{array}{c} x \\\\ y \\end{array}\\right)$ *æ³¨æ„åˆ°æœ‰çš„cdnç‰ˆæœ¬MathJaxæ¡†æ¶ä¸‹å…¬å¼å­—ä½“å¯¹è¡Œé—´å…¬å¼æœ‰ä¸€å®šå½±å“ï¼Œå¯èƒ½ä¼šä¸€äº›å­—ä½“ä¼šè¢«æ¸²æŸ“æˆä¸»é¢˜ç›¸åŒå­—ä½“ï¼Œä¸”ç§»åŠ¨ç«¯ä¸èƒ½å¾ˆå¥½åœ°æ˜¾ç¤º å‚è€ƒèµ„æ–™ï¼š https://www.cnblogs.com/wangxin37/p/8185688.html https://heartlessly.github.io/others/latex-mathjax-gong-shi-zi-ti-mei-hua/","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://miustannis.github.io/tags/Hexo/"}]},{"title":"Harvard CS50 Study Log","slug":"250306","date":"2025-03-06T12:39:18.000Z","updated":"2025-07-04T07:49:40.106Z","comments":true,"path":"2025/03/06/250306/","link":"","permalink":"https://miustannis.github.io/2025/03/06/250306/","excerpt":"","text":"ç›®å½•ï¼š Lecture 0 Scratch Lecture 1 C Lecture 2 Arrays Lecture 3 Algorithms Lecture 4 Memory Lecture 5 Data Structures Lecture 6 Python, Artificial Intelligence Lecture 7 SQL Lecture 8 HTML, CSS, JavaScript Lecture 9 Flask Lecture 10 Cybersecurity Lecture 0 ScratchLecture 1 CLecture 2 ArraysLecture 3 Algorithms Time Complexity is an important metric used to measure the relationship between the running time of an algorithm and the size of the input. It describes how the execution time of an algorithm increases as the input size grows. Time complexity helps us assess the efficiency of an algorithm under different problem sizes, allowing us to choose the most appropriate algorithm. Time complexity is usually expressed using Big $O$ notation. selection sort: $ O(n^2) $ bubble sortï¼š $ O(n^2) $ insertion sortï¼š $ O(n^2) $ merge sortï¼š $ O(nlogn) $ &nbsp; Lecture 4 Memory This section basically start from the pixels which formed by RGB code, for example 0xFF0000(using hexadecimal or base16 â€” 0x) . Why hexadecimal ? Using binary, it takes 4 bits to represent 16 possibilities. Using hexadecimal, 4 bits -&gt; one digit, thatâ€™s easier. So one byte, two of them, is a common unit of measurement. Then it comes to the tool or variable commonly used in C language which is pointer. A pointer is an address. int n = 50; printf(\"%i\\n\", n); // --50 printf(\"%p\\n\", &amp;n); // -- some address //the following sytanx are slightly differrent! int *p = &amp;n; // also int* p = &amp;n; they are the same, to specify a data type printf(\"%p\\n\", p);// -- same address above printf(\"%i\\n\", *p);// *p: go there --50 â€œ&amp;aâ€ means the address of a, â€œ*â€œ is a dereference operator, which allows you to take an address, and go to it. By convention, pointers take up more space, they account for 8 bytes. 32-bit machine differs from 64-bit machine in the width of address bus, where 64-bit machine has larger memory. Strings, arrays of char so to speak, live at some address. They are continuous in memory from left to right, with 1 byte from each other. string s = \"CS50!\"; printf(\"%s\\n\",s);//--CS50! printf(\"%p\\n\",s);//--some address printf(\"%p\\n\",&amp;s[0]);//--address same as above printf(\"%p\\n\",&amp;s[1]);//--address above + 0x1 //technically string is not an actual datatype string s = \"CS50!\"; char* s = \"CS50!\"; //typedef char* string; !! //char* s = \"CS50!\"; \"&amp;\" is not needed here because CLANG puts the address of the first char in the variable when a double quote shows up. s is technically a pointer, to find the beginning of the string. pointer arithmetic: doing math on addresses char *s = \"CS50\"; printf(\"%c\\n\", s[0]); // -- C printf(\"%c\\n\", s[1]); // -- S printf(\"%c\\n\", *s); // -- C printf(\"%c\\n\", *(s+1)); // -- S memory allocate: FREE &amp; MALLOC ç‰¹æ€§ æ ˆï¼ˆStackï¼‰ å †ï¼ˆHeapï¼‰ ç®¡ç†æ–¹å¼ è‡ªåŠ¨ï¼ˆç¼–è¯‘å™¨/æ“ä½œç³»ç»Ÿï¼‰ æ‰‹åŠ¨ï¼ˆç¨‹åºå‘˜mallocï¼‰ åˆ†é…é€Ÿåº¦ å¿«ï¼ˆç›´æ¥ç§»åŠ¨æŒ‡é’ˆï¼‰ æ…¢ï¼ˆéœ€è¦æŸ¥æ‰¾å¯ç”¨å†…å­˜ï¼‰ ç”Ÿå‘½å‘¨æœŸ å‡½æ•°è°ƒç”¨ç»“æŸå°±é‡Šæ”¾ æ˜¾å¼é‡Šæ”¾ï¼ˆfreeï¼‰ å¤§å°é™åˆ¶ è¾ƒå°ï¼ˆå‡ MBï¼‰ è¾ƒå¤§ï¼ˆå—ç³»ç»Ÿå†…å­˜é™åˆ¶ï¼‰ å­˜å‚¨å†…å®¹ å±€éƒ¨å˜é‡ã€å‡½æ•°è°ƒç”¨ä¿¡æ¯ åŠ¨æ€åˆ†é…çš„å¯¹è±¡ã€å¤§å‹æ•°æ® ç¢ç‰‡é—®é¢˜ æ—  å¯èƒ½äº§ç”Ÿå†…å­˜ç¢ç‰‡ //program for string operating #include &lt;ctype.h> #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;cs50.h> int main(void) &#123; char *s = get_string(\"s: \"); // fuction from cs50.h char *t = malloc(strlen(s) + 1); // malloc : memory allocate // return the first address of the memory if(t == NULL)&#123; return 1; &#125; // \"NULL\" no memory available for(int i = 0, n = strlen(s); i&lt;=n ; i++)&#123; t[i] = s[i]; &#125; strcpy(t,s);// equivalent if (strlen(t) > 0)&#123; t[0] = toupper(t[0]); &#125; printf(\"%s\\n\", s); printf(\"%s\\n\", t); free(t); //free the memory mallocatedï¼Œalways remember to free return 0; &#125; // Upper the first Character valgrind: prog that check memory mistake garbage values matter of scope â€œ{ }â€ passing by reference void swap( int* a , int* b)&#123; int temp = *a; *a = *b; *b = temp &#125; File I/O //program for file writing --phonebook #include &lt;cs50.h> #include &lt;stdio.h> #include &lt;string.h> int main(void) &#123; FILE *file = fopen(\"phonebook.csv\", \"a\"); if (file == NULL)&#123; return 1; &#125; char *name = get_string(\"Name: \"); char *number = get_string(\"Number: \"); fprintf(file, \"%s,%s\\n,name,number\"); fclose(file); &#125; //program for file copy #include &lt;stdio.h> #include &lt;stdint.h> typedef uint8_t BYTE; int main(int argc, char *argv[]) // use command line &#123; FILE *src = fopen(argv[1], \"rb\"); FILE *dst = fopen(argv[2], \"wb\"); BYTE b; while (fread(&amp;b, sizeof(b), 1, src) != 0)&#123; fwrite(&amp;b, sizeof(b), 1, dst); &#125; fclose(dst); fclose(src); &#125; &nbsp; Lecture 5 Data Structures abstract data types queues: FIFO (enqueue &amp; dequeue) stacks: LIFO (like email systems, push &amp; pop) //prog for dynamic memory allocate without linked list #include &lt;stdio.h> #include &lt;stdlib.h> int main(void) &#123; int *list = malloc(3 * sizeof(int)); if (list == NULL)&#123; return 1; &#125; // if more space is needed to be allocated dynamicly int *tmp = malloc(4 * sizeof(int)); if (tmp == NULL)&#123; // free the original memory free(list); return 1; &#125; for (int i = 0; i &lt; 3; i++)&#123; tmp[i] = list[i]; &#125; tmp[3] = 4; // free the original memory free(list); // reorientation list = tmp; &#125; linked list //template typedef struct node &#123; int number; struct node *next; &#125; node; //create a linked list with one node node *list = NULL; node *n = malloc(sizeof(node)); n -> number = 1; //(*n).number = 1; n -> next = NULL; list = n; // enter a linked list and print #include &lt;stdio.h> #include &lt;stdlib.h> typedef struct node&#123; int number; struct node *next; &#125; node; int main (int argc, char *argv[]) &#123; node *list = NULL; for (int i = 1; i &lt; argc; i++)&#123; int number = atoi(argv[i]); node *n = malloc(sizeof(node)); if(n == NULL)&#123; //Free memory thus far return 1; &#125; n->number = number; n->next = list; list = n; &#125; //print whole list node *ptr = list; while (ptr != NULL)&#123; printf(\"%i\\n\",ptr->number); ptr = ptr->next; &#125; &#125; adding nodesï¼š $ O(1) $ searching nodesï¼š $ O(n) $ // enter a reverse linked list and print #include &lt;stdio.h> #include &lt;stdlib.h> typedef struct node&#123; int number; struct node *next; &#125; node; int main (int argc, char *argv[]) &#123; node *list = NULL; for (int i = 1; i &lt; argc; i++)&#123; int number = atoi(argv[i]); node *n = malloc(sizeof(node)); if(n == NULL)&#123; //Free memory thus far return 1; &#125; n->number = number; n->next = NULL; //if list is empty if (list == NULL )&#123; list = n; &#125; else&#123; for (node *ptr = list; ptr != NULL ; ptr = ptr->next)&#123; if(ptr->next == NULL)&#123; ptr->next = n; break; &#125; &#125; &#125; &#125; //print whole list node *ptr = list; while (ptr != NULL)&#123; printf(\"%i\\n\",ptr->number); ptr = ptr->next; &#125; &#125; adding nodesï¼š $ O(n) $ // enter a sequenced linked list #include &lt;stdio.h> #include &lt;stdlib.h> typedef struct node&#123; int number; struct node *next; &#125; node; int main (int argc, char *argv[]) &#123; node *list = NULL; for (int i = 1; i &lt; argc; i++)&#123; int number = atoi(argv[i]); node *n = malloc(sizeof(node)); if(n == NULL)&#123; //Free memory thus far return 1; &#125; n->number = number; n->next = NULL; //if list is empty if (list == NULL )&#123; list = n; &#125; // if number belongs at beginning of the list else if (n->number &lt; list->number)&#123; n->next = list; list = n; &#125; // if number belongs later of the list else&#123; for (node *ptr = list; ptr != NULL ; ptr = ptr->next)&#123; // at end if(ptr->next == NULL)&#123; ptr->next = n; break; &#125; //in middle if (n->number &lt; ptr->next->number)&#123; n->next = ptr->next; ptr->next = n; break; &#125; &#125; &#125; &#125; //print whole list node *ptr = list; while (ptr != NULL)&#123; printf(\"%i\\n\",ptr->number); ptr = ptr->next; &#125; &#125; adding nodesï¼š $ O(n) $ trees binary search trees typedef struct node&#123; int number; struct node *left; struct node *right; &#125; node; searching nodesï¼š $ O(logn) $ dictionaries hashing : mapping objects into finite number of outputs hashing function hash tables: array of linked lists collision expectation $ O(n/k) - O(n) $ tries: a tree of arrays $ O(k)- O(1)$ &nbsp; Lecture 6 Python, Artificial Intelligence Python manages your memory automatically. It may take more memory than C. # python version of hash table in Problem set 5 words = set() def check(word): return word.lower() in words def load(dictionary): with open(dictionary) as file: words.update(file.read().splitlines()) return True def size(): return len(words) def unload(); return True Python has greater ecosystem for developers, basically more libs. Example: Face detection common IO syntax, you donâ€™t have to specify the type of your variables answer = input(\"input:\") print(\"output, \" + answer) print(\"output,\", answer) print(f\"output,&#123;answer&#125;\") #type: bool float int str list set ... intent matters object oriented program(OOP): s = input(\"opinion: \") s = s.lower() # s = input(\"opinion: \").lower() if s in [\"y\",\"yes\"]: print(\"agreed\", end = \"\") elif s in [\"n\",\"no\"]: print(\"not agreed\") #loop for _ in range(3): print(\"test\") #function exception def get_int(prompt): while True: try: return int(input(prompt)) except ValueError: print(\"not an integer\") #for loop can end with an else people = [ &#123;\"name\":\"carter1\",\"number\":\"+1-555-986-1004\"&#125; &#123;\"name\":\"carter2\",\"number\":\"+1-555-986-1004\"&#125; &#123;\"name\":\"carter3\",\"number\":\"+1-555-986-1004\"&#125; ] name = input(\"Name: \") for person in people: if person[\"name\"] == name: number = person[\"number\"] print(f\"Found &#123;number&#125;\") break else: print(\"Not found\") the Artificial Intelligence part is more â€œintroductoryâ€ and basic for learning prompt engineering minimax behavior machine learning reinforce learning (in robotics) explore vs exploit. deep learning generative artificial intelligence(large language models\\transformer\\attention values) &nbsp; Lecture 7 SQL SQL: a database-centric language (Structured Query Language) flat file database example: csv #csv example import csv with open(\"favorites.csv\",\"r\") as file: reader = csv.DictReader(file) counts = &#123;&#125; for row in reader: favorite = row[\"language\"] if favorite in counts: counts[favorite] += 1 else: counts[favorite] = 1 for favorite in sorted(counts, key = counts.get): print(f\"&#123;favorite&#125;: &#123;counts[favorite]&#125;\") relational database: CRUD(create read update delete || insert drop) this lecture uses sqlite3, for mobile database. $ sqlite3 favorites.db sqlite&gt; .mode csv sqlite&gt; .import favorites.csv favorites --import csv to table sqlite&gt; .quit sqlite&gt; .schema --a sqlite command that shows the schema of the database sqlite&gt; SELECT * FROM favorites; --show entire content of the table sqlite&gt; SELECT language FROM favorites LIMIT 10; --show seletced content of the table sqlite&gt; SELECT COUNT(*) FROM favorites; --total count sqlite&gt; SELECT COUNT(DISTINCT(language)) FROM favorites; --type count sqlite&gt; SELECT COUNT(*) FROM favorites WHERE language &#x3D; &#39;C&#39;; sqlite&gt; SELECT COUNT(*) FROM favorites WHERE language &#x3D; &#39;C&#39; AND problem &#x3D; &#39;Hello, World&#39;; sqlite&gt; SELECT language, COUNT(*) FROM favorites GROUP BY language; --works as python code above sqlite&gt; INSERT INTO favotites(language, problem) VALUES(&#39;SQL&#39;, &#39;fiftyville&#39;); --appending a new row to table sqlite&gt; DELETE FROM favorites WHERE Timestamp IS NULL;--delete row sqlite&gt; UPDATE favorites SET language &#x3D; &#39;SQL&#39;, problem &#x3D; &#39;fiftyville&#39;;--update and now all content has been changed which can be justified by WHERE...(condition) link different tables together one-to-one: primary key &amp; foreign key -- IMDb example sqlite&gt; SELECT * FROM shows WHERE id IN ...&gt;(SELECT show_id FROM ratings WHERE rating &gt;&#x3D; 6.0) how to join two tables that have related keys? -- syntax &#39;JOIN&#39; sqlite&gt; SELECT * FROM shows JOIN ratings ON shows.id &#x3D; ratings.show_id WHERE rating&gt;&#x3D; 6.0 LIMIT 10; link different tables together: one-to-many ï¼Œmany-to-many â€‹ just nested snytax. SQL injection attack just use placeholders and sanitize customerâ€™s inputs &nbsp; Lecture 8 HTML, CSS, JavaScript routes &amp; packetsï¼›a pair of protocols: TCP/IP IPv4: #.#.#.# (0~255) 32 bits TCP: use sequence numbers to help servers multiplex, port numbers (80: HTTP 443: HTTPS) DNS (domain name system) servers domain name -&gt; IP address buy a domain name: pay someone(è¿è¥å•†) to associate an IP address with your domain name DHCP (dynamic host configuration protocol) è‡ªåŠ¨ä¸ºè®¾å¤‡åˆ†é…åœ°å€ HTTP (hypertext transmit protocol) HTTPS (hypertext transmit protocol secure) Internet protocol that allows a web browser to request and receive information from a web server HTML: (hypertext marker language) a really easy language that you can learn in 30 minutes. VSCode makes it even more convenient. but it can take a lot of effort to make good websites. tags &amp; attributes: &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;!--html: tag lang = \"en\": attributes --> &lt;head> &lt;title> title &lt;/title> &lt;/head> &lt;body> body &lt;/body> &lt;/html> regular expressions: æ­£åˆ™è¡¨è¾¾å¼ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions you can change your local copy of html by using developer tools CSS: (Cascading Style Sheets) properties: example &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;title>title&lt;/title> &lt;/head> &lt;body style = \"text-align: center\"> &lt;p style = \"font-size: large\"> John Harvard &lt;/p> &lt;p style = \"font-size: medium\"> Welcome to my homepage &lt;/p> &lt;p style = \"font-size: small\"> Copyright &amp;#169; John Harvard &lt;/p> &lt;/body> &lt;/html> classes: your own style or style from third libraries &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;style> .centered&#123; text-align: center; &#125; .large&#123; font-size: large; &#125; .medium&#123; font-size: medium; &#125; .small&#123; font-size: small; &#125; &lt;/style> &lt;title>title&lt;/title> &lt;/head> &lt;body class = \"centered\"> &lt;head class = \"large\"> John Harvard &lt;/head> &lt;main class = \"medium\"> Welcome to my homepage &lt;/main> &lt;footer class = \"small\"> Copyright &amp;#169; John Harvard &lt;/footer> &lt;/body> &lt;/html> â€‹ æ ·å¼å¯ä½¿ç”¨å¤–é“¾ â€‹ #+â€¦ : ID JavaScript &nbsp; Lecture 9 Flask flask a python third party library for web microframework linking static(html) &amp; dynamic(python) files. We use the syntax â€œJINJAâ€ to customize and formalize the outlook of the web. Following the lecture I made a simple web application to greet users, the GitHub link is https://github.com/miustannis/flask-greeting-web.git more web app examples There two other web examples for sports register and library system, which are more realistic with more functions and more html files. Data can be managed in a better way using SQL, other than just in SRAM. cookies tools that websites use to keep staying stateful. Server needs to remember something about the user, cookies will be sent back to server by browsers every time a user log in. problems: cookies may be used for ads and tracking. &nbsp; Lecture 10 Cybersecurity passwords brute-force attack two-factor authentication (mostly hardware equipment) one-time passwords server uses hash function to compare passwords cryptography: public key &amp; private key (HTTPS) passkeys: generate public key and send it to the company, and a private one for verifying your signature combining the public key. secure deletion -&gt; full disk encryption *çœ‹æ­¤è¯¾ç¨‹ä»¥æ¸©ä¹ basic codingå’Œè¡¥å……ä¸€äº›è®¡ç®—æœºæ€ç»´ï¼Œè€å¸ˆè®²çš„å¾ˆæœ‰æ¿€æƒ…ï¼Œæ—¶é—´èŠ±çš„è¿˜ç®—æ¯”è¾ƒæœ‰ä»·å€¼ ______ | see you | ====== \\ \\ \\ \\ / \\\\ //\\\\ |\\\\___/| / \\\\// \\\\\\\\ /0 0 \\\\__ / // | \\\\ \\\\ / / \\\\/_/ // | \\\\ \\\\ \\@_^_\\@'/ \\\\/_ // | \\\\ \\\\ //_^_/ \\\\/_ // | \\\\ \\\\ ( //) | \\\\/// | \\\\ \\\\ ( / /) _|_ / ) // | \\\\ _\\\\ ( // /) '/,_ _ _/ ( ; -. | _ _\\\\.-~ .-~~~^-. (( / / )) ,-&#123; _ `-.|.-~-. .~ `. (( // / )) '/\\\\ / ~-. _ .-~ .-~^-. \\\\ (( /// )) `. &#123; &#125; / \\\\ \\\\ (( / )) .----~-.\\\\ \\\\-' .~ \\\\ `. \\\\^-. ///.----..> \\\\ _ -~ `. ^-` ^-_ ///-._ _ _ _ _ _ _&#125;^ - - - - ~ ~-- ,.-~ /.-~","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://miustannis.github.io/tags/CS/"}]},{"title":"åŸºäºMLX90640çš„æ‰‹æŒçº¢å¤–çƒ­æˆåƒä»ª","slug":"250226","date":"2025-02-26T02:05:52.000Z","updated":"2025-08-20T04:15:07.445Z","comments":true,"path":"2025/02/26/250226/","link":"","permalink":"https://miustannis.github.io/2025/02/26/250226/","excerpt":"","text":"é¡¹ç›®èƒŒæ™¯ï¼š DIYå¥½ç©æ ç”µè·¯å·¥ä½œæ—¶æœ‰æ—¶éœ€è¦æ£€æŸ¥å…ƒä»¶å‘çƒ­æƒ…å†µï¼Œä½†ç”¨æ‰‹è§¦æ‘¸å…ƒä»¶æœ‰ä¸€å®šçš„é£é™©ï¼Œå› æ­¤éœ€è¦ä¸€ç§æ— æ¥è§¦å¼çš„å¤šç‚¹æµ‹æ¸©è®¾å¤‡ äºæ˜¯å¼€å§‹äº†è§£åˆ°çƒ­æˆåƒè¿™ä¸ªæµ‹æ¸©æ–¹å¼ï¼Œä»¥ä¸‹æ˜¯è½¯ç¡¬ä»¶æ–¹æ¡ˆ æ–¹æ¡ˆï¼šç¡¬ä»¶éƒ¨åˆ†â€‹ é‡‡ç”¨ä¸Šä¸‹ä¸¤å—æ¿å­å¯¹æ’ç»„åˆï¼Œä¸ºäº†å‡å°‘å¤æ‚åº¦ï¼Œç•™äº†æ’æ¯æ–¹ä¾¿ç›´æ’LCDä¸ä¼ æ„Ÿå™¨æ¨¡ç»„ã€‚ BOARD1: MCUä¸å¤–è®¾ é‡‡ç”¨STM32F407ä½œä¸ºä¸»æ§ï¼Œ512KB Flashï¼Œå…¶å®æ²¡ç‰¹åˆ«æ³¨æ„é€‰å‹ï¼Œåªæ˜¯æ‰‹ä¸Šæœ‰è¿™ä¸ªå¼€å‘æ¿ï¼Œè¦å‹ç¼©æˆæœ¬çš„è¯ç”¨å…¶ä»–å‹å·ä¹Ÿå¯ä»¥ çº¢å¤–ä¼ æ„Ÿæ¨¡ç»„ä¸ºMLX90640 BAAï¼Œè¿™ä¸ªä»·æ ¼æ¯”è¾ƒè´µï¼Œæ¯”å…¶ä»–å…ƒä»¶åŠ èµ·æ¥éƒ½è´µ å±å¹•æ¨¡ç»„ä¸º1.44å¯¸TFT-LCDï¼Œä¹Ÿæ˜¯ç°æˆçš„ï¼Œä¹°äº†ä¿©è¿˜å‰©ä¸€ä¸ªï¼Œä¸‹æ¬¡åšåˆ«çš„ä¸œè¥¿çš„æ—¶å€™ç»™ç”¨äº†å§ ç•™äº†ä¸²å£æµ‹è¯•ç‚¹å’Œçƒ§å½•æµ‹è¯•ç‚¹ BOARD2: POWER 3.7Vé”‚ç”µæ± ä¾›ç”µï¼Œå¯é€šè¿‡USBæ¥å£ç»è¿‡LGS4084Hç”µæºç®¡ç†èŠ¯ç‰‡ç»™é”‚ç”µæ± å……ç”µ ç»è¿‡ä¸€ä¸ªLDOç¨³åˆ°3.3Vç»™MCUæ•´ä½“ä¾›ç”µï¼ŒVDDAå’ŒVCCç”¨ç£ç æ»¤æ³¢éš”ç¦»äº†ä¸€ä¸‹ ç”µæºæ¿åç»­æ¶‰åŠé”‚ç”µæ± ä¾›ç”µDIYçš„å€’æ˜¯å¯ä»¥ç»§ç»­æ²¿ç”¨ ç«‹åˆ›æ‰“æ ·PCBï¼Œè‡ªå·±è´´ç‰‡ï¼ŒPCBæ¿æ¡†ç•™äº†ä¸€äº›M3èºå­”æ–¹ä¾¿ç»„è£…ã€‚ è½¯ä»¶éƒ¨åˆ†é€šè®¯æ¥å£æ¶‰åŠIICä¸SPIï¼Œä»¥åŠå›¾åƒæµ‹è¯•çš„æ—¶å€™ç”¨äº†ä¸€ä¸‹UARTï¼Œå‡æ¯”è¾ƒåŸºç¡€ã€‚ä½¿ç”¨ç¡¬ä»¶IICè¿›è¡Œä¼ æ„Ÿå™¨æ¨¡ç»„ä¸MCUé—´çš„é€šä¿¡ï¼Œæ¨¡ç»„å®˜æ–¹æä¾›äº†æ¥å£å¯è°ƒç”¨ï¼Œå¯è¯»å–æ¸©åº¦å€¼ã€‚RGBè½¬æ¢ç”¨äº†å¼€æºçš„å‡½æ•°ï¼š /*pass in value and figure out R G B several published ways to do this I basically graphed R G B and developed simple linear equations again a 5-6-5 color display will not need accurate temp to R G B color calculation equations based on http://web-tech.ga-usa.com/2012/05/creating-a-custom-hot-to-cold-temperature-color-gradient-for-use-with-rrdtool/index.html */ static uint16_t TempToColor(float val)&#123; red = constrain(255.0f / (c - b) * val - ((b * 255.0f) / (c - b)), 0, 255); if ((val > minTemp) &amp; (val &lt; a)) &#123; green = constrain(255.0f / (a - minTemp) * val - (255.0f * minTemp) / (a - minTemp), 0, 255); &#125; else if ((val >= a) &amp; (val &lt;= c)) &#123; green = 255; &#125; else if (val > c) &#123; green = constrain(255.0f / (c - d) * val - (d * 255.0f) / (c - d), 0, 255); &#125; else if ((val > d) | (val &lt; a)) &#123; green = 0; &#125; if (val &lt;= b) &#123; blue = constrain(255.0f / (a - b) * val - (255.0f * b) / (a - b), 0, 255); &#125; else if ((val > b) &amp; (val &lt;= d)) &#123; blue = 0; &#125; else if (val > d) &#123; blue = constrain(240.0f / (maxTemp - d) * val - (d * 240.0f) / (maxTemp - d), 0, 240); &#125; // use the displays color mapping function to get 5-6-5 color palet (R=5 bits, G=6 bits, B-5 bits) return BSP_LCD_GetColor565(red, green, blue); &#125; è¯¥ä¼ æ„Ÿå™¨æˆå›¾32x24åƒç´ ï¼Œè€Œä½¿ç”¨çš„LCDæ˜¯128x128çš„ï¼Œäºæ˜¯æˆ‘ç”¨4ä¸ªåƒç´ ä½œä¸ºä¸€ä¸ªå¤§åƒç´ æ¥å¡«å……ï¼Œå¹¶å¢åŠ äº†ä¸€ä¸ªå›¾ä¾‹å’Œä¸€ä¸ªæœ€å¤§æœ€å°å€¼æ¥æä¾›é‡åŒ–ï¼Œå¹¶å¡«å……ä¸€ä¸‹å±å¹•ç•™ç™½ static void drawPicture(void) &#123; uint8_t cell_size = 4; // æ ¼å­å¤§å° 4x4 uint8_t start_x = 0; // æ°´å¹³å±…ä¸­ï¼ˆ128 - 32*4 = 0ï¼‰ uint8_t start_y = 16; // å‚ç›´å±…ä¸­ï¼ˆ(128 - 24*4)/2 = 16ï¼‰ for (y = 0; y &lt; 24; y++) &#123; for (x = 0; x &lt; 32; x++) &#123; ST7735_FillRectangle( start_x + x * cell_size, start_y + (23 - y) * cell_size, cell_size, cell_size, TempToColor(tempValues[(31- x) + (y * 32)]) ); &#125; &#125; &#125; static void drawLegend(void) &#123; uint8_t legend_height = 5; // å›¾ä¾‹é«˜åº¦ï¼ˆåƒç´ ï¼‰ uint8_t legend_y = 0; // å›¾ä¾‹é¡¶éƒ¨ä½ç½®ï¼ˆy=0ï¼‰ uint8_t legend_width = 120; // å›¾ä¾‹å®½åº¦ï¼ˆç•™å·¦å³è¾¹è·ï¼‰ uint8_t start_x = 4; // å›¾ä¾‹å·¦ä¾§èµ·å§‹ä½ç½®ï¼ˆx=4ï¼‰ // ç»˜åˆ¶æ¸©åº¦é¢œè‰²æ¸å˜æ¡ï¼ˆæ°´å¹³æ–¹å‘ï¼‰ float temp_range = maxTemp - minTemp; for (uint8_t x = 0; x &lt; legend_width; x++) &#123; float temp = minTemp + temp_range * (x / (float)legend_width); uint16_t color = TempToColor(temp); // ç»˜åˆ¶æ°´å¹³çº¿ï¼ˆä»å·¦åˆ°å³ï¼‰ ST7735_DrawLine(start_x + x, legend_y, start_x + x, legend_y + legend_height, color); &#125; // æ˜¾ç¤ºæœ€å°/æœ€å¤§æ¸©åº¦æ ‡ç­¾ // memset(tempBuffer, 0, sizeof(tempBuffer)); sprintf(tempBuffer, \"&lt;%2.1f \", minTemp); ST7735_WriteString(2, 115, tempBuffer, Font_7x10, ST7735_WHITE, ST7735_BLACK); //// memset(tempBuffer, 0, sizeof(tempBuffer)); sprintf(tempBuffer, \"%2.1f> \", maxTemp); ST7735_WriteString(90, 115, tempBuffer, Font_7x10, ST7735_WHITE, ST7735_BLACK); &#125; æœ€ååœ¨ä¸»å¾ªç¯é‡Œè½®è¯¢å°±å¯ä»¥äº†ï¼Œå±å¹•åˆ·æ–°ç‡ä¸€èˆ¬ï¼Œçœ¨çœ¼è¡¥å¸§ã€‚ æ•´ä½“è½¯ä»¶éƒ¨åˆ†æ¯”è¾ƒæ¸…æ™°ï¼Œæœ¬æ¥æƒ³åŠ ä¸€äº›æŒ‰é”®äº¤äº’ï¼Œä¿®æ”¹é¢œè‰²èŒƒå›´ï¼Œå­˜å‚¨å›¾ç‰‡åˆ°å¤–éƒ¨flashä¹‹ç±»çš„åŠŸèƒ½ï¼Œç„¶åæ‡’äº†ã€‚ åç»­å­¦äº†æ“ä½œç³»ç»Ÿå’ŒLVGLåº“ä¹‹åå†æç‚¹å¥½ç©çš„å§ï¼Œæ„Ÿè§‰å¤§éƒ¨åˆ†DIYåº”ç”¨è£¸æœºå®Œå…¨å¤Ÿäº†â€¦ å°é—®é¢˜åˆé›†ï¼šproblem1ï¼šä½¿ç”¨ST-Linkä¸‹è½½è¿‡ä¸€æ¬¡ç¨‹åºåå‘ç°æ— æ³•ç»§ç»­ä¸‹è½½ æ£€æŸ¥è®¾å¤‡ç®¡ç†å™¨ï¼Œç¡®ä¿æœ‰æ­£ç¡®çš„ST-Linké©±åŠ¨ æ£€æŸ¥Keilè½¯ä»¶é…ç½®ï¼Œç¡®ä¿å¯¼å…¥æ­£ç¡®çš„å‹å·ç‰ˆæœ¬ æ£€æŸ¥å¼•è„šé…ç½®ï¼Œå‘ç°é—®é¢˜ï¼š â€‹ é…ç½®çš„IICé€šä¿¡å¼•è„šå ç”¨äº†SWDä¸‹è½½å¼•è„šï¼ˆSTM32é»˜è®¤çš„PA13 &amp;PA14ï¼‰ï¼Œå¼•è„šè¾“å…¥è¾“å‡ºæ¨¡å¼ä¸é€‚é…ï¼Œæ˜¾ç„¶åç»­æ— æ³•ä¸‹è½½ï¼Œé‚æ”¹ä¹‹ï¼Œé—®é¢˜è§£å†³ã€‚ï¼ˆå›¾ç¤ºä»…ä¾›å‚è€ƒï¼‰ problem2ï¼šHardFaultä¸­æ–­è§¦å‘æ ˆç©ºé—´ä¸è¶³ï¼Œå¤šåˆ†é…ç‚¹å°±ok","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"Xiaomiè·¯ç”±å™¨BE3600å¿«é€Ÿæ•‘ç –","slug":"250213","date":"2025-02-13T10:25:24.000Z","updated":"2025-08-22T15:43:45.354Z","comments":true,"path":"2025/02/13/250213/","link":"","permalink":"https://miustannis.github.io/2025/02/13/250213/","excerpt":"","text":"å®¶é‡Œçš„è·¯ç”±å™¨å˜ç –äº†ï¼ˆå…·ä½“åŸå› ä¸æ¸…æ¥šï¼‰ æŒ‡ç¤ºç¯ç”±è“è‰²å¸¸äº®å˜æˆæ©™è‰²å¸¸äº®ï¼Œå¯¹äºå®¶ç”¨è·¯ç”±å™¨è¿™ç§æ¶ˆè´¹ç”µå­äº§å“ï¼Œä¸€èˆ¬é‡å¯ä¸€ä¸‹èƒ½è§£å†³90%çš„æ•…éšœ ä½†å¿ƒè¡€æ¥æ½®æƒ³è¯•ä¸€ä¸‹ç»™å®ƒåˆ·ä¸ªæœº å‹å·æ˜¯è¿™ä¸ªï¼š åˆ·æœºéœ€è¦ä¸€æ ¹ç½‘çº¿ï¼ŒPCï¼Œä»¥åŠå˜ç –çš„è·¯ç”±å™¨ æ­¥éª¤å¦‚ä¸‹ï¼š åœ¨ç½‘å€MiWiFiä¸­æ‰¾åˆ°åˆ·æœºè½¯ä»¶ä¸å¯¹åº”å‹å·çš„ROMå›ºä»¶ å…³é—­PCçš„é˜²ç«å¢™ï¼Œå°†ç½‘çº¿è¿æ¥è‡³è·¯ç”±å™¨çš„LANå£ï¼Œæœ¬å‹å·WANä¸LANå£äºŒåˆä¸€äº†,éšä¾¿æ‰¾ä¸ªå£æ’ä¸Šå°±è¡Œ æ‰“å¼€åˆ·æœºè½¯ä»¶å¹¶è½½å…¥å¯¹åº”çš„å›ºä»¶ ç”¨å·¥å…·æŒ‰ä½è·¯ç”±å™¨çš„reseté”®åé€šç”µæºï¼Œè¿™ä¸€æ­¥éå¸¸åƒä¹‹å‰ç»™å•ç‰‡æœºå†…éƒ¨flashè¿›è¡ŒISPä¸‹è½½ç¨‹åºçš„æ­¥éª¤ï¼Œå› æ­¤æ„Ÿè§‰å¾ˆç†Ÿæ‚‰ å¾…æŒ‡ç¤ºç¯é—ªçƒåæ¾å¼€reseté”®ï¼Œå›ºä»¶å¼€å§‹ä¸‹è½½ è·¯ç”±å™¨å˜ä¸ºè“ç¯é—ªçƒï¼Œæ­¤æ—¶å·²ç»åˆ·æœºå®Œæˆï¼Œå½“æ–°è·¯ç”±å™¨ç”¨å°±è¡Œ","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"STM32é…ç½®ç¬”è®°","slug":"241121","date":"2024-11-21T10:45:34.000Z","updated":"2025-08-19T15:37:52.826Z","comments":true,"path":"2024/11/21/241121/","link":"","permalink":"https://miustannis.github.io/2024/11/21/241121/","excerpt":"å¤§äºŒå­¦ä¹ STM32G4ç³»åˆ—çš„ç¬”è®°","text":"å¤§äºŒå­¦ä¹ STM32G4ç³»åˆ—çš„ç¬”è®° pdfåµŒå…¥ä½¿ç”¨äº†pdf.jsæ’ä»¶ï¼Œhexo-pdfè¿™ä¸ªæ’ä»¶åœ¨ç§»åŠ¨ç«¯ä¸èƒ½å¾ˆå¥½åœ°æ˜¾ç¤º","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"UARTæ”¶å‘å¤„ç†å‡½æ•°","slug":"241020","date":"2024-10-20T02:51:00.000Z","updated":"2025-08-19T15:35:37.729Z","comments":true,"path":"2024/10/20/241020/","link":"","permalink":"https://miustannis.github.io/2024/10/20/241020/","excerpt":"","text":"UARTï¼ˆUniversal Asynchronous Receiver/Transmitterï¼‰æ˜¯ä¸€ç§ä¸²è¡Œé€šä¿¡åè®®ï¼Œåœ¨åµŒå…¥å¼ç³»ç»Ÿå’Œå¾®æ§åˆ¶å™¨é—´æ•°æ®ä¼ è¾“ä¸­å‘æŒ¥ç€æ ¸å¿ƒä½œç”¨ã€‚UARTåè®®é€šè¿‡å¼‚æ­¥æ–¹å¼ä¼ è¾“æ•°æ®ï¼Œä¸ä¾èµ–äºå…±äº«æ—¶é’Ÿä¿¡å·ï¼Œç®€åŒ–äº†é€šä¿¡çº¿è·¯çš„éœ€æ±‚ã€‚æ¯æ¬¡ä¼ è¾“åŒ…æ‹¬èµ·å§‹ä½ã€æ•°æ®ä½ã€å¯é€‰çš„å¥‡å¶æ ¡éªŒä½ä»¥åŠåœæ­¢ä½ï¼Œè¿™ç§ç»“æ„æ”¯æŒä»ç®€å•çš„ä¼ æ„Ÿå™¨åˆ°å¤æ‚çš„å¤„ç†å™¨ä¹‹é—´çš„å¯é æ•°æ®äº¤æ¢ã€‚ å…¶é‡è¦æ€§è¿˜ä½“ç°åœ¨å…¶å¹¿æ³›çš„å…¼å®¹æ€§å’Œä½æˆæœ¬å®ç°ä¸Šã€‚å®ƒå¯ä»¥é€šè¿‡ç®€å•çš„ä¸¤çº¿ï¼ˆTXå’ŒRXï¼‰æ¥å£å®ç°å…¨åŒå·¥é€šä¿¡ï¼Œæå¤§åœ°é™ä½äº†ç³»ç»Ÿçš„ç¡¬ä»¶å¤æ‚æ€§ã€‚æ­¤å¤–ï¼ŒUARTé€šä¿¡åè®®å¯ä»¥é€‚åº”ä¸åŒçš„æ³¢ç‰¹ç‡è®¾ç½®ï¼Œä½¿å…¶èƒ½å¤Ÿçµæ´»åœ°è°ƒæ•´ä»¥åŒ¹é…ç‰¹å®šåº”ç”¨çš„é€Ÿåº¦è¦æ±‚ã€‚åœ¨è®¸å¤šå·¥ä¸šå’Œæ¶ˆè´¹ç”µå­äº§å“ä¸­ï¼ŒUARTä»ç„¶æ˜¯å®ç°å¯é ä¸²è¡Œé€šä¿¡çš„é¦–é€‰æŠ€æœ¯ï¼Œå°¤å…¶åœ¨èµ„æºå—é™çš„ç¯å¢ƒä¸­æ˜¾ç¤ºå‡ºå…¶é«˜æ•ˆå’Œç»æµçš„ä¼˜åŠ¿ã€‚ï¼ˆä»¥ä¸Šå‡ä¸ºGPTç”Ÿæˆï¼‰ åœ¨è¿›è¡Œä¼ æ„Ÿå™¨æµ‹è¯•æ—¶ï¼Œå¸¸ç”¨åˆ°UARTï¼Œè¿™é‡Œmarkä¸€ä¸‹è‡ªå·±å¸¸ç”¨çš„HALåº“å‡½æ•°å°è£…ï¼Œå…å¾—åç»­ä¸€ç›´ç¿»ä¹‹å‰çš„ç¨‹åº å‡½æ•°éœ€è¦ç”¨åˆ°çš„å…¨å±€å˜é‡å¦‚ä¸‹ï¼š char send[20] = &#123;0&#125;; //ä¼ è¾“ç”¨å­—ç¬¦æ•°ç»„ï¼Œå‚¨å­˜å­—ç¬¦ä¸² uint8_t rx_buffer = 0; //æ¥æ”¶å­—ç¬¦ç¼“å†²åŒº char rx_receiver[20] = &#123;0&#125;; //æ¥æ”¶ç”¨å­—ç¬¦æ•°ç»„ uint8_t rx_num = 0; //æ¥æ”¶å­—ç¬¦æ•°é‡ uint8_t uart_start_flag = 0; //æ¥æ”¶æ ‡å¿—ä½ __IO uint32_t uart_gettick = 0; //ç³»ç»Ÿæ—¶é’Ÿæ¯”è¾ƒå˜é‡ /* æµ‹è¯•å˜é‡ uint16_t pwm_duty = 0; uint8_t startbegin = 0xff; uint8_t startbegin2 = 0x00; */ åœ¨ç¡¬ä»¶é…ç½®æ—¶è¦æ‰“å¼€UARTä¸­æ–­ï¼š HAL_UART_Receive_IT(&amp;huart1 , &amp;rx_buffer, 1); ä¸­æ–­å›è°ƒå‡½æ•°å¦‚ä¸‹ï¼š void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) &#123; if(rx_num == 0)&#123; uart_gettick = uwTick; uart_start_flag = 1; &#125; if(uart_start_flag == 1)&#123; rx_receiver[rx_num] = rx_buffer; rx_num++; &#125; HAL_UART_Receive_IT(&amp;huart1 , &amp;rx_buffer, 1); &#125; ä¸»å¾ªç¯ä¸­çš„å¤„ç†å‡½æ•°å¦‚ä¸‹ï¼š void UART_RX_PROC(void) &#123; if((( uwTick- uart_gettick ) >=10) &amp;&amp; (( uwTick- uart_gettick ) &lt;=600) &amp;&amp; (uart_start_flag == 1))&#123; if(rx_receiver[0] == '&amp;' )&#123; if( rx_num == 2) &#123; //ç¤ºä¾‹ï¼šä¼ è¾“pwmå ç©ºæ¯” pwm_duty = rx_receiver[1]-'0'; &#125; else if( rx_num == 3)&#123; pwm_duty = (rx_receiver[1]-'0')*10 + rx_receiver[2]-'0'; &#125; else if( rx_num == 4)&#123; pwm_duty = (rx_receiver[1]-'0')*100 + (rx_receiver[2]-'0')*10 + rx_receiver[3]-'0'; &#125; else if ( rx_num >= 5)&#123; pwm_duty = 1000; &#125; &#125; HAL_UART_Transmit(&amp;huart1, &amp;startbegin, 1,0xffff); HAL_UART_Transmit(&amp;huart1, &amp;startbegin2, 1,0xffff); HAL_UART_Transmit(&amp;huart1, &amp;startbegin, 1,0xffff); rx_num = 0; uart_start_flag = 0; &#125; &#125; è¿™é‡Œçš„å‡½æ•°ä¸»è¦æ˜¯ç”¨ä»¥å¤„ç†å­—ç¬¦ä¸²çš„ï¼Œåº”ä»˜ä¸€äº›çš„ç®€å•çš„åº”ç”¨å·²ç»å¤Ÿç”¨äº†ï¼Œå½“ç„¶ï¼Œä¹Ÿèƒ½åœ¨æ­¤åŸºç¡€ä¸Šæ‰©å±•ã€‚","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"TFTLCDé©±åŠ¨","slug":"240928","date":"2024-09-28T06:00:30.000Z","updated":"2025-08-19T15:35:47.906Z","comments":true,"path":"2024/09/28/240928/","link":"","permalink":"https://miustannis.github.io/2024/09/28/240928/","excerpt":"","text":"åœ¨ä½¿ç”¨Img2LCDå–æ¨¡è½¯ä»¶å’ŒST7735Sé©±åŠ¨ICæ§åˆ¶LCDæ—¶ï¼Œå‘ç°APIä¸­æ˜¾ç¤ºå›¾ç‰‡çš„å‡½æ•°è°ƒç”¨åæ˜¾ç¤ºå¼‚å¸¸ åŸå‡½æ•°ï¼š void ST7735_DrawImage(uint16_t x, uint16_t y, uint16_t w, uint16_t h, const uint16_t* data) &#123; if((x >= ST7735_WIDTH) || (y >= ST7735_HEIGHT)) return; if((x + w - 1) >= ST7735_WIDTH) return; if((y + h - 1) >= ST7735_HEIGHT) return; ST7735_Select(); ST7735_SetAddressWindow(x, y, x+w-1, y+h-1); ST7735_WriteData((uint8_t*)data, sizeof(uint16_t)*w*h); ST7735_Unselect(); &#125; è¾“å…¥æ•°æ®è¦æ±‚16ä½rgb565æ ¼å¼å›¾ç‰‡ï¼Œä¸Img2LCDå–æ¨¡è½¯ä»¶ä¸¤ä¸ª8ä½æ•°è¡¨ç¤ºä¸€ä¸ªåƒç´ ç‚¹çš„ç¼–ç é€»è¾‘ä¸åŒï¼Œé¦–æ¬¡ä¿®æ”¹ä»…æ”¹äº†åŸå‡½æ•°è¾“å…¥æ•°æ®çš„æ ¼å¼ï¼šå°†data16ä½å¸¸é‡æ•°æ®æŒ‡é’ˆç±»å‹æ”¹ä¸º8ä½æ— ç¬¦å·å˜é‡æŒ‡é’ˆç±»å‹ï¼Œä¸”åœ¨spiå†™å…¥æ•°æ®æ—¶å°†æ•°æ®é‡ä¹˜ä»¥2ï¼Œä¿®æ”¹åçš„å‡½æ•°å¦‚ä¸‹ï¼š void ST7735_DrawImage8bit_Img2LCD(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t* data) &#123; if((x >= ST7735_WIDTH) || (y >= ST7735_HEIGHT)) return; if((x + w - 1) >= ST7735_WIDTH) return; if((y + h - 1) >= ST7735_HEIGHT) return; ST7735_Select(); ST7735_SetAddressWindow(x, y, x+w-1, y+h-1); ST7735_WriteData((uint8_t*)data, sizeof(uint8_t)*w*h*2); ST7735_Unselect(); &#125; ä½†æ˜¯çƒ§å½•æµ‹è¯•åLCDæ˜¾ç¤ºé¢œè‰²å¼‚å¸¸ä¸”è¾¹ç¼˜æ¨¡ç³Šï¼Œåˆæ­¥æ¨æµ‹æ˜¯å›¾ç‰‡æ•°æ®åŸæœ¬çš„é—®é¢˜ï¼Œè€ƒè™‘åˆ°å¯èƒ½2ä¸ª8ä½æ•°æ®åˆå¹¶æ—¶é«˜8ä½ä¸ä½8ä½çš„é¡ºåºåäº†ï¼Œåœ¨MATLABä¸­è¿›è¡Œæ•°ç»„å…ƒç´ ä¸¤ä¸¤ç¿»è½¬éªŒè¯ï¼š function swappedArray = swapPairs(inputArray) if iscolumn(inputArray) inputArray = inputArray'; end n = length(inputArray); if mod(n, 2) ~= 0 inputArray(end+1) = NaN; end swappedArray = inputArray; swappedArray(1:2:end) = inputArray(2:2:end); swappedArray(2:2:end) = inputArray(1:2:end); swappedArray = swappedArray(~isnan(swappedArray)); end å°†åŸå§‹å›¾ç‰‡æ•°æ®å¤„ç†åå†è¿›è¡Œçƒ§å½•ï¼Œå‘ç°æ˜¾ç¤ºæ­£å¸¸ï¼Œé—®é¢˜å®šä½åˆ°æ•°ç»„å…ƒç´ çš„å†™å…¥é¡ºåºï¼Œè§£å†³æ–¹æ³•è¾ƒå¤šï¼Œè¿™é‡Œæˆ‘ç›´æ¥åœ¨å‡½æ•°ä¸­å°†åŸå§‹æ•°ç»„å˜æ¢ï¼Œæœ€ç»ˆçš„å‡½æ•°å¦‚ä¸‹ï¼š void ST7735_DrawImage8bit_Img2LCD(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint8_t* data) &#123; uint32_t i = 0; uint8_t temp = 0; if((x >= ST7735_WIDTH) || (y >= ST7735_HEIGHT)) return; if((x + w - 1) >= ST7735_WIDTH) return; if((y + h - 1) >= ST7735_HEIGHT) return; /* Swap adjacent elements in the data array */ for ( i = 0; i &lt; w * h * 2; i += 2) &#123; if (i + 1 &lt; w * h * 2) &#123; temp = data[i]; data[i] = data[i + 1]; data[i + 1] = temp; &#125; &#125; ST7735_Select(); ST7735_SetAddressWindow(x, y, x+w-1, y+h-1); ST7735_WriteData((uint8_t*)data, sizeof(uint8_t)*w*h*2); ST7735_Unselect(); &#125; çœ‹çœ‹æ˜¾ç¤ºæ•ˆæœï¼š","categories":[{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"Hexoåšå®¢æ’å…¥å›¾ç‰‡","slug":"220321","date":"2022-03-21T01:32:46.000Z","updated":"2026-01-27T03:19:13.072Z","comments":true,"path":"2022/03/21/220321/","link":"","permalink":"https://miustannis.github.io/2022/03/21/220321/","excerpt":"","text":"ç›®å½•ï¼š æ’å…¥å›¾ç‰‡ æ›´æ”¹ç›¸å¯¹ä½ç½® æ’å…¥å›¾ç‰‡ä¹‹å‰æ‰“ç®—åœ¨æ–‡ç« ä¸­æ’å…¥å›¾ç‰‡ï¼Œé…ç½®çš„è¿‡ç¨‹ä¸­é‡åˆ°äº†ä¸€äº›é—®é¢˜ã€‚ æƒ³åœ¨åšå®¢ä¸­å¼•ç”¨å¤–ç«™å›¾ç‰‡é—®é¢˜ä¸å¤§ï¼Œä½†Hexoé»˜è®¤æ’å…¥å›¾ç‰‡åªæœ‰è¿™ä¸€ä¸ªæ–¹æ³•ï¼Œå¯¹æœ‰æœ¬åœ°åŒ–éœ€æ±‚çš„äººç¾¤æ¥è¯´ä¸å¤Ÿæ–¹ä¾¿ï¼Œæ­¤æ—¶å¯ä»¥å®‰è£…ä¸€ä¸ªæ»¡è¶³æœ¬åœ°å›¾ç‰‡å¼•ç”¨çš„æ’ä»¶npm install https://github.com/CodeFalling/hexo-asset-image â€“save ä¿®æ”¹_config.ymlæ–‡ä»¶ï¼Œå°†post_asset_folder:å€¼æ”¹ä¸ºtrueã€‚ ä¹‹ååœ¨æ–°å»ºä¸€ä¸ªåšå®¢çš„åŒæ—¶ä¼šç”ŸæˆåŒåæ–‡ä»¶å¤¹ï¼Œå°†éœ€æ’å…¥çš„å›¾ç‰‡æ”¾å…¥è¯¥æ–‡ä»¶å¤¹å³å¯ã€‚æ–‡ç« ä¸­çš„å…·ä½“å¼•ç”¨ä»£ç ä¸ºä»¥ä¸‹æ ¼å¼ï¼š(åæ¥å‘ç°åœ¨sourceæ–‡ä»¶å¤¹é‡Œæ–°å»ºä¸€ä¸ªåä¸ºimagesçš„æ–‡ä»¶å¤¹å­˜æ”¾å›¾ç‰‡ä¹Ÿè¡Œ)![](1/image.jpg) æ›´æ”¹ç›¸å¯¹ä½ç½®ä½†è¿™ç§æ–¹æ³•åœ¨PCç«¯æœ‰ä¸€ä¸ªé»˜è®¤çš„é—®é¢˜å°±æ˜¯å›¾ç‰‡æ’å…¥åä¼šè‡ªåŠ¨å·¦å¯¹é½ï¼Œæƒ³è¦å®ç°å±…ä¸­å¯¹é½ï¼Œå¯ä»¥åœ¨markdownå¼•ç”¨ä»£ç å¤–éƒ¨æ·»åŠ centerå…ƒç´ ï¼Œæˆ–è€…ç›´æ¥æ·»åŠ htmlå…ƒç´ ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š&lt;center> ![...](xxx) &lt;/center> &lt;!--or --> &lt;div align=center> ![...](xxx) &lt;/div>(å› ä¸ºæˆ‘ç”¨VScodeæ¥æ‰“å¼€åšå®¢çš„mdæ–‡ä»¶è¿›è¡Œç¼–è¾‘ï¼Œåœ¨ä¸Šä¼ è‡³æœ¬åœ°ç½‘é¡µæ—¶ä¸€å¼€å§‹å‘ç°å›¾ç‰‡æ— æ³•åŠ è½½ï¼Œåæ¥æ’æŸ¥å¾—å‡ºå±…ä¸­å‘½ä»¤ä»£ç é—´çš„ç©ºè¡Œæ˜¯å¿…è¦çš„ï¼Œä¸çŸ¥é“å…¶ä»–ç¼–è¾‘å™¨æ˜¯å¦æœ‰è¿™æ ·çš„é—®é¢˜ã€‚) è¿˜å¯ä»¥ç›´æ¥ä¿®æ”¹cssæ–‡ä»¶ï¼Œå› ä¸ºmarkdownæ’å…¥å›¾ç‰‡çš„ä»£ç åœ¨æœ€ç»ˆæ¸²æŸ“çš„æ—¶å€™å˜ä¸ºhtmlä¸­çš„imgå…ƒç´ ã€‚å› æ­¤å¯ä»¥ç›´æ¥å»åšå®¢ä¸»é¢˜æ–‡ä»¶çš„æºä»£ç ä¸­ï¼Œæ‰¾åˆ°æ§åˆ¶æ–‡ç« å†…å›¾ç‰‡æ˜¾ç¤ºæ ·å¼çš„cssä»£ç ï¼Œå°†å…¶ä¿®æ”¹æˆæ°´å¹³å±…ä¸­å³å¯ã€‚å‰ç«¯ç¼–ç¨‹ä¸­ä¿®æ”¹æ°´å¹³å±…ä¸­çš„æ–¹æ³•éå¸¸å¤šï¼Œä»¥ä¸‹æ˜¯ç½‘ä¸Šèµ„æºä¸­æä¾›çš„å…¶ä¸­ä¸€ç§ï¼š ä¸€èˆ¬æƒ…å†µä¸‹å¯ä»¥åœ¨Hexoåšå®¢æ–‡ä»¶å¤¹è¿›å…¥åˆ°ä¸»é¢˜æ¨¡æ¿çš„themes-&gt;(ä¸»é¢˜åç§°æ–‡ä»¶å¤¹)-&gt;source-&gt;css-&gt;_partialä¸­ï¼Œæ‰¾åˆ°post.stylæ–‡ä»¶ï¼Œè¯¥postæ–‡ä»¶ä¸­ä¿å­˜çš„å°±æ˜¯æ–‡ç« è¯¦æƒ…é¡µé‡Œé¢çš„æ˜¾ç¤ºæ ·å¼ã€‚ç„¶åæ‰¾åˆ°é‡Œé¢æ­£ç¡®çš„imgå…ƒç´ ï¼Œä¿®æ”¹å…¶æ ·å¼ï¼Œå¢åŠ margin 0 autoè¿™è¡ŒæŒ‡ä»¤ã€‚å¦‚ä¸‹:.post-content position relative color c-666 img max-width 100% cursor pointer display block margin 0 autoç„¶åå¯ä»¥å®ç°äº†ã€‚ä½†æˆ‘åœ¨è‡ªå·±å½“å‰ä½¿ç”¨çš„ä¸»é¢˜ä¸­å¹¶æ²¡æœ‰æ‰¾åˆ°ç›¸å…³è¯­æ®µï¼Œç”±äºæŠ€æœ¯æ¯”è¾ƒæ‹‰è·¨ï¼Œæˆ‘å†³å®šè¿˜æ˜¯å…ˆè€å®ç”¨å‰ä¸¤ç§å§ã€‚ [åæœŸè¡¥ä¸ï¼šä½ éœ€è¦ä¸€æ¬¾åä¸ºTyporaçš„markdownç¼–è¾‘è½¯ä»¶]","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://miustannis.github.io/tags/Hexo/"}]},{"title":"Hexoåšå®¢å¯ç”¨æµ‹è¯•","slug":"220314","date":"2022-03-14T07:08:39.000Z","updated":"2025-08-20T04:15:33.915Z","comments":true,"path":"2022/03/14/220314/","link":"","permalink":"https://miustannis.github.io/2022/03/14/220314/","excerpt":"","text":"test æµ‹è¯• è©¦é¨“ ãƒ†ã‚¹ãƒˆ","categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://miustannis.github.io/tags/Hexo/"}]}],"categories":[{"name":"Projects & Builds","slug":"Projects-Builds","permalink":"https://miustannis.github.io/categories/Projects-Builds/"},{"name":"Learning Record","slug":"Learning-Record","permalink":"https://miustannis.github.io/categories/Learning-Record/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://miustannis.github.io/tags/C/"},{"name":"CS","slug":"CS","permalink":"https://miustannis.github.io/tags/CS/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://miustannis.github.io/tags/Algorithm/"},{"name":"Android","slug":"Android","permalink":"https://miustannis.github.io/tags/Android/"},{"name":"å›¾åƒå¤„ç†","slug":"å›¾åƒå¤„ç†","permalink":"https://miustannis.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"åµŒå…¥å¼","slug":"åµŒå…¥å¼","permalink":"https://miustannis.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"Hexo","slug":"Hexo","permalink":"https://miustannis.github.io/tags/Hexo/"}]}